const t='{"documentCount":330,"nextId":330,"documentIds":{"0":"/guide/README.html#导航","1":"/guide/IO库.html#第八章-io库","2":"/guide/IO库.html#io类","3":"/guide/IO库.html#io对象无拷贝或赋值","4":"/guide/IO库.html#条件状态","5":"/guide/IO库.html#管理输出缓冲","6":"/guide/IO库.html#文件输入输出","7":"/guide/IO库.html#使用文件流对象","8":"/guide/IO库.html#文件模式","9":"/guide/IO库.html#string流","10":"/guide/IO库.html#使用istringstream","11":"/guide/IO库.html#使用ostringstream","12":"/guide/关联容器.html#第十一章-关联容器","13":"/guide/关联容器.html#使用关联容器","14":"/guide/关联容器.html#关联容器概述","15":"/guide/关联容器.html#定义关联容器","16":"/guide/关联容器.html#关键字类型的要求","17":"/guide/关联容器.html#pair类型","18":"/guide/关联容器.html#关联容器操作","19":"/guide/关联容器.html#关联容器迭代器","20":"/guide/关联容器.html#添加元素","21":"/guide/关联容器.html#删除元素","22":"/guide/关联容器.html#map的下标操作","23":"/guide/关联容器.html#访问元素","24":"/guide/关联容器.html#无序容器","25":"/guide/函数.html#第六章-函数","26":"/guide/函数.html#函数基础","27":"/guide/函数.html#局部对象","28":"/guide/函数.html#函数声明","29":"/guide/函数.html#分离式编译","30":"/guide/函数.html#参数传递","31":"/guide/函数.html#传值参数","32":"/guide/函数.html#传引用参数","33":"/guide/函数.html#const形参和实参","34":"/guide/函数.html#数组形参","35":"/guide/函数.html#main-处理命令行选项","36":"/guide/函数.html#含有可变形参的函数","37":"/guide/函数.html#返回类型和return语句","38":"/guide/函数.html#无返回值函数","39":"/guide/函数.html#有返回值函数","40":"/guide/函数.html#返回数组的指针","41":"/guide/函数.html#函数重载","42":"/guide/函数.html#重载与作用域","43":"/guide/函数.html#特殊用途语言特性","44":"/guide/函数.html#默认实参","45":"/guide/函数.html#内联函数和constexpr函数","46":"/guide/函数.html#调试帮助","47":"/guide/函数.html#函数匹配","48":"/guide/函数.html#实参类型转换","49":"/guide/函数.html#函数指针","50":"/guide/动态内存.html#第十二章-动态内存","51":"/guide/动态内存.html#动态内存与智能指针","52":"/guide/动态内存.html#shared-ptr类","53":"/guide/动态内存.html#直接管理内存","54":"/guide/动态内存.html#shared-ptr和new结合使用","55":"/guide/动态内存.html#智能指针和异常","56":"/guide/动态内存.html#unique-ptr","57":"/guide/动态内存.html#weak-ptr","58":"/guide/动态内存.html#动态数组","59":"/guide/动态内存.html#new和数组","60":"/guide/动态内存.html#allocator类","61":"/guide/变量和基本类型.html#第二章-变量和基本类型","62":"/guide/变量和基本类型.html#基本内置类型","63":"/guide/变量和基本类型.html#算术类型","64":"/guide/变量和基本类型.html#类型转换","65":"/guide/变量和基本类型.html#字面值常量","66":"/guide/变量和基本类型.html#变量","67":"/guide/变量和基本类型.html#变量定义","68":"/guide/变量和基本类型.html#变量声明和定义的关系","69":"/guide/变量和基本类型.html#标识符","70":"/guide/变量和基本类型.html#名字的作用域","71":"/guide/变量和基本类型.html#复合类型","72":"/guide/变量和基本类型.html#引用","73":"/guide/变量和基本类型.html#指针","74":"/guide/变量和基本类型.html#理解复合类型的声明","75":"/guide/变量和基本类型.html#const限定符","76":"/guide/变量和基本类型.html#const的引用","77":"/guide/变量和基本类型.html#指针和const","78":"/guide/变量和基本类型.html#顶层const","79":"/guide/变量和基本类型.html#constexpr和常量表达式","80":"/guide/变量和基本类型.html#处理类型","81":"/guide/变量和基本类型.html#类型别名","82":"/guide/变量和基本类型.html#auto类型说明符","83":"/guide/变量和基本类型.html#decltype类型指示符","84":"/guide/变量和基本类型.html#自定义数据结构","85":"/guide/变量和基本类型.html#定义sales-data类型","86":"/guide/变量和基本类型.html#编写自己的头文件","87":"/guide/字符串、向量和数组.html#第三章-字符串、向量和数组","88":"/guide/字符串、向量和数组.html#命名空间的using声明","89":"/guide/字符串、向量和数组.html#标准库类型string","90":"/guide/字符串、向量和数组.html#定义和初始化string对象","91":"/guide/字符串、向量和数组.html#string对象上的操作","92":"/guide/字符串、向量和数组.html#处理string对象中的字符","93":"/guide/字符串、向量和数组.html#标准库类型vector","94":"/guide/字符串、向量和数组.html#定义和初始化vector对象","95":"/guide/字符串、向量和数组.html#向vector中添加元素","96":"/guide/字符串、向量和数组.html#其它vector操作","97":"/guide/字符串、向量和数组.html#迭代器介绍","98":"/guide/字符串、向量和数组.html#使用迭代器","99":"/guide/字符串、向量和数组.html#迭代器运算","100":"/guide/字符串、向量和数组.html#数组","101":"/guide/字符串、向量和数组.html#定义和初始化内置数组","102":"/guide/字符串、向量和数组.html#访问数组元素","103":"/guide/字符串、向量和数组.html#指针和数组","104":"/guide/字符串、向量和数组.html#c风格字符串","105":"/guide/字符串、向量和数组.html#多维数组","106":"/guide/开始.html#第一章-开始","107":"/guide/开始.html#编写一个简单的c-程序","108":"/guide/开始.html#编译、运行程序","109":"/guide/开始.html#初识输入输出","110":"/guide/开始.html#注释简介","111":"/guide/开始.html#控制流","112":"/guide/开始.html#while语句","113":"/guide/开始.html#for语句","114":"/guide/开始.html#读取数量不定的输入数据","115":"/guide/开始.html#if语句","116":"/guide/开始.html#类简介","117":"/guide/开始.html#初识成员函数","118":"/guide/拷贝控制.html#第十三章-拷贝控制","119":"/guide/拷贝控制.html#拷贝、赋值与销毁","120":"/guide/拷贝控制.html#拷贝构造函数","121":"/guide/拷贝控制.html#拷贝赋值运算符","122":"/guide/拷贝控制.html#析构函数","123":"/guide/拷贝控制.html#三-五法则","124":"/guide/拷贝控制.html#使用-default","125":"/guide/拷贝控制.html#阻止拷贝","126":"/guide/拷贝控制.html#拷贝控制和资源管理","127":"/guide/拷贝控制.html#行为像值的类","128":"/guide/拷贝控制.html#定义行为像指针的类","129":"/guide/拷贝控制.html#交换操作","130":"/guide/拷贝控制.html#对象移动","131":"/guide/拷贝控制.html#右值引用","132":"/guide/拷贝控制.html#移动构造函数和移动赋值运算符","133":"/guide/拷贝控制.html#右值引用和成员函数","134":"/guide/操作重载与类型转换.html#第十四章-操作重载与类型转换","135":"/guide/操作重载与类型转换.html#基本概念","136":"/guide/操作重载与类型转换.html#输入和输出运算符","137":"/guide/操作重载与类型转换.html#重载输出运算符","138":"/guide/操作重载与类型转换.html#重载输入运算符","139":"/guide/操作重载与类型转换.html#算术和关系运算符","140":"/guide/操作重载与类型转换.html#相等运算符","141":"/guide/操作重载与类型转换.html#赋值运算符","142":"/guide/操作重载与类型转换.html#下标运算符","143":"/guide/操作重载与类型转换.html#递增和递减运算符","144":"/guide/操作重载与类型转换.html#成员访问运算符","145":"/guide/操作重载与类型转换.html#函数调用运算符","146":"/guide/操作重载与类型转换.html#lambda是函数对象","147":"/guide/操作重载与类型转换.html#标准库定义的函数对象","148":"/guide/操作重载与类型转换.html#可调用对象与function","149":"/guide/操作重载与类型转换.html#重载、类型转换与运算符","150":"/guide/操作重载与类型转换.html#类型转换运算符","151":"/guide/标准库特殊设施.html#第17章-标准库特殊设施","152":"/guide/标准库特殊设施.html#tuple类型","153":"/guide/标准库特殊设施.html#定义和初始化tuple","154":"/guide/标准库特殊设施.html#bitset类型","155":"/guide/标准库特殊设施.html#定义和初始化bitset","156":"/guide/标准库特殊设施.html#bitset操作","157":"/guide/标准库特殊设施.html#正则表达式","158":"/guide/标准库特殊设施.html#随机数","159":"/guide/标准库特殊设施.html#随机数引擎和分布","160":"/guide/标准库特殊设施.html#io库再探","161":"/guide/标准库特殊设施.html#格式化输入与输出","162":"/guide/标准库特殊设施.html#未格式化的输入-输出操作","163":"/guide/标准库特殊设施.html#流随机访问","164":"/guide/模板与泛型编程.html#第十六章-模板与泛型编程","165":"/guide/模板与泛型编程.html#定义模板","166":"/guide/模板与泛型编程.html#函数模板","167":"/guide/模板与泛型编程.html#类模板","168":"/guide/模板与泛型编程.html#模板参数","169":"/guide/模板与泛型编程.html#成员模板","170":"/guide/模板与泛型编程.html#控制实例化","171":"/guide/模板与泛型编程.html#模板实参推断","172":"/guide/模板与泛型编程.html#类型转换与模板类型参数","173":"/guide/模板与泛型编程.html#函数模板显式实参","174":"/guide/模板与泛型编程.html#尾置返回类型与类型转换","175":"/guide/模板与泛型编程.html#函数指针和实参推断","176":"/guide/模板与泛型编程.html#模板实参推断和引用","177":"/guide/模板与泛型编程.html#理解std-move","178":"/guide/模板与泛型编程.html#转发","179":"/guide/模板与泛型编程.html#重载与模板","180":"/guide/模板与泛型编程.html#可变参数模板","181":"/guide/模板与泛型编程.html#编写可变参数函数模板","182":"/guide/模板与泛型编程.html#包扩展","183":"/guide/模板与泛型编程.html#模板特例化","184":"/guide/泛型算法.html#第十章-泛型算法","185":"/guide/泛型算法.html#概述","186":"/guide/泛型算法.html#初识泛型算法","187":"/guide/泛型算法.html#只读算法","188":"/guide/泛型算法.html#写容器元素的算法","189":"/guide/泛型算法.html#重排元素的算法","190":"/guide/泛型算法.html#定义操作","191":"/guide/泛型算法.html#向算法传递函数","192":"/guide/泛型算法.html#lambda表达式","193":"/guide/泛型算法.html#lambda捕获和返回","194":"/guide/泛型算法.html#参数绑定","195":"/guide/泛型算法.html#再探迭代器","196":"/guide/泛型算法.html#插入迭代器","197":"/guide/泛型算法.html#iostream迭代器","198":"/guide/泛型算法.html#反向迭代器","199":"/guide/泛型算法.html#泛型算法结构","200":"/guide/泛型算法.html#_5类迭代器","201":"/guide/泛型算法.html#算法的形参模式","202":"/guide/泛型算法.html#算法命名规范","203":"/guide/泛型算法.html#特定容器的算法","204":"/guide/用于大型程序的工具.html#第18章-用于大型程序的工具","205":"/guide/用于大型程序的工具.html#异常处理","206":"/guide/用于大型程序的工具.html#抛出异常","207":"/guide/用于大型程序的工具.html#捕获异常","208":"/guide/用于大型程序的工具.html#noexception异常说明","209":"/guide/用于大型程序的工具.html#命名空间","210":"/guide/用于大型程序的工具.html#命名空间的定义","211":"/guide/用于大型程序的工具.html#使用命名空间的成员","212":"/guide/用于大型程序的工具.html#类、命名空间与作用域","213":"/guide/用于大型程序的工具.html#重载与命名空间","214":"/guide/用于大型程序的工具.html#多重继承与虚继承","215":"/guide/用于大型程序的工具.html#多重继承","216":"/guide/用于大型程序的工具.html#类型转换与多个基类","217":"/guide/用于大型程序的工具.html#多重继承下的类作用域","218":"/guide/用于大型程序的工具.html#虚继承","219":"/guide/用于大型程序的工具.html#构造函数与虚继承","220":"/guide/特殊工具与技术.html#第19章-特殊工具与技术","221":"/guide/特殊工具与技术.html#控制内存分配","222":"/guide/特殊工具与技术.html#重载new和delete","223":"/guide/特殊工具与技术.html#定位new表达式","224":"/guide/特殊工具与技术.html#运行时类型识别","225":"/guide/特殊工具与技术.html#dynamic-cast运算符","226":"/guide/特殊工具与技术.html#typeid运算符","227":"/guide/特殊工具与技术.html#type-info类","228":"/guide/特殊工具与技术.html#枚举类型","229":"/guide/特殊工具与技术.html#类成员指针","230":"/guide/特殊工具与技术.html#成员函数指针","231":"/guide/特殊工具与技术.html#将成员函数用作可调用对象","232":"/guide/特殊工具与技术.html#嵌套类","233":"/guide/特殊工具与技术.html#union-一种节省空间的类","234":"/guide/特殊工具与技术.html#局部类","235":"/guide/特殊工具与技术.html#固有的不可移植的特性","236":"/guide/特殊工具与技术.html#链接指示-extern-c","237":"/guide/类.html#第七章-类","238":"/guide/类.html#定义抽象数据类型","239":"/guide/类.html#定义类相关的非成员函数","240":"/guide/类.html#构造函数","241":"/guide/类.html#拷贝、赋值和析构","242":"/guide/类.html#访问控制与封装","243":"/guide/类.html#友元","244":"/guide/类.html#类的其它特性","245":"/guide/类.html#类成员再探","246":"/guide/类.html#返回-this的成员函数","247":"/guide/类.html#类类型","248":"/guide/类.html#友元再探","249":"/guide/类.html#类的作用域","250":"/guide/类.html#名字查找与类的作用域","251":"/guide/类.html#构造函数再探","252":"/guide/类.html#构造函数初始值列表","253":"/guide/类.html#委托构造函数","254":"/guide/类.html#默认构造函数的作用","255":"/guide/类.html#隐式的类类型转换","256":"/guide/类.html#聚合类","257":"/guide/类.html#字面值常量类-literal-classes","258":"/guide/类.html#类的静态成员","259":"/guide/表达式.html#第四章-表达式","260":"/guide/表达式.html#基础","261":"/guide/表达式.html#基本概念","262":"/guide/表达式.html#优先级与结合律","263":"/guide/表达式.html#求值顺序","264":"/guide/表达式.html#算术运算符","265":"/guide/表达式.html#逻辑和关系运算符","266":"/guide/表达式.html#赋值运算符","267":"/guide/表达式.html#递增和递减运算符","268":"/guide/表达式.html#成员访问运算符","269":"/guide/表达式.html#条件运算符","270":"/guide/表达式.html#位运算符","271":"/guide/表达式.html#sizeof运算符","272":"/guide/表达式.html#逗号运算符","273":"/guide/表达式.html#类型转换","274":"/guide/表达式.html#算术转换","275":"/guide/表达式.html#其他隐式转换","276":"/guide/表达式.html#显式转换","277":"/guide/语句.html#第五章-语句","278":"/guide/语句.html#简单语句","279":"/guide/语句.html#语句作用域","280":"/guide/语句.html#条件语句","281":"/guide/语句.html#if语句","282":"/guide/语句.html#switch语句","283":"/guide/语句.html#迭代语句","284":"/guide/语句.html#while语句","285":"/guide/语句.html#传统的for语句","286":"/guide/语句.html#范围for语句","287":"/guide/语句.html#do-while语句","288":"/guide/语句.html#跳转语句","289":"/guide/语句.html#break语句","290":"/guide/语句.html#continue语句","291":"/guide/语句.html#goto语句","292":"/guide/语句.html#try语句块和异常处理","293":"/guide/语句.html#throw表达式","294":"/guide/语句.html#try语句块","295":"/guide/语句.html#标准异常","296":"/guide/面向对象程序设计.html#第十五章-面向对象程序设计","297":"/guide/面向对象程序设计.html#oop概述","298":"/guide/面向对象程序设计.html#定义基类","299":"/guide/面向对象程序设计.html#定义派生类","300":"/guide/面向对象程序设计.html#类型转换与继承","301":"/guide/面向对象程序设计.html#虚函数","302":"/guide/面向对象程序设计.html#抽象基类","303":"/guide/面向对象程序设计.html#访问控制与继承","304":"/guide/面向对象程序设计.html#继承中的类作用域","305":"/guide/面向对象程序设计.html#构造函数与拷贝控制","306":"/guide/面向对象程序设计.html#虚析构函数","307":"/guide/面向对象程序设计.html#合成拷贝控制与继承","308":"/guide/面向对象程序设计.html#派生类的拷贝控制成员","309":"/guide/面向对象程序设计.html#继承的构造函数","310":"/guide/顺序容器.html#第九章-顺序容器","311":"/guide/顺序容器.html#顺序容器概览","312":"/guide/顺序容器.html#容器库概览","313":"/guide/顺序容器.html#迭代器","314":"/guide/顺序容器.html#容器定义和初始化","315":"/guide/顺序容器.html#赋值和拷贝","316":"/guide/顺序容器.html#容器大小操作","317":"/guide/顺序容器.html#关系运算符","318":"/guide/顺序容器.html#顺序容器操作","319":"/guide/顺序容器.html#向顺序容器添加元素","320":"/guide/顺序容器.html#访问元素","321":"/guide/顺序容器.html#删除元素","322":"/guide/顺序容器.html#改变容器大小","323":"/guide/顺序容器.html#容器操作可能使迭代器失效","324":"/guide/顺序容器.html#额外的-string-操作","325":"/guide/顺序容器.html#构造-string-的其他方法","326":"/guide/顺序容器.html#改变-string-的其他方法","327":"/guide/顺序容器.html#string-搜索操作","328":"/guide/顺序容器.html#compare-函数","329":"/guide/顺序容器.html#数值转换"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,40],"1":[2,1,1],"2":[1,2,14],"3":[1,3,6],"4":[1,3,27],"5":[1,3,43],"6":[1,2,4],"7":[1,3,22],"8":[1,3,25],"9":[1,2,8],"10":[1,3,4],"11":[1,3,4],"12":[2,1,13],"13":[1,2,11],"14":[1,2,16],"15":[1,3,35],"16":[1,3,28],"17":[1,3,38],"18":[1,2,21],"19":[1,3,42],"20":[1,3,41],"21":[1,3,11],"22":[1,3,20],"23":[1,3,7],"24":[1,2,5],"25":[2,1,7],"26":[1,2,34],"27":[1,3,58],"28":[1,3,25],"29":[1,3,10],"30":[1,2,19],"31":[1,3,16],"32":[1,3,18],"33":[1,3,56],"34":[1,3,77],"35":[2,3,47],"36":[1,3,37],"37":[1,2,7],"38":[1,3,4],"39":[1,3,55],"40":[1,3,82],"41":[1,2,113],"42":[1,3,13],"43":[1,2,1],"44":[1,3,52],"45":[1,3,33],"46":[1,3,82],"47":[1,2,49],"48":[1,3,21],"49":[1,2,68],"50":[2,1,21],"51":[1,2,31],"52":[2,3,75],"53":[1,3,69],"54":[2,3,28],"55":[1,3,46],"56":[2,3,32],"57":[2,3,45],"58":[1,2,11],"59":[1,3,94],"60":[1,3,64],"61":[2,1,1],"62":[1,2,13],"63":[1,3,53],"64":[1,3,37],"65":[1,3,76],"66":[1,2,7],"67":[1,3,64],"68":[1,3,28],"69":[1,3,17],"70":[1,3,34],"71":[1,2,5],"72":[1,3,31],"73":[1,3,91],"74":[1,3,23],"75":[1,2,27],"76":[1,3,36],"77":[1,3,32],"78":[1,3,36],"79":[1,3,67],"80":[1,2,8],"81":[1,3,27],"82":[1,3,74],"83":[1,3,68],"84":[1,2,9],"85":[2,3,34],"86":[1,3,34],"87":[3,1,1],"88":[1,3,31],"89":[1,3,3],"90":[1,4,42],"91":[1,4,51],"92":[1,4,47],"93":[1,3,18],"94":[1,4,37],"95":[1,4,21],"96":[1,4,41],"97":[1,3,8],"98":[1,4,80],"99":[1,4,30],"100":[1,3,5],"101":[1,4,56],"102":[1,4,23],"103":[1,4,50],"104":[1,4,36],"105":[1,3,58],"106":[2,1,2],"107":[1,2,37],"108":[2,3,12],"109":[1,2,127],"110":[1,2,22],"111":[1,2,7],"112":[1,3,17],"113":[1,3,34],"114":[1,3,24],"115":[1,3,9],"116":[1,2,14],"117":[1,3,25],"118":[2,1,23],"119":[2,2,1],"120":[1,4,34],"121":[1,4,40],"122":[1,4,48],"123":[2,4,28],"124":[1,4,2],"125":[1,4,47],"126":[1,2,38],"127":[1,3,17],"128":[1,3,36],"129":[1,2,36],"130":[1,2,12],"131":[1,3,55],"132":[1,3,102],"133":[1,2,35],"134":[2,1,1],"135":[1,2,67],"136":[1,2,8],"137":[3,3,36],"138":[3,3,38],"139":[1,2,28],"140":[1,3,20],"141":[1,2,43],"142":[1,2,28],"143":[1,2,29],"144":[1,2,18],"145":[1,2,39],"146":[1,3,14],"147":[1,3,47],"148":[1,3,48],"149":[2,2,9],"150":[1,4,101],"151":[2,1,1],"152":[1,2,8],"153":[1,3,95],"154":[1,2,5],"155":[1,3,54],"156":[1,3,83],"157":[1,2,45],"158":[1,2,34],"159":[1,3,88],"160":[1,2,1],"161":[1,3,67],"162":[2,3,44],"163":[1,3,50],"164":[2,1,5],"165":[1,2,1],"166":[1,3,112],"167":[1,3,114],"168":[1,3,104],"169":[1,3,9],"170":[1,3,61],"171":[1,2,10],"172":[1,3,51],"173":[1,3,52],"174":[1,3,57],"175":[1,3,18],"176":[1,3,121],"177":[2,3,47],"178":[1,3,122],"179":[1,2,21],"180":[1,2,73],"181":[1,3,40],"182":[1,3,41],"183":[1,2,47],"184":[2,1,9],"185":[1,2,13],"186":[1,2,8],"187":[1,3,20],"188":[1,3,15],"189":[1,3,6],"190":[1,2,8],"191":[1,3,13],"192":[1,3,34],"193":[1,3,73],"194":[1,3,54],"195":[1,2,19],"196":[1,3,23],"197":[1,3,9],"198":[1,3,11],"199":[1,2,20],"200":[1,3,15],"201":[1,3,27],"202":[1,3,33],"203":[1,2,31],"204":[2,1,12],"205":[1,2,10],"206":[1,3,42],"207":[1,3,95],"208":[1,3,28],"209":[1,2,8],"210":[1,3,39],"211":[1,3,46],"212":[2,3,10],"213":[1,3,40],"214":[1,2,4],"215":[1,3,92],"216":[1,3,38],"217":[1,3,18],"218":[1,3,47],"219":[1,3,47],"220":[2,1,1],"221":[1,2,5],"222":[1,3,121],"223":[1,3,51],"224":[1,2,22],"225":[2,3,55],"226":[1,3,58],"227":[2,3,29],"228":[1,2,44],"229":[1,2,74],"230":[1,3,51],"231":[1,3,74],"232":[1,2,18],"233":[2,2,90],"234":[1,2,15],"235":[1,2,11],"236":[5,3,48],"237":[2,1,26],"238":[1,2,56],"239":[1,3,7],"240":[1,3,65],"241":[2,3,20],"242":[1,2,23],"243":[1,3,18],"244":[1,2,1],"245":[1,3,26],"246":[2,3,22],"247":[1,3,31],"248":[1,3,5],"249":[1,2,8],"250":[1,3,10],"251":[1,2,1],"252":[1,3,16],"253":[1,3,12],"254":[1,3,13],"255":[1,3,11],"256":[1,3,13],"257":[4,3,14],"258":[1,2,38],"259":[2,1,11],"260":[1,2,2],"261":[1,3,42],"262":[1,3,15],"263":[1,3,53],"264":[1,2,43],"265":[1,2,12],"266":[1,2,29],"267":[1,2,37],"268":[1,2,25],"269":[1,2,24],"270":[1,2,59],"271":[1,2,24],"272":[1,2,11],"273":[1,2,31],"274":[1,3,15],"275":[1,3,34],"276":[1,3,97],"277":[2,1,1],"278":[1,2,48],"279":[1,2,25],"280":[1,2,7],"281":[1,3,8],"282":[1,3,30],"283":[1,2,7],"284":[1,3,14],"285":[1,3,11],"286":[1,3,28],"287":[2,3,20],"288":[1,2,9],"289":[1,3,6],"290":[1,3,5],"291":[1,3,47],"292":[1,2,44],"293":[1,3,19],"294":[1,3,63],"295":[1,3,11],"296":[2,1,1],"297":[1,2,63],"298":[1,3,60],"299":[1,3,96],"300":[1,3,35],"301":[1,2,76],"302":[1,2,24],"303":[1,2,108],"304":[1,2,25],"305":[1,2,7],"306":[1,3,29],"307":[1,3,18],"308":[1,3,46],"309":[1,3,47],"310":[2,1,1],"311":[1,2,44],"312":[1,2,18],"313":[1,3,33],"314":[1,3,15],"315":[1,3,16],"316":[1,3,13],"317":[1,3,13],"318":[1,2,5],"319":[1,3,19],"320":[1,3,22],"321":[1,3,12],"322":[1,3,10],"323":[1,3,19],"324":[3,2,4],"325":[3,5,35],"326":[3,5,22],"327":[2,5,24],"328":[2,5,5],"329":[1,5,21]},"averageFieldLength":[1.1757575757575767,2.6606060606060598,32.93333333333335],"storedFields":{"0":{"title":"导航","titles":[]},"1":{"title":"第八章 IO库","titles":[]},"2":{"title":"IO类","titles":["第八章 IO库"]},"3":{"title":"IO对象无拷贝或赋值","titles":["第八章 IO库","IO类"]},"4":{"title":"条件状态","titles":["第八章 IO库","IO类"]},"5":{"title":"管理输出缓冲","titles":["第八章 IO库","IO类"]},"6":{"title":"文件输入输出","titles":["第八章 IO库"]},"7":{"title":"使用文件流对象","titles":["第八章 IO库","文件输入输出"]},"8":{"title":"文件模式","titles":["第八章 IO库","文件输入输出"]},"9":{"title":"string流","titles":["第八章 IO库"]},"10":{"title":"使用istringstream","titles":["第八章 IO库","string流"]},"11":{"title":"使用ostringstream","titles":["第八章 IO库","string流"]},"12":{"title":"第十一章 关联容器","titles":[]},"13":{"title":"使用关联容器","titles":["第十一章 关联容器"]},"14":{"title":"关联容器概述","titles":["第十一章 关联容器"]},"15":{"title":"定义关联容器","titles":["第十一章 关联容器","关联容器概述"]},"16":{"title":"关键字类型的要求","titles":["第十一章 关联容器","关联容器概述"]},"17":{"title":"pair类型","titles":["第十一章 关联容器","关联容器概述"]},"18":{"title":"关联容器操作","titles":["第十一章 关联容器"]},"19":{"title":"关联容器迭代器","titles":["第十一章 关联容器","关联容器操作"]},"20":{"title":"添加元素","titles":["第十一章 关联容器","关联容器操作"]},"21":{"title":"删除元素","titles":["第十一章 关联容器","关联容器操作"]},"22":{"title":"map的下标操作","titles":["第十一章 关联容器","关联容器操作"]},"23":{"title":"访问元素","titles":["第十一章 关联容器","关联容器操作"]},"24":{"title":"无序容器","titles":["第十一章 关联容器"]},"25":{"title":"第六章 函数","titles":[]},"26":{"title":"函数基础","titles":["第六章 函数"]},"27":{"title":"局部对象","titles":["第六章 函数","函数基础"]},"28":{"title":"函数声明","titles":["第六章 函数","函数基础"]},"29":{"title":"分离式编译","titles":["第六章 函数","函数基础"]},"30":{"title":"参数传递","titles":["第六章 函数"]},"31":{"title":"传值参数","titles":["第六章 函数","参数传递"]},"32":{"title":"传引用参数","titles":["第六章 函数","参数传递"]},"33":{"title":"const形参和实参","titles":["第六章 函数","参数传递"]},"34":{"title":"数组形参","titles":["第六章 函数","参数传递"]},"35":{"title":"main: 处理命令行选项","titles":["第六章 函数","参数传递"]},"36":{"title":"含有可变形参的函数","titles":["第六章 函数","参数传递"]},"37":{"title":"返回类型和return语句","titles":["第六章 函数"]},"38":{"title":"无返回值函数","titles":["第六章 函数","返回类型和return语句"]},"39":{"title":"有返回值函数","titles":["第六章 函数","返回类型和return语句"]},"40":{"title":"返回数组的指针","titles":["第六章 函数","返回类型和return语句"]},"41":{"title":"函数重载","titles":["第六章 函数"]},"42":{"title":"重载与作用域","titles":["第六章 函数","函数重载"]},"43":{"title":"特殊用途语言特性","titles":["第六章 函数"]},"44":{"title":"默认实参","titles":["第六章 函数","特殊用途语言特性"]},"45":{"title":"内联函数和constexpr函数","titles":["第六章 函数","特殊用途语言特性"]},"46":{"title":"调试帮助","titles":["第六章 函数","特殊用途语言特性"]},"47":{"title":"函数匹配","titles":["第六章 函数"]},"48":{"title":"实参类型转换","titles":["第六章 函数","函数匹配"]},"49":{"title":"函数指针","titles":["第六章 函数"]},"50":{"title":"第十二章 动态内存","titles":[]},"51":{"title":"动态内存与智能指针","titles":["第十二章 动态内存"]},"52":{"title":"shared_ptr类","titles":["第十二章 动态内存","动态内存与智能指针"]},"53":{"title":"直接管理内存","titles":["第十二章 动态内存","动态内存与智能指针"]},"54":{"title":"shared_ptr和new结合使用","titles":["第十二章 动态内存","动态内存与智能指针"]},"55":{"title":"智能指针和异常","titles":["第十二章 动态内存","动态内存与智能指针"]},"56":{"title":"unique_ptr","titles":["第十二章 动态内存","动态内存与智能指针"]},"57":{"title":"weak_ptr","titles":["第十二章 动态内存","动态内存与智能指针"]},"58":{"title":"动态数组","titles":["第十二章 动态内存"]},"59":{"title":"new和数组","titles":["第十二章 动态内存","动态数组"]},"60":{"title":"allocator类","titles":["第十二章 动态内存","动态数组"]},"61":{"title":"第二章 变量和基本类型","titles":[]},"62":{"title":"基本内置类型","titles":["第二章 变量和基本类型"]},"63":{"title":"算术类型","titles":["第二章 变量和基本类型","基本内置类型"]},"64":{"title":"类型转换","titles":["第二章 变量和基本类型","基本内置类型"]},"65":{"title":"字面值常量","titles":["第二章 变量和基本类型","基本内置类型"]},"66":{"title":"变量","titles":["第二章 变量和基本类型"]},"67":{"title":"变量定义","titles":["第二章 变量和基本类型","变量"]},"68":{"title":"变量声明和定义的关系","titles":["第二章 变量和基本类型","变量"]},"69":{"title":"标识符","titles":["第二章 变量和基本类型","变量"]},"70":{"title":"名字的作用域","titles":["第二章 变量和基本类型","变量"]},"71":{"title":"复合类型","titles":["第二章 变量和基本类型"]},"72":{"title":"引用","titles":["第二章 变量和基本类型","复合类型"]},"73":{"title":"指针","titles":["第二章 变量和基本类型","复合类型"]},"74":{"title":"理解复合类型的声明","titles":["第二章 变量和基本类型","复合类型"]},"75":{"title":"const限定符","titles":["第二章 变量和基本类型"]},"76":{"title":"const的引用","titles":["第二章 变量和基本类型","const限定符"]},"77":{"title":"指针和const","titles":["第二章 变量和基本类型","const限定符"]},"78":{"title":"顶层const","titles":["第二章 变量和基本类型","const限定符"]},"79":{"title":"constexpr和常量表达式","titles":["第二章 变量和基本类型","const限定符"]},"80":{"title":"处理类型","titles":["第二章 变量和基本类型"]},"81":{"title":"类型别名","titles":["第二章 变量和基本类型","处理类型"]},"82":{"title":"auto类型说明符","titles":["第二章 变量和基本类型","处理类型"]},"83":{"title":"decltype类型指示符","titles":["第二章 变量和基本类型","处理类型"]},"84":{"title":"自定义数据结构","titles":["第二章 变量和基本类型"]},"85":{"title":"定义Sales_data类型","titles":["第二章 变量和基本类型","自定义数据结构"]},"86":{"title":"编写自己的头文件","titles":["第二章 变量和基本类型","自定义数据结构"]},"87":{"title":"第三章 字符串、向量和数组","titles":[]},"88":{"title":"命名空间的using声明","titles":["第三章 字符串、向量和数组"]},"89":{"title":"标准库类型string","titles":["第三章 字符串、向量和数组"]},"90":{"title":"定义和初始化string对象","titles":["第三章 字符串、向量和数组","标准库类型string"]},"91":{"title":"string对象上的操作","titles":["第三章 字符串、向量和数组","标准库类型string"]},"92":{"title":"处理string对象中的字符","titles":["第三章 字符串、向量和数组","标准库类型string"]},"93":{"title":"标准库类型vector","titles":["第三章 字符串、向量和数组"]},"94":{"title":"定义和初始化vector对象","titles":["第三章 字符串、向量和数组","标准库类型vector"]},"95":{"title":"向vector中添加元素","titles":["第三章 字符串、向量和数组","标准库类型vector"]},"96":{"title":"其它vector操作","titles":["第三章 字符串、向量和数组","标准库类型vector"]},"97":{"title":"迭代器介绍","titles":["第三章 字符串、向量和数组"]},"98":{"title":"使用迭代器","titles":["第三章 字符串、向量和数组","迭代器介绍"]},"99":{"title":"迭代器运算","titles":["第三章 字符串、向量和数组","迭代器介绍"]},"100":{"title":"数组","titles":["第三章 字符串、向量和数组"]},"101":{"title":"定义和初始化内置数组","titles":["第三章 字符串、向量和数组","数组"]},"102":{"title":"访问数组元素","titles":["第三章 字符串、向量和数组","数组"]},"103":{"title":"指针和数组","titles":["第三章 字符串、向量和数组","数组"]},"104":{"title":"C风格字符串","titles":["第三章 字符串、向量和数组","数组"]},"105":{"title":"多维数组","titles":["第三章 字符串、向量和数组"]},"106":{"title":"第一章 开始","titles":[]},"107":{"title":"编写一个简单的C++程序","titles":["第一章 开始"]},"108":{"title":"编译、运行程序","titles":["第一章 开始","编写一个简单的C++程序"]},"109":{"title":"初识输入输出","titles":["第一章 开始"]},"110":{"title":"注释简介","titles":["第一章 开始"]},"111":{"title":"控制流","titles":["第一章 开始"]},"112":{"title":"while语句","titles":["第一章 开始","控制流"]},"113":{"title":"for语句","titles":["第一章 开始","控制流"]},"114":{"title":"读取数量不定的输入数据","titles":["第一章 开始","控制流"]},"115":{"title":"if语句","titles":["第一章 开始","控制流"]},"116":{"title":"类简介","titles":["第一章 开始"]},"117":{"title":"初识成员函数","titles":["第一章 开始","类简介"]},"118":{"title":"第十三章 拷贝控制","titles":[]},"119":{"title":"拷贝、赋值与销毁","titles":["第十三章 拷贝控制"]},"120":{"title":"拷贝构造函数","titles":["第十三章 拷贝控制","拷贝、赋值与销毁"]},"121":{"title":"拷贝赋值运算符","titles":["第十三章 拷贝控制","拷贝、赋值与销毁"]},"122":{"title":"析构函数","titles":["第十三章 拷贝控制","拷贝、赋值与销毁"]},"123":{"title":"三/五法则","titles":["第十三章 拷贝控制","拷贝、赋值与销毁"]},"124":{"title":"使用=default","titles":["第十三章 拷贝控制","拷贝、赋值与销毁"]},"125":{"title":"阻止拷贝","titles":["第十三章 拷贝控制","拷贝、赋值与销毁"]},"126":{"title":"拷贝控制和资源管理","titles":["第十三章 拷贝控制"]},"127":{"title":"行为像值的类","titles":["第十三章 拷贝控制","拷贝控制和资源管理"]},"128":{"title":"定义行为像指针的类","titles":["第十三章 拷贝控制","拷贝控制和资源管理"]},"129":{"title":"交换操作","titles":["第十三章 拷贝控制"]},"130":{"title":"对象移动","titles":["第十三章 拷贝控制"]},"131":{"title":"右值引用","titles":["第十三章 拷贝控制","对象移动"]},"132":{"title":"移动构造函数和移动赋值运算符","titles":["第十三章 拷贝控制","对象移动"]},"133":{"title":"右值引用和成员函数","titles":["第十三章 拷贝控制"]},"134":{"title":"第十四章 操作重载与类型转换","titles":[]},"135":{"title":"基本概念","titles":["第十四章 操作重载与类型转换"]},"136":{"title":"输入和输出运算符","titles":["第十四章 操作重载与类型转换"]},"137":{"title":"重载输出运算符&lt;&lt;","titles":["第十四章 操作重载与类型转换","输入和输出运算符"]},"138":{"title":"重载输入运算符&gt;&gt;","titles":["第十四章 操作重载与类型转换","输入和输出运算符"]},"139":{"title":"算术和关系运算符","titles":["第十四章 操作重载与类型转换"]},"140":{"title":"相等运算符","titles":["第十四章 操作重载与类型转换","算术和关系运算符"]},"141":{"title":"赋值运算符","titles":["第十四章 操作重载与类型转换"]},"142":{"title":"下标运算符","titles":["第十四章 操作重载与类型转换"]},"143":{"title":"递增和递减运算符","titles":["第十四章 操作重载与类型转换"]},"144":{"title":"成员访问运算符","titles":["第十四章 操作重载与类型转换"]},"145":{"title":"函数调用运算符","titles":["第十四章 操作重载与类型转换"]},"146":{"title":"lambda是函数对象","titles":["第十四章 操作重载与类型转换","函数调用运算符"]},"147":{"title":"标准库定义的函数对象","titles":["第十四章 操作重载与类型转换","函数调用运算符"]},"148":{"title":"可调用对象与function","titles":["第十四章 操作重载与类型转换","函数调用运算符"]},"149":{"title":"重载、类型转换与运算符","titles":["第十四章 操作重载与类型转换"]},"150":{"title":"类型转换运算符","titles":["第十四章 操作重载与类型转换","重载、类型转换与运算符"]},"151":{"title":"第17章 标准库特殊设施","titles":[]},"152":{"title":"tuple类型","titles":["第17章 标准库特殊设施"]},"153":{"title":"定义和初始化tuple","titles":["第17章 标准库特殊设施","tuple类型"]},"154":{"title":"bitset类型","titles":["第17章 标准库特殊设施"]},"155":{"title":"定义和初始化bitset","titles":["第17章 标准库特殊设施","bitset类型"]},"156":{"title":"bitset操作","titles":["第17章 标准库特殊设施","bitset类型"]},"157":{"title":"正则表达式","titles":["第17章 标准库特殊设施"]},"158":{"title":"随机数","titles":["第17章 标准库特殊设施"]},"159":{"title":"随机数引擎和分布","titles":["第17章 标准库特殊设施","随机数"]},"160":{"title":"IO库再探","titles":["第17章 标准库特殊设施"]},"161":{"title":"格式化输入与输出","titles":["第17章 标准库特殊设施","IO库再探"]},"162":{"title":"未格式化的输入/输出操作","titles":["第17章 标准库特殊设施","IO库再探"]},"163":{"title":"流随机访问","titles":["第17章 标准库特殊设施","IO库再探"]},"164":{"title":"第十六章 模板与泛型编程","titles":[]},"165":{"title":"定义模板","titles":["第十六章 模板与泛型编程"]},"166":{"title":"函数模板","titles":["第十六章 模板与泛型编程","定义模板"]},"167":{"title":"类模板","titles":["第十六章 模板与泛型编程","定义模板"]},"168":{"title":"模板参数","titles":["第十六章 模板与泛型编程","定义模板"]},"169":{"title":"成员模板","titles":["第十六章 模板与泛型编程","定义模板"]},"170":{"title":"控制实例化","titles":["第十六章 模板与泛型编程","定义模板"]},"171":{"title":"模板实参推断","titles":["第十六章 模板与泛型编程"]},"172":{"title":"类型转换与模板类型参数","titles":["第十六章 模板与泛型编程","模板实参推断"]},"173":{"title":"函数模板显式实参","titles":["第十六章 模板与泛型编程","模板实参推断"]},"174":{"title":"尾置返回类型与类型转换","titles":["第十六章 模板与泛型编程","模板实参推断"]},"175":{"title":"函数指针和实参推断","titles":["第十六章 模板与泛型编程","模板实参推断"]},"176":{"title":"模板实参推断和引用","titles":["第十六章 模板与泛型编程","模板实参推断"]},"177":{"title":"理解std::move","titles":["第十六章 模板与泛型编程","模板实参推断"]},"178":{"title":"转发","titles":["第十六章 模板与泛型编程","模板实参推断"]},"179":{"title":"重载与模板","titles":["第十六章 模板与泛型编程"]},"180":{"title":"可变参数模板","titles":["第十六章 模板与泛型编程"]},"181":{"title":"编写可变参数函数模板","titles":["第十六章 模板与泛型编程","可变参数模板"]},"182":{"title":"包扩展","titles":["第十六章 模板与泛型编程","可变参数模板"]},"183":{"title":"模板特例化","titles":["第十六章 模板与泛型编程"]},"184":{"title":"第十章 泛型算法","titles":[]},"185":{"title":"概述","titles":["第十章 泛型算法"]},"186":{"title":"初识泛型算法","titles":["第十章 泛型算法"]},"187":{"title":"只读算法","titles":["第十章 泛型算法","初识泛型算法"]},"188":{"title":"写容器元素的算法","titles":["第十章 泛型算法","初识泛型算法"]},"189":{"title":"重排元素的算法","titles":["第十章 泛型算法","初识泛型算法"]},"190":{"title":"定义操作","titles":["第十章 泛型算法"]},"191":{"title":"向算法传递函数","titles":["第十章 泛型算法","定义操作"]},"192":{"title":"lambda表达式","titles":["第十章 泛型算法","定义操作"]},"193":{"title":"lambda捕获和返回","titles":["第十章 泛型算法","定义操作"]},"194":{"title":"参数绑定","titles":["第十章 泛型算法","定义操作"]},"195":{"title":"再探迭代器","titles":["第十章 泛型算法"]},"196":{"title":"插入迭代器","titles":["第十章 泛型算法","再探迭代器"]},"197":{"title":"iostream迭代器","titles":["第十章 泛型算法","再探迭代器"]},"198":{"title":"反向迭代器","titles":["第十章 泛型算法","再探迭代器"]},"199":{"title":"泛型算法结构","titles":["第十章 泛型算法"]},"200":{"title":"5类迭代器","titles":["第十章 泛型算法","泛型算法结构"]},"201":{"title":"算法的形参模式","titles":["第十章 泛型算法","泛型算法结构"]},"202":{"title":"算法命名规范","titles":["第十章 泛型算法","泛型算法结构"]},"203":{"title":"特定容器的算法","titles":["第十章 泛型算法"]},"204":{"title":"第18章 用于大型程序的工具","titles":[]},"205":{"title":"异常处理","titles":["第18章 用于大型程序的工具"]},"206":{"title":"抛出异常","titles":["第18章 用于大型程序的工具","异常处理"]},"207":{"title":"捕获异常","titles":["第18章 用于大型程序的工具","异常处理"]},"208":{"title":"noexception异常说明","titles":["第18章 用于大型程序的工具","异常处理"]},"209":{"title":"命名空间","titles":["第18章 用于大型程序的工具"]},"210":{"title":"命名空间的定义","titles":["第18章 用于大型程序的工具","命名空间"]},"211":{"title":"使用命名空间的成员","titles":["第18章 用于大型程序的工具","命名空间"]},"212":{"title":"类、命名空间与作用域","titles":["第18章 用于大型程序的工具","命名空间"]},"213":{"title":"重载与命名空间","titles":["第18章 用于大型程序的工具","命名空间"]},"214":{"title":"多重继承与虚继承","titles":["第18章 用于大型程序的工具"]},"215":{"title":"多重继承","titles":["第18章 用于大型程序的工具","多重继承与虚继承"]},"216":{"title":"类型转换与多个基类","titles":["第18章 用于大型程序的工具","多重继承与虚继承"]},"217":{"title":"多重继承下的类作用域","titles":["第18章 用于大型程序的工具","多重继承与虚继承"]},"218":{"title":"虚继承","titles":["第18章 用于大型程序的工具","多重继承与虚继承"]},"219":{"title":"构造函数与虚继承","titles":["第18章 用于大型程序的工具","多重继承与虚继承"]},"220":{"title":"第19章 特殊工具与技术","titles":[]},"221":{"title":"控制内存分配","titles":["第19章 特殊工具与技术"]},"222":{"title":"重载new和delete","titles":["第19章 特殊工具与技术","控制内存分配"]},"223":{"title":"定位new表达式","titles":["第19章 特殊工具与技术","控制内存分配"]},"224":{"title":"运行时类型识别","titles":["第19章 特殊工具与技术"]},"225":{"title":"dynamic_cast运算符","titles":["第19章 特殊工具与技术","运行时类型识别"]},"226":{"title":"typeid运算符","titles":["第19章 特殊工具与技术","运行时类型识别"]},"227":{"title":"type_info类","titles":["第19章 特殊工具与技术","运行时类型识别"]},"228":{"title":"枚举类型","titles":["第19章 特殊工具与技术"]},"229":{"title":"类成员指针","titles":["第19章 特殊工具与技术"]},"230":{"title":"成员函数指针","titles":["第19章 特殊工具与技术","类成员指针"]},"231":{"title":"将成员函数用作可调用对象","titles":["第19章 特殊工具与技术","类成员指针"]},"232":{"title":"嵌套类","titles":["第19章 特殊工具与技术"]},"233":{"title":"union：一种节省空间的类","titles":["第19章 特殊工具与技术"]},"234":{"title":"局部类","titles":["第19章 特殊工具与技术"]},"235":{"title":"固有的不可移植的特性","titles":["第19章 特殊工具与技术"]},"236":{"title":"链接指示：extern &quot;C&quot;","titles":["第19章 特殊工具与技术","固有的不可移植的特性"]},"237":{"title":"第七章 类","titles":[]},"238":{"title":"定义抽象数据类型","titles":["第七章 类"]},"239":{"title":"定义类相关的非成员函数","titles":["第七章 类","定义抽象数据类型"]},"240":{"title":"构造函数","titles":["第七章 类","定义抽象数据类型"]},"241":{"title":"拷贝、赋值和析构","titles":["第七章 类","定义抽象数据类型"]},"242":{"title":"访问控制与封装","titles":["第七章 类"]},"243":{"title":"友元","titles":["第七章 类","访问控制与封装"]},"244":{"title":"类的其它特性","titles":["第七章 类"]},"245":{"title":"类成员再探","titles":["第七章 类","类的其它特性"]},"246":{"title":"返回*this的成员函数","titles":["第七章 类","类的其它特性"]},"247":{"title":"类类型","titles":["第七章 类","类的其它特性"]},"248":{"title":"友元再探","titles":["第七章 类","类的其它特性"]},"249":{"title":"类的作用域","titles":["第七章 类"]},"250":{"title":"名字查找与类的作用域","titles":["第七章 类","类的作用域"]},"251":{"title":"构造函数再探","titles":["第七章 类"]},"252":{"title":"构造函数初始值列表","titles":["第七章 类","构造函数再探"]},"253":{"title":"委托构造函数","titles":["第七章 类","构造函数再探"]},"254":{"title":"默认构造函数的作用","titles":["第七章 类","构造函数再探"]},"255":{"title":"隐式的类类型转换","titles":["第七章 类","构造函数再探"]},"256":{"title":"聚合类","titles":["第七章 类","构造函数再探"]},"257":{"title":"字面值常量类（ Literal Classes）","titles":["第七章 类","构造函数再探"]},"258":{"title":"类的静态成员","titles":["第七章 类"]},"259":{"title":"第四章 表达式","titles":[]},"260":{"title":"基础","titles":["第四章 表达式"]},"261":{"title":"基本概念","titles":["第四章 表达式","基础"]},"262":{"title":"优先级与结合律","titles":["第四章 表达式","基础"]},"263":{"title":"求值顺序","titles":["第四章 表达式","基础"]},"264":{"title":"算术运算符","titles":["第四章 表达式"]},"265":{"title":"逻辑和关系运算符","titles":["第四章 表达式"]},"266":{"title":"赋值运算符","titles":["第四章 表达式"]},"267":{"title":"递增和递减运算符","titles":["第四章 表达式"]},"268":{"title":"成员访问运算符","titles":["第四章 表达式"]},"269":{"title":"条件运算符","titles":["第四章 表达式"]},"270":{"title":"位运算符","titles":["第四章 表达式"]},"271":{"title":"sizeof运算符","titles":["第四章 表达式"]},"272":{"title":"逗号运算符","titles":["第四章 表达式"]},"273":{"title":"类型转换","titles":["第四章 表达式"]},"274":{"title":"算术转换","titles":["第四章 表达式","类型转换"]},"275":{"title":"其他隐式转换","titles":["第四章 表达式","类型转换"]},"276":{"title":"显式转换","titles":["第四章 表达式","类型转换"]},"277":{"title":"第五章 语句","titles":[]},"278":{"title":"简单语句","titles":["第五章 语句"]},"279":{"title":"语句作用域","titles":["第五章 语句"]},"280":{"title":"条件语句","titles":["第五章 语句"]},"281":{"title":"if语句","titles":["第五章 语句","条件语句"]},"282":{"title":"switch语句","titles":["第五章 语句","条件语句"]},"283":{"title":"迭代语句","titles":["第五章 语句"]},"284":{"title":"while语句","titles":["第五章 语句","迭代语句"]},"285":{"title":"传统的for语句","titles":["第五章 语句","迭代语句"]},"286":{"title":"范围for语句","titles":["第五章 语句","迭代语句"]},"287":{"title":"do while语句","titles":["第五章 语句","迭代语句"]},"288":{"title":"跳转语句","titles":["第五章 语句"]},"289":{"title":"break语句","titles":["第五章 语句","跳转语句"]},"290":{"title":"continue语句","titles":["第五章 语句","跳转语句"]},"291":{"title":"goto语句","titles":["第五章 语句","跳转语句"]},"292":{"title":"try语句块和异常处理","titles":["第五章 语句"]},"293":{"title":"throw表达式","titles":["第五章 语句","try语句块和异常处理"]},"294":{"title":"try语句块","titles":["第五章 语句","try语句块和异常处理"]},"295":{"title":"标准异常","titles":["第五章 语句","try语句块和异常处理"]},"296":{"title":"第十五章 面向对象程序设计","titles":[]},"297":{"title":"OOP概述","titles":["第十五章 面向对象程序设计"]},"298":{"title":"定义基类","titles":["第十五章 面向对象程序设计","OOP概述"]},"299":{"title":"定义派生类","titles":["第十五章 面向对象程序设计","OOP概述"]},"300":{"title":"类型转换与继承","titles":["第十五章 面向对象程序设计","OOP概述"]},"301":{"title":"虚函数","titles":["第十五章 面向对象程序设计"]},"302":{"title":"抽象基类","titles":["第十五章 面向对象程序设计"]},"303":{"title":"访问控制与继承","titles":["第十五章 面向对象程序设计"]},"304":{"title":"继承中的类作用域","titles":["第十五章 面向对象程序设计"]},"305":{"title":"构造函数与拷贝控制","titles":["第十五章 面向对象程序设计"]},"306":{"title":"虚析构函数","titles":["第十五章 面向对象程序设计","构造函数与拷贝控制"]},"307":{"title":"合成拷贝控制与继承","titles":["第十五章 面向对象程序设计","构造函数与拷贝控制"]},"308":{"title":"派生类的拷贝控制成员","titles":["第十五章 面向对象程序设计","构造函数与拷贝控制"]},"309":{"title":"继承的构造函数","titles":["第十五章 面向对象程序设计","构造函数与拷贝控制"]},"310":{"title":"第九章 顺序容器","titles":[]},"311":{"title":"顺序容器概览","titles":["第九章 顺序容器"]},"312":{"title":"容器库概览","titles":["第九章 顺序容器"]},"313":{"title":"迭代器","titles":["第九章 顺序容器","容器库概览"]},"314":{"title":"容器定义和初始化","titles":["第九章 顺序容器","容器库概览"]},"315":{"title":"赋值和拷贝","titles":["第九章 顺序容器","容器库概览"]},"316":{"title":"容器大小操作","titles":["第九章 顺序容器","容器库概览"]},"317":{"title":"关系运算符","titles":["第九章 顺序容器","容器库概览"]},"318":{"title":"顺序容器操作","titles":["第九章 顺序容器"]},"319":{"title":"向顺序容器添加元素","titles":["第九章 顺序容器","顺序容器操作"]},"320":{"title":"访问元素","titles":["第九章 顺序容器","顺序容器操作"]},"321":{"title":"删除元素","titles":["第九章 顺序容器","顺序容器操作"]},"322":{"title":"改变容器大小","titles":["第九章 顺序容器","顺序容器操作"]},"323":{"title":"容器操作可能使迭代器失效","titles":["第九章 顺序容器","顺序容器操作"]},"324":{"title":"额外的 string 操作","titles":["第九章 顺序容器"]},"325":{"title":"构造 string 的其他方法","titles":["第九章 顺序容器","额外的 string 操作"]},"326":{"title":"改变 string 的其他方法","titles":["第九章 顺序容器","额外的 string 操作"]},"327":{"title":"string 搜索操作","titles":["第九章 顺序容器","额外的 string 操作"]},"328":{"title":"compare 函数","titles":["第九章 顺序容器","额外的 string 操作"]},"329":{"title":"数值转换","titles":["第九章 顺序容器","额外的 string 操作"]}},"dirtCount":0,"index":[["搜索操作",{"0":{"327":1}}],["替换内容",{"2":{"326":1}}],["替换或删除元素",{"2":{"184":1}}],["末尾进行插入操作",{"2":{"326":1}}],["末尾加上分号就变成了表达式语句",{"2":{"278":1}}],["个字符",{"2":{"325":1}}],["个字符的拷贝",{"2":{"325":1}}],["额外的",{"0":{"324":1},"1":{"325":1,"326":1,"327":1,"328":1,"329":1}}],["方法",{"2":{"325":1}}],["方法有两种",{"2":{"314":1}}],["方法是令其他类或者函数成为它的友元",{"2":{"243":1}}],["方法是通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用",{"2":{"131":1}}],["方法是在大小之后跟一对空括号",{"2":{"59":1}}],["列出了我们可以用来在顺序容器中访问元素的操作",{"2":{"320":1}}],["列出了迭代器支持的算术运算",{"2":{"313":1}}],["列出了容器迭代器支持的所有操作",{"2":{"313":1}}],["列表",{"2":{"167":1}}],["列表中的元素将拷贝替换v1中的",{"2":{"96":1}}],["列表中每个变量名的类型由类型说明符指定",{"2":{"67":1}}],["列表初始化返回值",{"2":{"39":1}}],["列表初始化",{"2":{"15":1,"17":1,"67":1}}],["很相似",{"2":{"328":1}}],["很高",{"2":{"311":1}}],["很多时候",{"2":{"273":1}}],["很多算法都会比较输入序列中的元素",{"2":{"190":1}}],["很多和string类似",{"2":{"96":1}}],["很多程序员容易迷惑于基本数据类型和类型修饰符之间的关系",{"2":{"74":1}}],["出于同样的原因",{"2":{"309":1}}],["出现在捕获所有异常语句后面的catch语句将永远不会被匹配",{"2":{"207":1}}],["沿着继承体系的反方向直到最后",{"2":{"308":1}}],["沿着调用链的函数可能会提早退出",{"2":{"206":1}}],["假定begin和end构成一个合法的迭代器范围",{"2":{"313":1}}],["假定d继承自b",{"2":{"303":1}}],["假如i是一个int对象",{"2":{"176":1}}],["假如有一个类的构造函数中需要动态分配内存",{"2":{"123":1}}],["假如已经有了一个函数",{"2":{"49":1}}],["及友元",{"2":{"303":1}}],["派生列表中的访问说明符限制了派生类用户对继承而来的成员的访问权限",{"2":{"303":1}}],["派生访问说明符对于派生类的成员",{"2":{"303":1}}],["派生类继承基类构造函数的方式是提供一条注明了",{"2":{"309":1}}],["派生类能够重用其直接基类定义的构造函数",{"2":{"309":1}}],["派生类能访问公有成员",{"2":{"298":1}}],["派生类析构函数首先执行",{"2":{"308":1}}],["派生类析构函数只负责销毁由派生类自己分配的资源",{"2":{"308":1}}],["派生类赋值运算符也必须为其基类部分的成员赋值",{"2":{"308":1}}],["派生类最好不要重用其他定义在基类中的名字",{"2":{"304":1}}],["派生类也能重用定义在其直接基类或间接基类中的名字",{"2":{"304":1}}],["派生类只能为那些它可以访问的名字提供using声明",{"2":{"303":1}}],["派生类向其直接基类的类型转换对于派生类的成员和友元来说都是可访问的",{"2":{"303":1}}],["派生类向基类的转换是否可访问由使用该转换的代码决定",{"2":{"303":1}}],["派生类向基类转换的可访问性",{"2":{"303":1}}],["派生类对于一个基类对象中受保护成员没有任何访问权限",{"2":{"303":1}}],["派生类对象的基类部分是自动销毁的",{"2":{"308":1}}],["派生类对象",{"2":{"299":1}}],["派生类对象及派生类向基类的类型转换",{"2":{"299":1}}],["派生类中的虚函数",{"2":{"301":1}}],["派生类中含有继承链上每个类对应的子部分",{"2":{"218":1}}],["派生类会直接继承其在基类中的版本",{"2":{"299":1}}],["派生类经常覆盖它继承的虚函数",{"2":{"299":1}}],["派生类需要对这些操作提供自己的新定义以覆盖",{"2":{"298":1}}],["派生类可以在它覆盖的函数前使用virtual关键字",{"2":{"299":1}}],["派生类可以继承定义在基类中的成员",{"2":{"298":1}}],["派生类可以继承其基类的成员",{"2":{"298":1}}],["派生类可以通过它的两个直接基类分别继承同一个间接基类",{"2":{"218":1}}],["派生类必须使用基类的构造函数来初始化它的基类部分",{"2":{"299":1}}],["派生类必须对其重新定义",{"2":{"298":1}}],["派生类必须在其内部对所有重新定义的虚函数进行声明",{"2":{"297":1}}],["派生类必须通过使用",{"2":{"297":1}}],["派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时",{"2":{"308":1}}],["派生类的拷贝控制成员",{"0":{"308":1}}],["派生类的作用域嵌套在其基类的作用域之内",{"2":{"304":1}}],["派生类的作用域嵌套在直接基类和间接基类的作用域中",{"2":{"217":1}}],["派生类的友元也不能随意访问基类的成员",{"2":{"303":1}}],["派生类的成员或友元只能通过派生类对象来访问基类的受保护成员",{"2":{"303":1}}],["派生类的成员及基类都是自动销毁的",{"2":{"215":1}}],["派生类的函数并没有覆盖掉基类中的函数",{"2":{"301":1}}],["派生类的构造函数",{"2":{"299":1}}],["派生类的名字将隐藏基类的同名成员",{"2":{"217":1}}],["派生类的指针或引用能自动转换成一个可访问基类的指针或引用",{"2":{"216":1}}],["派生类的析构函数只负责清除派生类本身分配的资源",{"2":{"215":1}}],["派生类的对象包含有每个基类的子对象",{"2":{"215":1}}],["派生类构造函数初始化所有基类",{"2":{"215":1}}],["私有和受保护继承",{"2":{"303":1}}],["私有的成员函数",{"2":{"237":1}}],["抽象基类负责定义接口",{"2":{"302":1}}],["抽象基类",{"0":{"302":1}}],["抽象数据类型隐藏了自己的成员变量",{"2":{"238":1}}],["警告",{"2":{"301":1}}],["回避虚函数机制",{"2":{"301":1}}],["回到正常的缓冲方式",{"2":{"5":1}}],["覆盖的虚函数的形参类型必须与被它覆盖的基类函数完全一致",{"2":{"301":1}}],["覆盖基类的函数版本以实现基于大量购买的折扣政策",{"2":{"299":1}}],["防止继承的发生",{"2":{"299":1}}],["办法函数后面加一个关键字override",{"2":{"299":1}}],["折扣",{"2":{"299":1}}],["折叠成x",{"2":{"176":2}}],["折叠",{"2":{"176":1}}],["适用折扣最低购买量",{"2":{"299":1}}],["适应",{"2":{"194":1}}],["受保护的成员对于派生类的成员和友元来说是可访问的",{"2":{"303":1}}],["受保护的成员对于类的用户来说是不可访问的",{"2":{"303":1}}],["受保护的成员",{"2":{"298":1,"303":1}}],["受委托的构造函数的初始值列表和函数体被依次执行",{"2":{"253":1}}],["根据引用或指针所绑定的对象类型不同",{"2":{"298":1}}],["根据判断结果决定是否执行另外一条语句",{"2":{"281":1}}],["明确指出它是从哪个基类继承而来的",{"2":{"297":1}}],["层次关系的根部有一个基类",{"2":{"297":1}}],["联系在一起的类构成一种层次关系",{"2":{"297":1}}],["联合",{"2":{"233":1}}],["继承disc",{"2":{"309":1}}],["继承的构造函数等价于",{"2":{"309":1}}],["继承的构造函数",{"0":{"309":1}}],["继承的构造函数与多重继承",{"2":{"215":1}}],["继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数",{"2":{"306":1}}],["继承中的类作用域",{"0":{"304":1}}],["继承与静态成员",{"2":{"299":1}}],["继承",{"2":{"297":1}}],["继承和动态绑定",{"2":{"297":1}}],["继续搜索调用它的函数",{"2":{"294":1}}],["终止该函数",{"2":{"294":1}}],["跳出while循环",{"2":{"294":1}}],["跳转语句中断当前的执行过程",{"2":{"288":1}}],["跳转语句",{"0":{"288":1},"1":{"289":1,"290":1,"291":1}}],["摘自书本",{"2":{"294":1}}],["带标签的语句",{"2":{"291":2}}],["带符号类型可以表示正数",{"2":{"63":1}}],["带符号类型和无符号类型",{"2":{"63":1}}],["唯一的区别是",{"2":{"287":1}}],["唯一的序号",{"2":{"123":1}}],["序列中的每个元素都能转换成该变量的类型",{"2":{"286":1}}],["迭代语句通常称之为循环",{"2":{"283":1}}],["迭代语句",{"0":{"283":1},"1":{"284":1,"285":1,"286":1,"287":1}}],["迭代器范围由一对迭代器表示",{"2":{"313":1}}],["迭代器范围",{"2":{"313":1}}],["迭代器有着公共的接口",{"2":{"313":1}}],["迭代器有有效和无效之分",{"2":{"97":1}}],["迭代器也定义了一组公共操作",{"2":{"200":1}}],["迭代器",{"0":{"313":1},"2":{"199":1}}],["迭代器适配器",{"2":{"157":1}}],["迭代器相减的结果的类型是difference",{"2":{"99":1}}],["迭代器的算数运算",{"2":{"99":1}}],["迭代器运算",{"0":{"99":1}}],["迭代器类型",{"2":{"98":1}}],["迭代器指示一个元素时",{"2":{"98":1}}],["迭代器介绍",{"0":{"97":1},"1":{"98":1,"99":1}}],["迭代器按关键字升序遍历元素",{"2":{"19":1}}],["判断一个指定的条件是否为真",{"2":{"281":1}}],["似乎没有什么实际意义",{"2":{"279":1}}],["块",{"2":{"278":1}}],["简单语句",{"0":{"278":1}}],["简写的名字从using指示开始",{"2":{"211":1}}],["追踪起来也更加困难",{"2":{"276":1}}],["容易被看漏",{"2":{"276":1}}],["容器操作可能使迭代器失效",{"0":{"323":1}}],["容器后部的元素会被删除",{"2":{"322":1}}],["容器元素是拷贝",{"2":{"319":1}}],["容器大小操作",{"0":{"316":1}}],["容器定义和初始化",{"0":{"314":1}}],["容器库概览",{"0":{"312":1},"1":{"313":1,"314":1,"315":1,"316":1,"317":1}}],["容器也会执行正确的拷贝",{"2":{"241":1}}],["容器类型不一定匹配",{"2":{"314":1}}],["容器类型上的操作形成了一种层次",{"2":{"312":1}}],["容器类",{"2":{"157":1}}],["容器类是出于第一种原因而使用动态内存的典型例子",{"2":{"52":1}}],["容器或数组被销毁时",{"2":{"122":1}}],["旧式的强制类型转换从表现形式上来说不那么清晰明了",{"2":{"276":1}}],["旧式的强制类型转换分别具有const",{"2":{"276":1}}],["旧式的强制类型转换",{"2":{"276":1}}],["强制类型转换应当在其合适的应用场景中使用",{"2":{"276":1}}],["强制类型转换表示",{"2":{"276":1}}],["强烈建议将位运算符用于处理无符号类型",{"2":{"270":1}}],["命名的强制类型转换",{"2":{"276":1}}],["命名空间ns中声明的函数display",{"2":{"213":1}}],["命名空间与作用域",{"0":{"212":1}}],["命名空间别名",{"2":{"211":2}}],["命名空间中定义的名字也需要满足这一要求",{"2":{"210":1}}],["命名空间成员的定义部分则置于另外的源文件中",{"2":{"210":1}}],["命名空间可以是不连续的",{"2":{"210":1}}],["命名空间可以帮助我们避免不经意的名字定义冲突",{"2":{"109":1}}],["命名空间的一部分成员的作用是定义类",{"2":{"210":1}}],["命名空间的组织方式类似于我们管理自定义类及函数的方式",{"2":{"210":1}}],["命名空间的定义",{"0":{"210":1}}],["命名空间的using声明",{"0":{"88":1}}],["命名空间分割了全局命名空间",{"2":{"209":1}}],["命名空间",{"0":{"209":1},"1":{"210":1,"211":1,"212":1,"213":1},"2":{"209":1}}],["命名空间和多重继承",{"2":{"204":1}}],["感觉没有必要一一记录",{"2":{"274":1}}],["何时发生隐式转换",{"2":{"273":1}}],["何为对象",{"2":{"67":1}}],["上述规则可以用下面的例子来理解",{"2":{"303":1}}],["上述转换是自动进行的",{"2":{"273":1}}],["上面左值右值的讨论不是很能理清",{"2":{"268":1}}],["上面这句话还是挺绕口的",{"2":{"263":1}}],["考虑下面这条表达式",{"2":{"273":1}}],["|",{"2":{"270":2}}],["||",{"2":{"150":1,"263":1,"294":1}}],["^",{"2":{"270":2}}],["功能",{"2":{"270":1}}],["箭头运算符作用于一个指针类型的运算对象",{"2":{"268":1}}],["箭头运算符与点运算符有关",{"2":{"268":1}}],["尤其是对于迭代器类型",{"2":{"267":1}}],["窄化转换",{"2":{"266":1}}],["k",{"2":{"266":2}}],["key",{"2":{"18":2}}],["等于m",{"2":{"264":1}}],["等价的函数调用",{"2":{"135":1}}],["等价的赋值语句",{"2":{"49":1}}],["等价",{"2":{"91":1}}],["等价于i",{"2":{"103":1}}],["等价于vector",{"2":{"94":1}}],["等价于v2",{"2":{"94":1}}],["等价于s3",{"2":{"90":1}}],["等价于s2",{"2":{"90":1}}],["等价于screen",{"2":{"44":2}}],["等价于",{"2":{"73":1,"98":1}}],["等价调用",{"2":{"49":2}}],["等价定义",{"2":{"34":1}}],["取模",{"2":{"264":1}}],["取余",{"2":{"264":1}}],["取地址运算符",{"2":{"135":1}}],["取地址符是可选的",{"2":{"49":1}}],["俗称",{"2":{"264":1}}],["整数提升",{"2":{"274":1}}],["整数相除的结果还是整数",{"2":{"264":1}}],["整型会转换成浮点型",{"2":{"273":1}}],["整型值的输入输出使用十进制",{"2":{"161":1}}],["整型和浮点型字面值",{"2":{"65":1}}],["整型数",{"2":{"62":1}}],["溢出和其他算术运算异常",{"2":{"264":1}}],["提供了6个搜索函数",{"2":{"327":1}}],["提供快速随机访问的容器",{"2":{"320":1}}],["提示",{"2":{"264":1}}],["提醒",{"2":{"68":1}}],["小整型",{"2":{"270":1}}],["小整数类型的运算对象被提升成较大的整数类型",{"2":{"264":1}}],["小数部分记为0",{"2":{"64":1}}],["已经改变",{"2":{"263":1}}],["拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求",{"2":{"263":1}}],["拿它和别的指针比较",{"2":{"73":1}}],["条件语句",{"0":{"280":1},"1":{"281":1,"282":1}}],["条件运算符的执行过程是",{"2":{"269":1}}],["条件运算符按照如下形式使用",{"2":{"269":1}}],["条件运算符",{"0":{"269":1},"2":{"263":1,"269":1}}],["条件状态",{"0":{"4":1}}],["高优先级运算符的运算对象要比低优先级运算符的运算对象更为紧密地组织在一起",{"2":{"262":1}}],["高位被置为0",{"2":{"156":1}}],["优先级最低的是加法和减法",{"2":{"264":1}}],["优先级",{"2":{"263":1}}],["优先级规定了运算对象的组合方式",{"2":{"263":1}}],["优先级和结合律决定了运算对象组合的方式",{"2":{"262":1}}],["优先级与结合律",{"0":{"262":1}}],["求值的顺序不会成为问题",{"2":{"263":1}}],["求值顺序",{"0":{"263":1},"2":{"263":1}}],["求值结果的临时值是一种右值",{"2":{"261":1}}],["求复合表达式的值需要首先将运算符和运算对象合理地组合在一起",{"2":{"262":1}}],["求10和20的和",{"2":{"147":1}}],["满足如下条件也是一个字面值常量类",{"2":{"257":1}}],["聚合类",{"0":{"256":1},"2":{"256":1}}],["委托构造函数",{"0":{"253":1}}],["按照从左向右的顺序依次求值",{"2":{"272":1}}],["按照从左向右的顺序进行组合",{"2":{"264":1}}],["按如下方式解析",{"2":{"250":1}}],["按其需要写入数据",{"2":{"201":1}}],["负责把小整数转换成较大的整数类型",{"2":{"274":1}}],["负责计算两个整数相除所得的余数",{"2":{"264":1}}],["负责具体工作",{"2":{"246":1}}],["负数或0",{"2":{"63":1}}],["规模较小的成员函数适合声明成内联函数",{"2":{"245":1}}],["封装有两个重要的优点",{"2":{"243":1}}],["封装的益处",{"2":{"243":1}}],["封装就是隐藏",{"2":{"238":1}}],["友元关系不能继承",{"2":{"303":1}}],["友元与继承",{"2":{"303":1}}],["友元类有权访问本类的非公有成员",{"2":{"248":1}}],["友元再探",{"0":{"248":1}}],["友元声明只能出现在类的内部",{"2":{"243":1}}],["友元",{"0":{"243":1}}],["加强类的封装性",{"2":{"242":1}}],["加法的结果是int",{"2":{"83":1}}],["外部无法访问",{"2":{"242":1}}],["外部可访问",{"2":{"242":1}}],["外部只能使用其接口来间接访问其成员",{"2":{"238":1}}],["外层作用域也可能是一个或多个嵌套的命名空间",{"2":{"212":1}}],["外层作用域的同名实体将被隐藏",{"2":{"211":1}}],["链接指示不能出现在类定义或函数定义的内部",{"2":{"236":1}}],["链接指示可以有两种形式",{"2":{"236":1}}],["链接指示",{"0":{"236":1}}],["链表特有的操作会改变容器",{"2":{"203":1}}],["链表类型定义的其他算法的通用版本可以用于链表",{"2":{"203":1}}],["链表类型list定义了几个成员函数形式的算法",{"2":{"203":1}}],["详见书本",{"2":{"235":1}}],["详细见书本p315",{"2":{"323":1}}],["详细见书本p517",{"2":{"150":1}}],["详细操作见p359",{"2":{"197":1}}],["详细案例及讨论见书本p677",{"2":{"163":1}}],["详细案例解析见书本p220",{"2":{"48":1}}],["详细讨论见p615",{"2":{"179":1}}],["详细讨论见p673",{"2":{"162":1}}],["详细讨论见书本和代码案例",{"2":{"126":1}}],["详细的解释见书本p474",{"2":{"132":1}}],["详细定义方法见书本",{"2":{"129":1}}],["详细解释见书本p186",{"2":{"29":1}}],["位于继承体系中的类也需要控制当其对象执行一系列操作时发送什么样的行为",{"2":{"305":1}}],["位于函数名之后",{"2":{"173":1}}],["位或",{"2":{"270":1}}],["位异或",{"2":{"270":1}}],["位与",{"2":{"270":1}}],["位求反",{"2":{"270":1}}],["位运算符作用于整数类型的运算对象",{"2":{"270":1}}],["位运算符",{"0":{"270":1}}],["位域和volatile限定符",{"2":{"235":1}}],["固有的不可移植的特性",{"0":{"235":1},"1":{"236":1}}],["匿名union不能包含受保护的成员或私有成员",{"2":{"233":1}}],["匿名union",{"2":{"233":1}}],["嵌套类必须声明在类的内部",{"2":{"232":1}}],["嵌套类的名字在外层类作用域中是可见的",{"2":{"232":1}}],["嵌套类是一个独立的类",{"2":{"232":1}}],["嵌套类常用于定义作为实现部分的类",{"2":{"232":1}}],["嵌套类",{"0":{"232":1}}],["嵌套的作用域",{"2":{"70":1}}],["翻译",{"2":{"231":1}}],["翻转",{"2":{"178":1}}],["翻转第一位",{"2":{"156":2}}],["翻转bitvec中的所有位",{"2":{"156":1}}],["获得myscreen对象的contents成员",{"2":{"229":1}}],["获得扩展后的列表",{"2":{"182":1}}],["依赖于机器",{"2":{"270":1}}],["依次加1",{"2":{"228":1}}],["依此类推",{"2":{"59":1}}],["限定作用域的枚举类型",{"2":{"228":1}}],["限定作用域的和不限定作用域的",{"2":{"228":1}}],["枚举值从0开始",{"2":{"228":1}}],["枚举属于字面值常量类型",{"2":{"228":1}}],["枚举类型",{"0":{"228":1},"2":{"228":1}}],["检查运行时类型是否是某种指定的类型",{"2":{"226":1}}],["检测出问题的部分应该发出某种信号以表明程序遇到了故障",{"2":{"292":1}}],["检测环节无须知道问题处理模块的所有细节",{"2":{"205":1}}],["检测val是否小于等于10",{"2":{"113":1}}],["你的对象是什么类型",{"2":{"226":1}}],["改写之前的程序",{"2":{"225":1}}],["改变",{"0":{"326":1}}],["改变容器大小",{"0":{"322":1}}],["改变个别成员的可访问性",{"2":{"303":1}}],["改变元素或是重排元素顺序",{"2":{"186":1}}],["改变对象状态的运算符或者与给定类型密切相关的运算符",{"2":{"135":1}}],["改变副本也会改变原对象",{"2":{"126":1}}],["改变副本不会影响原对象",{"2":{"126":1}}],["事实上",{"2":{"223":1}}],["定位new允许我们在一个特定的",{"2":{"223":1}}],["定位new使用operator",{"2":{"223":1}}],["定位new表达式构造对象但是不分配内存",{"2":{"223":1}}],["定位new表达式",{"0":{"223":1}}],["定义派生类的拷贝或移动构造函数",{"2":{"308":1}}],["定义派生类",{"0":{"299":1}}],["定义基类",{"0":{"298":1}}],["定义并初始化一个静态成员",{"2":{"258":1}}],["定义并初始化ctr",{"2":{"167":1}}],["定义静态成员",{"2":{"258":1}}],["定义指向这种类型的指针or引用",{"2":{"247":1}}],["定义指针类型的方法将声明符写成",{"2":{"73":1}}],["定义时在前面加inline即可",{"2":{"245":1}}],["定义时还可以为一个或多个变量赋初值",{"2":{"67":1}}],["定义类相关的非成员函数",{"0":{"239":1}}],["定义类时必须采用某种机制加以阻止",{"2":{"125":1}}],["定义成员函数",{"2":{"238":1}}],["定义成员函数指针最简单的方法是使用auto",{"2":{"230":1}}],["定义抽象数据类型",{"0":{"238":1},"1":{"239":1,"240":1,"241":1}}],["定义union",{"2":{"233":1}}],["定义操作",{"0":{"190":1},"1":{"191":1,"192":1,"193":1,"194":1}}],["定义函数模板特例化",{"2":{"183":1}}],["定义函数的源文件应该把含有函数声明的头文件包含进来",{"2":{"28":1}}],["定义能保持类型信息的函数参数",{"2":{"178":1}}],["定义",{"2":{"170":1}}],["定义模板",{"0":{"165":1},"1":{"166":1,"167":1,"168":1,"169":1,"170":1}}],["定义为static的",{"2":{"159":1}}],["定义向bool的类型转换还是比较普遍的现象",{"2":{"150":1}}],["定义swap的类通常用swap来定义它们的赋值运算符",{"2":{"129":1}}],["定义sales",{"0":{"85":1}}],["定义行为像指针的类",{"0":{"128":1}}],["定义删除的函数",{"2":{"125":1}}],["定义在控制结构当中的变量只在相应语句的内部可见",{"2":{"279":1}}],["定义在类内部的函数是隐式的inline函数",{"2":{"238":1}}],["定义在头文件random中的随机数库通过一组协作的类来解决这些问题",{"2":{"158":1}}],["定义在cstddef头文件中",{"2":{"102":1}}],["定义在函数体外的标识符不能以下画线开头",{"2":{"69":1}}],["定义在函数体内部的内置类型变量将不被初始化",{"2":{"67":1}}],["定义一个私有的常量版本的函数",{"2":{"246":1}}],["定义一个类型成员",{"2":{"245":1}}],["定义一个返回this对象的函数",{"2":{"238":1}}],["定义一个拷贝赋值运算符来释放对象当前的string",{"2":{"127":1}}],["定义一个拷贝构造函数",{"2":{"127":1}}],["定义一个析构函数来释放string",{"2":{"127":1}}],["定义一个指针数组",{"2":{"101":1}}],["定义一个函数",{"2":{"49":1}}],["定义数组的时候必须指定数组的类型",{"2":{"101":1}}],["定义vector对象的方法有",{"2":{"94":1}}],["定义和初始化bitset",{"0":{"155":1}}],["定义和初始化tuple",{"0":{"153":1}}],["定义和初始化内置数组",{"0":{"101":1}}],["定义和初始化vector对象",{"0":{"94":1}}],["定义和初始化string对象",{"0":{"90":1}}],["定义于函数体之外的变量被初始化为0",{"2":{"67":1}}],["定义包括以下部分",{"2":{"26":1}}],["定义关联容器",{"0":{"15":1}}],["定义了一个未命名的对象",{"2":{"233":1}}],["定义了一个从lambda生成的类型的对象",{"2":{"193":1}}],["定义了一组重载函数后",{"2":{"41":1}}],["定义了移动构造函数和移动赋值运算符的类就可以避免此问题",{"2":{"132":1}}],["定义了读写内存string对象的类型",{"2":{"2":1}}],["定义了读写命名文件的类型",{"2":{"2":1}}],["定义了用于读写流的基本类型",{"2":{"2":1}}],["含有两个运算对象",{"2":{"272":1}}],["含有类类型成员的union",{"2":{"233":1}}],["含有虚基类的对象的构造顺序与一般的顺序稍有区别",{"2":{"219":1}}],["含有可变形参的函数",{"0":{"36":1}}],["虚析构函数还将阻止合成移动操作",{"2":{"306":1}}],["虚析构函数",{"0":{"306":1}}],["虚函数可以拥有默认实参",{"2":{"301":1}}],["虚函数",{"0":{"301":1}}],["虚基类总是先于非虚基类构造",{"2":{"219":1}}],["虚基类是由最低层的派生类初始化的",{"2":{"219":1}}],["虚派生只影响从指定了虚基类的派生类中进一步派生出的类",{"2":{"218":1}}],["虚继承的目的是令某个类做出声明",{"2":{"218":1}}],["虚继承",{"0":{"218":1}}],["共享的基类子对象被称为虚基类",{"2":{"218":1}}],["承诺愿意共享它的基类",{"2":{"218":1}}],["查找过程沿着继承体系自底向上进行",{"2":{"217":1}}],["查找匹配的处理代码",{"2":{"207":1}}],["解决办法",{"2":{"215":1}}],["解引用和赋值",{"2":{"200":1}}],["解引用iter",{"2":{"98":1}}],["解引用",{"2":{"98":1}}],["解引用操作仅适用于那些确实指向了某个对象的有效指针",{"2":{"73":1}}],["解引用一个智能指针返回它指向的对象",{"2":{"52":1}}],["试图从两个基类中继承d1",{"2":{"215":1}}],["z",{"2":{"233":1}}],["zooanimal是整个继承体系的最终基类",{"2":{"215":1}}],["zooanimal",{"2":{"215":1,"216":1,"218":2,"219":1}}],["zh",{"2":{"59":1}}],["扼要概述",{"2":{"211":1}}],["像namespace",{"2":{"211":1}}],["像20这样的十进制整数字面值",{"2":{"65":1}}],["静态类型与动态类型",{"2":{"300":1}}],["静态成员遵循通用的访问控制规则",{"2":{"299":1}}],["静态成员可以是public或private",{"2":{"258":1}}],["静态函数不包含this指针",{"2":{"258":1}}],["静态数据成员定义在函数体之外",{"2":{"258":1}}],["静态数据成员不属于类的对象",{"2":{"258":1}}],["静态数据成员",{"2":{"210":1}}],["静态内存用来保存局部static对象",{"2":{"50":1}}],["全局作用域是隐式的",{"2":{"210":1}}],["全局作用域内的名字在整个程序的范围内都可使用",{"2":{"70":1}}],["违反异常说明",{"2":{"208":1}}],["预存了end",{"2":{"286":1}}],["预先分配的内存地址上构造对象",{"2":{"223":1}}],["预先知道某个函数不会抛出异常大有裨益",{"2":{"208":1}}],["预处理器概述",{"2":{"86":1}}],["预处理器还定义了4个对于调试程序很有用的名字",{"2":{"46":1}}],["修改了异常对象",{"2":{"207":1}}],["放在后面",{"2":{"207":1}}],["放在前面",{"2":{"207":1}}],["放在const关键字之前用以说明指针是一个常量",{"2":{"77":1}}],["挑选出来的应该是第一个与异常匹配的catch语句",{"2":{"207":1}}],["看起来像是只包含一个形参的函数形参列表",{"2":{"207":1}}],["捕获异常",{"0":{"207":1}}],["抛出异常将终止当前的函数",{"2":{"293":1}}],["抛出异常的一个例子是",{"2":{"293":1}}],["抛出异常",{"0":{"206":1}}],["异常",{"2":{"329":1}}],["异常类型只定义了一个名为what的成员函数",{"2":{"295":1}}],["异常检测部分使用throw表达式来表示它遇到了无法处理的问题",{"2":{"292":1}}],["异常是指存在于运行时的反常行为",{"2":{"292":1}}],["异常声明的静态类型将决定catch语句所能执行的操作",{"2":{"207":1}}],["异常对象的status成员没有改变",{"2":{"207":1}}],["异常对象的status成员是severerr",{"2":{"207":1}}],["异常对象",{"2":{"206":2}}],["异常使得我们能够将问题的检测与解决过程分离开来",{"2":{"205":1}}],["异常处理部分使用try语句块处理异常",{"2":{"292":1}}],["异常处理包括",{"2":{"292":1}}],["异常处理机制为程序中异常检测和异常处理这两部分的协作提供支持",{"2":{"292":1}}],["异常处理",{"0":{"205":1},"1":{"206":1,"207":1,"208":1},"2":{"204":1,"205":1}}],["大规模应用程序的特殊要求包括",{"2":{"204":1}}],["大规模编程对程序设计语言的要求更高",{"2":{"204":1}}],["大多数算法具有如下4种形式之一",{"2":{"201":1}}],["大多数算法提供了一种方法",{"2":{"185":1}}],["大多数算法定义在头文件algorithm中",{"2":{"185":1}}],["大多数常见的安全问题都源于缓冲区溢出错误",{"2":{"102":1}}],["大多数应用应该使用标准库容器而不是动态分配的数组",{"2":{"58":1}}],["大多数类类型的对象在传递给省略符形参时都无法正确拷贝",{"2":{"36":1}}],["大多数类型都能用作函数的返回类型",{"2":{"27":1}}],["交换两个容器的操作保证会很快",{"2":{"315":1}}],["交换",{"2":{"203":1}}],["交换操作",{"0":{"129":1}}],["几乎所有算法都有一个输入范围",{"2":{"201":1}}],["几乎可以肯定它也需要一个拷贝赋值运算符",{"2":{"123":1}}],["支持全部迭代器运算",{"2":{"199":1}}],["支持未格式化io",{"2":{"162":1}}],["元素",{"2":{"203":1,"286":1}}],["元素将被插入到给定迭代器所表示的元素之前",{"2":{"196":1}}],["元素数量相同",{"2":{"96":1}}],["差异在于元素插入的位置",{"2":{"196":1}}],["差别在于名字的后缀是g还是p",{"2":{"163":1}}],["能否访问其直接基类的成员没什么影响",{"2":{"303":1}}],["能访问sneaky",{"2":{"303":1}}],["能实现向给定容器添加元素",{"2":{"196":1}}],["能在调用中应用于函数模板的包括如下两项",{"2":{"172":1}}],["占位符",{"2":{"194":1}}],["原始的",{"2":{"222":1}}],["原对象的参数列表",{"2":{"194":1}}],["原因分析如下",{"2":{"123":1}}],["介绍",{"2":{"195":1}}],["介绍lambda",{"2":{"192":1}}],["介绍back",{"2":{"188":1}}],["超出了算法对谓词的限制",{"2":{"192":1}}],["超出bitset大小的高位被丢弃",{"2":{"155":1}}],["谓词是一个可调用的表达式",{"2":{"191":1}}],["谓词",{"2":{"191":1}}],["插入器是一种迭代器适配器",{"2":{"196":1}}],["插入迭代器会将新元素添加到容器中",{"2":{"201":1}}],["插入迭代器",{"0":{"196":1},"2":{"195":1}}],["插入迭代器是一种向容器中添加元素的迭代器",{"2":{"188":1}}],["插入第一个元素",{"2":{"20":1}}],["附录a按照操作方式列出了所有的算法",{"2":{"186":1}}],["算法还遵循一套命名和重载规范",{"2":{"202":1}}],["算法命名规范",{"0":{"202":1}}],["算法假定",{"2":{"201":1}}],["算法的形参模式",{"0":{"201":1}}],["算法所要求的迭代器操作可以分为5个迭代器类别",{"2":{"199":1}}],["算法不依赖于容器",{"2":{"185":1}}],["算法并不直接操作容器",{"2":{"185":1}}],["算术转换",{"0":{"274":1},"2":{"274":1}}],["算术表达式有可能产生未定义的结果",{"2":{"264":1}}],["算术运算符的运算对象和求值结果都是右值",{"2":{"264":1}}],["算术运算符中",{"2":{"264":1}}],["算术运算符",{"0":{"264":1}}],["算术和关系运算符",{"0":{"139":1},"1":{"140":1}}],["算术类型尺寸表格见书本p30",{"2":{"63":1}}],["算术类型的尺寸",{"2":{"63":1}}],["算术类型分为整型和浮点型",{"2":{"63":1}}],["算术类型",{"0":{"63":1},"2":{"79":1}}],["概述",{"0":{"185":1}}],["版本还接受c风格字符串",{"2":{"326":1}}],["版本的构造函数",{"2":{"255":1}}],["版本",{"2":{"183":1,"202":1,"326":1}}],["版本参数t是int",{"2":{"176":1}}],["扩展rest",{"2":{"182":1}}],["扩展args",{"2":{"182":1}}],["扩展一个包就是将它分解为构成的元素",{"2":{"182":1}}],["打印其他实参",{"2":{"181":1}}],["打印整型值时显示进制",{"2":{"161":1}}],["存在两种参数包",{"2":{"180":1}}],["存放文件编译日期的字符串字面值",{"2":{"46":1}}],["存放文件编译时间的字符串字面值",{"2":{"46":1}}],["存放文件名的字符串字面值",{"2":{"46":1}}],["存放当前行号的整型字面值",{"2":{"46":1}}],["候选函数总是可行的",{"2":{"179":1}}],["候选函数具备两个特征",{"2":{"47":1}}],["再求i的值",{"2":{"263":1}}],["再执行自己的",{"2":{"253":1}}],["再探迭代器",{"0":{"195":1},"1":{"196":1,"197":1,"198":1}}],["再次对forward",{"2":{"178":1}}],["再在运行时向其中添加具体值",{"2":{"95":1}}],["模式是函数参数包的名字",{"2":{"182":1}}],["模式是const",{"2":{"182":1}}],["模版参数t是int",{"2":{"176":1}}],["模板特例化",{"0":{"183":1}}],["模板",{"2":{"174":1}}],["模板实参推断和引用",{"0":{"176":1}}],["模板实参推断",{"0":{"171":1},"1":{"172":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1}}],["模板默认实参与类模板",{"2":{"168":1}}],["模板声明必须包含模板参数",{"2":{"168":1}}],["模板参数包",{"2":{"180":1}}],["模板参数t是int",{"2":{"176":1}}],["模板参数t是const",{"2":{"176":1}}],["模板参数类型t是int",{"2":{"176":1}}],["模板参数不匹配",{"2":{"173":1}}],["模板参数会隐藏外层作用域中声明的相同名字",{"2":{"168":1}}],["模板参数",{"0":{"168":1}}],["模板参数列表不能为空",{"2":{"166":1}}],["模板的一个特定实例",{"2":{"167":1}}],["模板的头文件通常既包括声明也包括定义",{"2":{"166":1}}],["模板则不同",{"2":{"166":1}}],["模板时",{"2":{"166":1}}],["模板类型参数与非模板参数",{"2":{"166":1}}],["模板就是函数或者类的公式",{"2":{"164":1}}],["模板是c++泛型编程的基础",{"2":{"164":1}}],["模板是为编译器提供的一份生成类或函数的说明",{"2":{"93":1}}],["模板与泛型编程",{"0":{"164":1},"1":{"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1,"172":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1,"183":1},"2":{"0":1}}],["变成一个左值引用",{"2":{"176":1}}],["变量也就超出其作用范围了",{"2":{"279":1}}],["变量等",{"2":{"210":1}}],["变量捕获的方式可以是值或引用",{"2":{"193":1}}],["变量表达式都是左值",{"2":{"131":1}}],["变量表达式也有左值",{"2":{"131":1}}],["变量可以看作只有一个运算对象而没有运算符的表达式",{"2":{"131":1}}],["变量是左值",{"2":{"131":1,"178":1}}],["变量是一种可以作为赋值语句左值的特殊表达式",{"2":{"83":1}}],["变量在离开其作用域时被销毁",{"2":{"122":1}}],["变量的定义包括一个基本数据类型",{"2":{"74":1}}],["变量能且只能被定义一次",{"2":{"68":1}}],["变量声明和定义的关系",{"0":{"68":1}}],["变量定义的基本形式是",{"2":{"67":1}}],["变量定义",{"0":{"67":1}}],["变量提供一个具名",{"2":{"66":1}}],["变量",{"0":{"66":1},"1":{"67":1,"68":1,"69":1,"70":1},"2":{"70":1}}],["变量和基本类型",{"0":{"61":1},"1":{"62":1,"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":1,"83":1,"84":1,"85":1,"86":1},"2":{"0":1}}],["又通过折叠",{"2":{"176":1}}],["又因为使用重载的函数运算符本质上是一次函数调用",{"2":{"135":1}}],["时",{"2":{"176":4,"300":1}}],["让上面的fcn函数返回一个元素的值而非引用",{"2":{"174":1}}],["让编译器验证变量的值是否是一个常量表达式",{"2":{"79":1}}],["灵活性",{"2":{"170":1}}],["避免了间接调用删除器的运行时开销",{"2":{"170":1}}],["效率",{"2":{"170":1}}],["效果就是检测它是否为空",{"2":{"52":1}}],["尖括号指出类必须从一个模板实例化而来",{"2":{"168":1}}],["尖括号中的名字指出了一个头文件",{"2":{"109":1}}],["至于什么样的类能够作为虚基类并没有特殊规定",{"2":{"218":1}}],["至模板声明或定义结束之前",{"2":{"168":1}}],["至少含有一个constexpr构造函数",{"2":{"257":1}}],["至少为32767",{"2":{"158":1}}],["至少有一个实参的匹配优于其他可行函数提供的匹配",{"2":{"47":1}}],["注意上述模板参数列表只有一个typename",{"2":{"167":1}}],["注释界定符不能嵌套",{"2":{"110":1}}],["注释",{"2":{"110":1}}],["注释简介",{"0":{"110":1}}],["代替使用模板时用户需要提供的类型或值",{"2":{"167":1}}],["他们的含义没什么不同",{"2":{"166":1}}],["他们定义在cstring头文件中",{"2":{"104":1}}],["奖标记定位到from之前或之后off个字符",{"2":{"163":1}}],["到流中给定的位置",{"2":{"163":1}}],["到底是由一个计数器还是其他数据结构来记录有多少指针共享对象",{"2":{"52":1}}],["流迭代器",{"2":{"195":1}}],["流结尾位置",{"2":{"163":1}}],["流当前位置",{"2":{"163":1}}],["流开始位置",{"2":{"163":1}}],["流随机访问",{"0":{"163":1}}],["流程直接",{"2":{"45":1}}],["多个基类的情况与之类似",{"2":{"216":1}}],["多个库将名字放置在全局命名空间中将引发命名空间污染",{"2":{"209":1}}],["多重继承下的类作用域",{"0":{"217":1}}],["多重继承的派生类如果定义了自己的拷贝",{"2":{"215":1}}],["多重继承的派生类的拷贝与移动操作",{"2":{"215":1}}],["多重继承的派生类的构造函数初始值也只能初始化它的直接基类",{"2":{"215":1}}],["多重继承的派生类继承了所以父类的属性",{"2":{"214":1}}],["多重继承",{"0":{"215":1}}],["多重继承是指从多个直接基类中产生派生类的能力",{"2":{"214":1}}],["多重继承与虚继承",{"0":{"214":1},"1":{"215":1,"216":1,"217":1,"218":1,"219":1}}],["多数链表特有的算法与通用版本的很相似",{"2":{"203":1}}],["多遍扫描",{"2":{"199":3}}],["多字节操作",{"2":{"162":1}}],["多维数组的首元素是一个内层数组",{"2":{"105":1}}],["多维数组的下标引用",{"2":{"105":1}}],["多维数组的初始化",{"2":{"105":1}}],["多维数组",{"0":{"105":1},"2":{"105":1}}],["单语句链接指示",{"2":{"236":1}}],["单个的或复合的",{"2":{"236":1}}],["单遍扫描",{"2":{"199":2}}],["单字节操作",{"2":{"162":1}}],["单行注释和界定符注释",{"2":{"110":1}}],["恢复流状态",{"2":{"161":1}}],["浮点值的精度",{"2":{"161":1}}],["浮点型和字符型字面值的默认类型",{"2":{"65":1}}],["浮点型字面值是一个double",{"2":{"65":1}}],["浮点型字面值表现为一个小数或以科学计数法表示的指数",{"2":{"65":1}}],["浮点型可表示单精度",{"2":{"63":1}}],["格式状态控制格式化的某些方面",{"2":{"161":1}}],["格式化输入与输出",{"0":{"161":1}}],["稍微随机些的种子",{"2":{"159":1}}],["种子就是一个数值",{"2":{"159":1}}],["设置随机数发生器种子",{"2":{"159":1}}],["仍然可以生成不同的序列",{"2":{"159":1}}],["均匀分布的随机数",{"2":{"159":1}}],["区别在于性能和随机质量不同",{"2":{"159":1}}],["生成一个可调用对象",{"2":{"231":1}}],["生成一个迭代器",{"2":{"196":1}}],["生成一个新的可调用对象来",{"2":{"194":1}}],["生成一个随机无符号数",{"2":{"159":1}}],["生成非均匀分布随机数等",{"2":{"159":1}}],["生成随机实数",{"2":{"159":1}}],["生成随机unsigned整数序列",{"2":{"158":1}}],["生成0到9之间",{"2":{"159":1}}],["引发",{"2":{"292":1}}],["引入const成员函数",{"2":{"238":1}}],["引入this",{"2":{"238":1}}],["引擎可以利用它从序列中一个新位置重新开始生成随机数",{"2":{"159":1}}],["引擎生成一个数值序列",{"2":{"159":1}}],["引擎",{"2":{"158":1}}],["引用和指针都会失效",{"2":{"321":1}}],["引用和指针失效",{"2":{"319":1}}],["引用或指针的静态类型决定了该对象的哪些成员是可见的",{"2":{"304":1}}],["引用或指针可以访问静态成员",{"2":{"258":1}}],["引用or指针访问",{"2":{"249":1}}],["引用捕获是变量的引用",{"2":{"193":1}}],["引用时",{"2":{"176":1}}],["引用限定符必须跟随在const限定符之后",{"2":{"133":1}}],["引用计数应该保存在动态内存中",{"2":{"128":1}}],["引用计数的工作方式如下",{"2":{"128":1}}],["引用计数",{"2":{"128":1}}],["引用的类型必须与其所引用对象的类型一致",{"2":{"76":1}}],["引用只能绑定在对象上",{"2":{"72":1}}],["引用并非对象",{"2":{"72":1}}],["引用将和它的初始值对象一直绑定在一起",{"2":{"72":1}}],["引用",{"0":{"72":1},"2":{"72":1,"79":1,"252":1,"258":1,"321":1,"323":1}}],["引用是一种常见错误",{"2":{"33":1}}],["引用形参绑定到对应的实参上",{"2":{"34":1}}],["引用形参为我们一次返回多个结果提供了有效的途径",{"2":{"32":1}}],["引用形参也是如此",{"2":{"32":1}}],["我认为它应该有其合适的应用场景",{"2":{"291":1}}],["我使用gcc5",{"2":{"157":1}}],["我们原本很可能希望覆盖",{"2":{"301":1}}],["我们不希望其他类继承它",{"2":{"299":1}}],["我们不能",{"2":{"302":1}}],["我们不能将一个右值引用绑定到一个右值引用类型的变量上",{"2":{"131":1}}],["我们不能使用weak",{"2":{"57":1}}],["我们知道并且不在乎潜在的精度损失",{"2":{"276":1}}],["我们称这样的类为局部类",{"2":{"234":1}}],["我们称之为重载",{"2":{"41":1}}],["我们提供给function的形式中还必须指明对象是否以指针或引用的形式传入",{"2":{"231":1}}],["我们提供新的operator",{"2":{"222":1}}],["我们令其指向类的某个成员",{"2":{"229":1}}],["我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数",{"2":{"224":1}}],["我们既可以通过对象调用析构函数",{"2":{"223":1}}],["我们既可以在类模板的内部",{"2":{"167":1}}],["我们应该使用new的定位new",{"2":{"223":1}}],["我们应当将此事通知标准库",{"2":{"132":1}}],["我们都至少会执行一次循环",{"2":{"287":1}}],["我们都不能改变new运算符和delete运算符的基本含义",{"2":{"222":1}}],["我们都必须在模板名之后接上尖括号",{"2":{"168":1}}],["我们指定虚基类的方式是在派生列表中添加关键字virtual",{"2":{"218":1}}],["我们指出this的左值",{"2":{"133":1}}],["我们无法控制哪些名字是可见的",{"2":{"211":1}}],["我们无法改变initializer",{"2":{"36":1}}],["我们最终找到的catch未必是异常的最佳匹配",{"2":{"207":1}}],["我们传递给算法的谓词必须严格接受一个或两个参数",{"2":{"192":1}}],["我们传递给get一个tuple对象",{"2":{"153":1}}],["我们还能把某个虚函数函数指定为final",{"2":{"301":1}}],["我们还可以使用bind从成员函数生成一个可调用对象",{"2":{"231":1}}],["我们还可以特例化类模板",{"2":{"183":1}}],["我们还可以提供一个元素初始化器的花括号列表",{"2":{"59":1}}],["我们还要提供用于每个扩展元素的模式",{"2":{"182":1}}],["我们还需要定义一个非可变参数的版本",{"2":{"181":1}}],["我们需要分别构造或析构该类类型的成员",{"2":{"233":1}}],["我们需要通过作用域运算符在外部显式地访问枚举成员",{"2":{"228":1}}],["我们需要保持被转发实参的所有性质",{"2":{"178":1}}],["我们需要以合理的实参调用它们",{"2":{"41":1}}],["我们希望对虚函数的调用不要进行动态绑定",{"2":{"301":1}}],["我们希望用户控制模板实例化",{"2":{"173":1}}],["我们希望将内存分配和对象构造分离",{"2":{"60":1}}],["我们在一次调用中传递给函数模板的实参被用来初始化函数的形参",{"2":{"172":1}}],["我们在本应该出现返回类型的地方放置一个auto",{"2":{"40":1}}],["我们必须通过构造函数初始值列表为这些成员提供初始值",{"2":{"252":1}}],["我们必须提供成员的调用形式",{"2":{"231":1}}],["我们必须提供额外信息",{"2":{"167":1}}],["我们必须显式地声明函数类型以明确指出我们想要使用哪个函数",{"2":{"230":1}}],["我们必须在构造函数初始值列表中显式地调用该构造函数",{"2":{"308":1}}],["我们必须在",{"2":{"229":1}}],["我们必须在模板名后的尖括号中提供额外信息",{"2":{"167":1}}],["我们必须首先声明模板自身",{"2":{"167":1}}],["我们必须指明这个allocator可以分配的对象类型",{"2":{"60":1}}],["我们用一个省略号来指出一个模板参数或函数参数表示一个包",{"2":{"180":1}}],["我们用名字t表示一个类型",{"2":{"166":1}}],["我们用实参初始化函数的形参",{"2":{"26":1}}],["我们",{"2":{"166":1}}],["我们只能通过typeid运算符创建type",{"2":{"227":1}}],["我们只能对istream使用g版本",{"2":{"163":1}}],["我们只能将函数作用于大小为10的数组",{"2":{"34":1}}],["我们当前的位置",{"2":{"163":1}}],["我们就担负起了控制动态内存分配的职责",{"2":{"222":1}}],["我们就改变了cout打印bool值的方式",{"2":{"161":1}}],["我们就需要编译它",{"2":{"108":1}}],["我们才能使用这两个操作",{"2":{"156":1}}],["我们才能比较它们",{"2":{"153":1}}],["我们定义一个比较简单的类",{"2":{"150":1}}],["我们同样能定义对于类类型的类型转换",{"2":{"149":1}}],["我们也可以采取另外一种方法",{"2":{"231":1}}],["我们也可以提供默认模板实参",{"2":{"168":1}}],["我们也应该为类定义两个版本的递增和递减运算符",{"2":{"143":1}}],["我们也需要使用头文件来自己的类",{"2":{"116":1}}],["我们能把派生类的对象当成基类对象来使用",{"2":{"299":1}}],["我们能对它做的唯一的事情就是扩展",{"2":{"182":1}}],["我们能像调用普通函数一样直接调用运算符函数",{"2":{"135":1}}],["我们能用下面的任意一种形式来表示数值20",{"2":{"65":1}}],["我们将在每个实参类",{"2":{"213":1}}],["我们将在第15章看到出于第二种原因的例子",{"2":{"52":1}}],["我们将此元素范围称为",{"2":{"186":1}}],["我们将模版参数当作替身",{"2":{"167":1}}],["我们将类定义和函数声明放在头文件中",{"2":{"166":1}}],["我们将不再使用它",{"2":{"131":1}}],["我们有一个左值",{"2":{"131":1}}],["我们虽然声明了它们",{"2":{"125":1}}],["我们显示或隐式地指定在此类型的对象拷贝",{"2":{"118":1}}],["我们使用using声明语句改变了这些成员的可访问性",{"2":{"303":1}}],["我们使用union时",{"2":{"233":1}}],["我们使用重载运算符时",{"2":{"261":1}}],["我们使用通用的成员访问运算符访问一个union对象的成员",{"2":{"233":1}}],["我们使用classname",{"2":{"230":1}}],["我们使用省略号作为异常声明",{"2":{"207":1}}],["我们使用一个分布类型的对象",{"2":{"159":1}}],["我们使用一种特殊形式的delete",{"2":{"59":1}}],["我们使用",{"2":{"117":1,"230":1}}],["我们按需要在此内存中构造对象",{"2":{"60":1}}],["我们并未得到一个数组类型的对象",{"2":{"59":1}}],["我们要在类型名之后跟一对方括号",{"2":{"59":1}}],["我们的程序不应该依赖于移后源对象中的数据",{"2":{"132":1}}],["我们的程序到目前为止只使用过静态内存或栈内存",{"2":{"50":1}}],["我们的类只有数据成员",{"2":{"85":1}}],["我们的代码必须显示地销毁它们",{"2":{"50":1}}],["我们把算术运算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换",{"2":{"139":1}}],["我们把这个反复出现的值称为函数的默认实参",{"2":{"44":1}}],["我们把只存在于块执行期间的对象称为自动对象",{"2":{"27":1}}],["我们允许main函数没有return语句直接结束",{"2":{"39":1}}],["我们说throw",{"2":{"292":1}}],["我们说这个对象被初始化",{"2":{"67":1}}],["我们说这样的实参被值传递",{"2":{"30":1}}],["我们说它对应的实参被引用传递",{"2":{"30":1}}],["我们建议函数在头文件中声明",{"2":{"28":1}}],["我们通常把含有类类型成员的union内嵌在另一个类当中",{"2":{"233":1}}],["我们通常希望每次运行程序都会生成不同的随机结果",{"2":{"159":1}}],["我们通常计划在这块内存上按需构造对象",{"2":{"60":1}}],["我们通常不对关联容器使用泛型算法",{"2":{"19":1}}],["我们通过在基类中奖析构函数定义成虚析构函数以确保执行正确的析构函数版本",{"2":{"306":1}}],["我们通过在模式右边放一个省略号",{"2":{"182":1}}],["我们通过抛出",{"2":{"206":1}}],["我们通过使用关键字typename来实现这一点",{"2":{"168":1}}],["我们通过一个特定的类型名来指定非类型参数",{"2":{"166":1}}],["我们通过一个关键字而不是位置来查找值",{"2":{"13":1}}],["我们通过delete表达式",{"2":{"53":1}}],["我们通过",{"2":{"26":1}}],["我们通过调用函数执行相应的代码",{"2":{"25":1}}],["我们会得到一个类型为容器的value",{"2":{"19":1}}],["我们可以对begin递增若干次",{"2":{"313":1}}],["我们可以直接访问它的成员",{"2":{"233":1}}],["我们可以像显式地初始化聚合类一样使用一对花括号内的初始值显式地初始化一个union",{"2":{"233":1}}],["我们可以像使用istream对象一样来使用它们",{"2":{"2":1}}],["我们可以声明一个指针",{"2":{"230":1}}],["我们可以重新使用该空间",{"2":{"223":1}}],["我们可以重写翻转函数",{"2":{"178":1}}],["我们可以令某个可访问的基类的指针或引用直接指向一个派生类对象",{"2":{"216":1}}],["我们可以向一个算法传递任何类别的可调用对象",{"2":{"192":1}}],["我们可以保持其对应实参的所有类型信息",{"2":{"178":1}}],["我们可以传递给它一个右值",{"2":{"176":1}}],["我们可以传入一个greater类型的对象",{"2":{"147":1}}],["我们可以通过上面的方式组织命名空间并达到目的",{"2":{"210":1}}],["我们可以通过提供noexcept说明",{"2":{"208":1}}],["我们可以通过显式实例化",{"2":{"170":1}}],["我们可以通过调用一个随机数引擎对象来生成原始随机数",{"2":{"159":1}}],["我们可以定义一个typedef来引用实例化的类",{"2":{"167":1}}],["我们可以将该类的直接或间接基类中任何可访问成员标记出来",{"2":{"303":1}}],["我们可以将类的接口与实现分离",{"2":{"297":1}}],["我们可以将类型参数看作类型说明符",{"2":{"166":1}}],["我们可以将整型字面值写作十进制数",{"2":{"65":1}}],["我们可以从一个string或一个字符数组指针来初始化bitset",{"2":{"155":1}}],["我们可以为其指定具体的应用类型",{"2":{"147":1}}],["我们可以强制左侧运算对象是一个左值",{"2":{"133":1}}],["我们可以自由地将一个右值引用的资源移动到另一个对象中",{"2":{"131":1}}],["我们可以改变使用new的方式来阻止它抛出异常",{"2":{"53":1}}],["我们可以改变pair的值",{"2":{"19":1}}],["我们可以把assert当成调试程序的一种辅助手段",{"2":{"46":1}}],["我们可以编写一种可变参数模板",{"2":{"36":1}}],["我们可以使用static",{"2":{"276":1}}],["我们可以使用命名空间名字的简写形式",{"2":{"211":1}}],["我们可以使用泛型算法从流对象读取数据以及向其写入数据",{"2":{"197":1}}],["我们可以使用标准库的类型转换",{"2":{"174":1}}],["我们可以使用任何名字",{"2":{"168":1}}],["我们可以使用操纵符hex",{"2":{"161":1}}],["我们可以使用一个initializer",{"2":{"181":1}}],["我们可以使用一个名为forward的新标准库设施来传递flip2的参数",{"2":{"178":1}}],["我们可以使用一个",{"2":{"46":1}}],["我们可以使用非常量初始化一个底层const",{"2":{"33":1}}],["我们可以使用unitbuf操纵符",{"2":{"5":1}}],["我们可以利用这些函数获取迭代器",{"2":{"19":1}}],["说明",{"2":{"157":1,"158":1,"162":1,"163":1,"227":1,"325":1}}],["说明了数组中元素的个数",{"2":{"101":1}}],["说明了调用该函数所需的全部信息",{"2":{"28":1}}],["组成",{"2":{"259":1}}],["组成的列表以及函数体",{"2":{"26":1}}],["组件",{"2":{"157":1,"158":1}}],["~quote",{"2":{"298":1,"306":1}}],["~expr",{"2":{"270":1}}],["~endangered",{"2":{"215":1}}],["~",{"2":{"270":1}}],["~zooanimal",{"2":{"215":1}}],["~base被自动调用执行",{"2":{"308":1}}],["~bear",{"2":{"215":1}}],["~bitvec",{"2":{"156":1}}],["~panda",{"2":{"215":1}}],["~foo",{"2":{"122":1}}],["置位第一位",{"2":{"156":1}}],["剩余两位为0",{"2":{"155":1}}],["剩下的元素执行值初始化",{"2":{"101":1}}],["低位为1",{"2":{"155":1}}],["书写=0就可以将一个虚函数说明为纯虚函数",{"2":{"302":1}}],["书写形如t",{"2":{"254":1}}],["书上建议不要使用goto语句",{"2":{"291":1}}],["书本上有例子的详细解读",{"2":{"293":1}}],["书本上给出一个翻转函数的例子",{"2":{"178":1}}],["书本使用一个详细的案例screen来阐述本节的知识点",{"2":{"246":1}}],["书本以动物体系为例进行讲解",{"2":{"214":1}}],["书本p606列出了所有类型转换模板",{"2":{"174":1}}],["书本里有一个完整的例子",{"2":{"115":1}}],["书中也建议尽量避免其他的强制类型转换",{"2":{"276":1}}],["书中建议尽量避免使用",{"2":{"276":1}}],["书中拿shared",{"2":{"170":1}}],["书中未给出代码案例讲解",{"2":{"162":1}}],["书中给出的案例见p638",{"2":{"152":1}}],["举例",{"2":{"269":1}}],["举一个简单的例子",{"2":{"225":1}}],["举一个列子",{"2":{"187":1}}],["举一个例子",{"2":{"40":1}}],["举个例子",{"2":{"150":1}}],["进行强制类型转换以便执行浮点数除法",{"2":{"276":1}}],["进行协同开发的能力",{"2":{"204":1}}],["进行定义",{"2":{"150":1}}],["进行io操作的函数通常以引用方式传递或返回流",{"2":{"3":1}}],["转换回初始的指针类型",{"2":{"276":1}}],["转换成常量",{"2":{"275":1}}],["转换成布尔类型",{"2":{"275":1}}],["转换的结果是false",{"2":{"275":1}}],["转换构造函数和类型转换运算符共同定义了类类型转换",{"2":{"149":1}}],["转发",{"0":{"178":1}}],["转义序列见书本p36",{"2":{"65":1}}],["转义序列以反斜线作为开始",{"2":{"65":1}}],["转义序列",{"2":{"65":1}}],["之前介绍的经验准则说",{"2":{"306":1}}],["之前介绍了拷贝赋值和移动赋值运算符",{"2":{"141":1}}],["之前添加classname",{"2":{"229":1}}],["之后才会执行statement",{"2":{"286":1}}],["之后才使用它",{"2":{"138":1}}],["之后需要调用",{"2":{"203":1}}],["之后尖括号内容叫模板参数列表",{"2":{"166":1}}],["之间",{"2":{"158":1}}],["具有固定的大小",{"2":{"155":1}}],["具有对称性的运算符可能转换任意一端的运算对象",{"2":{"135":1}}],["具体见p302",{"2":{"315":1}}],["具体见书本p751",{"2":{"233":1}}],["具体见书本上的讨论",{"2":{"213":1}}],["具体的原因见p163",{"2":{"282":1}}],["具体例子可以参考",{"2":{"232":1}}],["具体例子可见于书本p210",{"2":{"42":1}}],["具体操作见p674",{"2":{"162":1}}],["具体是哪种由编译器决定",{"2":{"63":1}}],["具体排序如下所示",{"2":{"48":1}}],["具体使用案例见书本p375",{"2":{"13":1}}],["逗号运算符真正的结果是右侧表达式的值",{"2":{"272":1}}],["逗号运算符",{"0":{"272":1},"2":{"135":1,"272":1}}],["逻辑运算符和关系运算符的返回值都是布尔类型",{"2":{"265":1}}],["逻辑运算符作用于任意能转换成布尔值的类型",{"2":{"265":1}}],["逻辑和关系运算符",{"0":{"265":1}}],["逻辑或",{"2":{"263":1}}],["逻辑或运算符",{"2":{"135":1}}],["逻辑与",{"2":{"135":1,"263":1}}],["二元谓词",{"2":{"191":1}}],["二元运算符有两个",{"2":{"135":1}}],["二是在派生类的派生列表中的访问说明符",{"2":{"303":1}}],["二是有时候根本搞不清到底需要什么类型",{"2":{"80":1}}],["二是将控制权转移给被调用函数",{"2":{"26":1}}],["移出边界之外的位数被舍弃掉了",{"2":{"270":1}}],["移位运算符",{"2":{"270":1}}],["移后源对象必须保持有效的",{"2":{"132":1}}],["移动或赋值",{"2":{"300":1}}],["移动或赋值成员时",{"2":{"215":1}}],["移动或赋值操作",{"2":{"215":1}}],["移动迭代器",{"2":{"195":1}}],["移动右值",{"2":{"132":1}}],["移动操作还必须保证对象仍然是有效的",{"2":{"132":1}}],["移动操作通常不分配资源",{"2":{"132":1}}],["移动的版本从给定对象",{"2":{"132":1}}],["移动赋值运算符必须正确处理自赋值",{"2":{"132":1}}],["移动赋值运算符执行与析构函数和移动构造函数相同的工作",{"2":{"132":1}}],["移动赋值运算符",{"2":{"118":1,"132":1}}],["移动构造函数不应抛出异常",{"2":{"132":1}}],["移动构造函数还必须确保移后源对象处于这样一个状态",{"2":{"132":1}}],["移动构造函数的第一个参数是该类型的一个右值引用",{"2":{"132":1}}],["移动构造函数和移动赋值运算符",{"0":{"132":1}}],["移动构造函数",{"2":{"118":1}}],["移动",{"2":{"118":1,"133":1,"305":1}}],["移动到下一个元素",{"2":{"19":1}}],["源对象会被销毁",{"2":{"132":1}}],["源文件的开始位置",{"2":{"109":1}}],["资源而不是拷贝资源",{"2":{"132":1}}],["窃取",{"2":{"132":1}}],["虽然由42推断出来的参数类型是int",{"2":{"178":1}}],["虽然不能隐式地将一个左值转换为右值引用",{"2":{"177":1}}],["虽然不能直接将一个右值引用绑定到一个左值上",{"2":{"177":1}}],["虽然不能将一个右值引用直接绑定到一个左值上",{"2":{"131":1}}],["虽然基本数据类型只有一个",{"2":{"74":1}}],["左移运算符",{"2":{"270":1}}],["左移",{"2":{"270":1}}],["左侧运算对象的拷贝作为求值结果",{"2":{"270":1}}],["左侧运算对象绑定到隐式的this指针",{"2":{"141":1}}],["左侧运算对象传递给第一个参数",{"2":{"135":1}}],["左侧",{"2":{"135":1}}],["左侧必须是一个ostream对象",{"2":{"109":1}}],["左值可以位于赋值语句的左侧",{"2":{"261":1}}],["左值和右值",{"2":{"261":1}}],["左值",{"2":{"176":1}}],["左值有持久的状态",{"2":{"131":1}}],["左值与右值的区别",{"2":{"131":1}}],["右移运算符",{"2":{"270":1}}],["右移",{"2":{"270":1}}],["右值则不能",{"2":{"261":1}}],["右值属性将得到保持",{"2":{"178":1}}],["右值属性的方式与定义const成员函数相同",{"2":{"133":1}}],["右值属性",{"2":{"131":1,"178":1}}],["右值短暂",{"2":{"131":1}}],["右值引用和成员函数",{"0":{"133":1}}],["右值引用必须绑定到右值",{"2":{"131":1}}],["右值引用",{"0":{"131":1},"2":{"131":1}}],["右侧的运算对象一定不能为负",{"2":{"270":1}}],["右侧运算对象转换成左侧运算对象的类型",{"2":{"273":1}}],["右侧运算对象传递给第二个参数",{"2":{"135":1}}],["右侧运算对象必须是该类型的一个成员名",{"2":{"117":1}}],["右侧是要打印的值",{"2":{"109":1}}],["令成员作为内联函数",{"2":{"245":1}}],["令其指向含有两个形参的get",{"2":{"230":1}}],["令其返回值是指向该成员的指针",{"2":{"229":1}}],["令其表示0到255之间的一个整数",{"2":{"150":1}}],["令其使用捕获的变量的值来初始化数据成员",{"2":{"146":1}}],["令size成员保持public访问级别",{"2":{"303":1}}],["令string的加法运算符作用于string对象",{"2":{"147":1}}],["令s进入这样的状态",{"2":{"132":1}}],["令一个类展现类似指针的行为的最好方法是使用shared",{"2":{"128":1}}],["令iter指示容器中的上一个元素",{"2":{"98":1}}],["令iter指示容器中的下一个元素",{"2":{"98":1}}],["完成string的拷贝",{"2":{"127":1}}],["完全一致再比较长度",{"2":{"91":1}}],["完全由标准库的具体实现决定",{"2":{"52":1}}],["行为像值的类",{"0":{"127":1}}],["准备定义构造函数",{"2":{"126":1}}],["副本和原对象使用相同的底层数据",{"2":{"126":1}}],["副本和原对象是完全独立的",{"2":{"126":1}}],["细节见书本",{"2":{"125":1}}],["复位第i位",{"2":{"156":1}}],["复合语句也被称作块",{"2":{"278":1}}],["复合语句",{"2":{"278":2}}],["复合语句链接指示",{"2":{"236":1}}],["复合表达式",{"2":{"262":1}}],["复合赋值运算符一般来说应该是成员",{"2":{"135":1}}],["复合类型",{"0":{"71":1},"1":{"72":1,"73":1,"74":1},"2":{"71":1}}],["复制或销毁",{"2":{"125":1}}],["阻止赋值",{"2":{"125":1}}],["阻止拷贝",{"0":{"125":1},"2":{"125":1}}],["阻止丢弃的方法是同时指定app模式",{"2":{"8":1}}],["独一无二的序号",{"2":{"123":1}}],["独占",{"2":{"51":1}}],["五法则",{"0":{"123":1},"2":{"132":1}}],["三个成员都设置为0",{"2":{"153":1}}],["三个元素",{"2":{"15":1}}],["三",{"0":{"123":1}}],["什么时候会调用析构函数",{"2":{"122":1}}],["什么是成员函数",{"2":{"117":1}}],["隐式的类类型转换",{"0":{"255":1}}],["隐式地使用bear的默认构造函数初始化bear子对象",{"2":{"215":1}}],["隐式捕获",{"2":{"193":1}}],["隐式或显式地",{"2":{"166":1}}],["隐式销毁一个内置类型指针的成员不会delete它所指向的对象",{"2":{"122":1}}],["隐式构造返回值",{"2":{"17":1}}],["析构的部分是隐式的",{"2":{"122":1}}],["析构函数只负责销毁派生类自己分配的资源",{"2":{"308":1}}],["析构函数的调用顺序是",{"2":{"215":1}}],["析构函数的调用顺序正好与构造函数相反",{"2":{"215":1}}],["析构函数不应该抛出异常",{"2":{"206":1}}],["析构函数不能是删除的成员",{"2":{"125":1}}],["析构函数递减计数器",{"2":{"128":1}}],["析构函数释放对象在生存期分配的所有资源",{"2":{"122":1}}],["析构函数释放对象使用的资源",{"2":{"122":1}}],["析构函数完成什么工作",{"2":{"122":1}}],["析构函数是一个类的成员函数",{"2":{"122":1}}],["析构函数执行与构造函数相反的操作",{"2":{"122":1}}],["析构函数",{"0":{"122":1},"2":{"122":1,"126":1,"241":1}}],["成员的子对象",{"2":{"299":1}}],["成员的初始化顺序和它们在类内的定义顺序一致",{"2":{"252":1}}],["成员的初始化是在函数体执行之前完成的",{"2":{"122":1}}],["成员初始化的顺序",{"2":{"252":1}}],["成员初始化器接管s中的资源",{"2":{"132":1}}],["成员指针不是一个可调用对象",{"2":{"231":1}}],["成员指针",{"2":{"229":1}}],["成员模板不能是虚函数",{"2":{"169":1}}],["成员模板",{"0":{"169":1}}],["成员访问运算符",{"0":{"144":1,"268":1}}],["成员访问箭头",{"2":{"135":1}}],["成员运算符函数的参数数量比运算符的运算对象总数少一个",{"2":{"135":1}}],["成员函数size",{"2":{"316":1}}],["成员函数与继承",{"2":{"298":1}}],["成员函数中的名字查找",{"2":{"250":1}}],["成员函数体可以随意使用类中的成员",{"2":{"238":1}}],["成员函数的定义必须包含其所属的类名",{"2":{"238":1}}],["成员函数通过名为this的隐式参数来访问此对象",{"2":{"238":1}}],["成员函数指针",{"0":{"230":1}}],["成员函数也可以提供拷贝和移动的版本",{"2":{"133":1}}],["成员函数是定义为类的一部分的函数",{"2":{"117":1}}],["成员销毁时发生什么完全依赖于成员的类型",{"2":{"122":1}}],["成员按初始化顺序逆序销毁",{"2":{"122":1}}],["构造",{"0":{"325":1}}],["构造函数至多拷贝",{"2":{"325":1}}],["构造函数再探",{"0":{"251":1},"1":{"252":1,"253":1,"254":1,"255":1,"256":1,"257":1}}],["构造函数初始值列表",{"0":{"252":1},"2":{"240":1}}],["构造函数初始化对象的非static数据成员",{"2":{"122":1}}],["构造函数执行完毕后",{"2":{"240":1}}],["构造函数名和类名一致",{"2":{"240":1}}],["构造函数就会被执行",{"2":{"240":1}}],["构造函数",{"0":{"240":1}}],["构造函数与拷贝控制",{"0":{"305":1},"1":{"306":1,"307":1,"308":1,"309":1}}],["构造函数与析构函数的次序",{"2":{"219":1}}],["构造函数与虚继承",{"0":{"219":1}}],["构造一个派生类对象将同时构造并初始化它的所有基类子对象",{"2":{"215":1}}],["构造一个ifstream并打开给定的文件",{"2":{"7":1}}],["逐个赋值数组元素",{"2":{"121":1}}],["逐一检查函数调用提供的实参",{"2":{"47":1}}],["合成拷贝控制与继承",{"0":{"307":1}}],["合成拷贝构造函数",{"2":{"120":1}}],["合成的bulk",{"2":{"307":1}}],["合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化",{"2":{"307":1}}],["合成的默认构造函数根据如下规则初始化类成员",{"2":{"240":1}}],["合成的默认构造函数",{"2":{"240":1}}],["合成的赋值运算符中的成员也按照该顺序赋值",{"2":{"219":1}}],["合成的拷贝赋值版本只是做了浅拷贝操作",{"2":{"241":1}}],["合成的拷贝和移动构造函数按照完全相同的顺序执行",{"2":{"219":1}}],["合成的拷贝控制成员可能是删除的",{"2":{"125":1}}],["合成的析构函数体为空",{"2":{"215":1}}],["合成的移动操作",{"2":{"132":1}}],["合成的版本会将右侧运算对象的每个非static成员赋予左侧运算符对象的对应成员",{"2":{"121":1}}],["赋值或销毁的操作",{"2":{"307":1}}],["赋值或销毁操作",{"2":{"307":1}}],["赋值或销毁等工作",{"2":{"215":1}}],["赋值和拷贝",{"0":{"315":1}}],["赋值和销毁",{"2":{"305":1}}],["赋值和析构",{"0":{"241":1}}],["赋值运算要求两边容器类型和元素类型相同",{"2":{"315":1}}],["赋值运算满足右结合律",{"2":{"266":1}}],["赋值运算的细节由类本身决定",{"2":{"266":1}}],["赋值运算的结果是它左侧的运算对象",{"2":{"266":1}}],["赋值运算",{"2":{"241":1}}],["赋值运算符将其左边容器中的全部元素替换为右边容器中的元素的拷贝",{"2":{"315":1}}],["赋值运算符或析构函数类似",{"2":{"307":1}}],["赋值运算符的左侧运算对象必须是一个可修改的左值",{"2":{"266":1}}],["赋值运算符",{"0":{"141":1,"266":1},"2":{"121":1}}],["赋值运算符就是一个名为operator=的函数",{"2":{"121":1}}],["赋值构造函数和赋值运算符",{"2":{"215":1}}],["赋值操作的情况类似",{"2":{"132":1}}],["赋值与销毁",{"0":{"119":1},"1":{"120":1,"121":1,"122":1,"123":1,"124":1,"125":1}}],["赋值",{"2":{"118":1,"135":1}}],["里面放实参列表",{"2":{"117":1}}],["点运算符分成两种情况",{"2":{"268":1}}],["点运算符获取类对象的一个成员",{"2":{"268":1}}],["点运算符和箭头运算符都可以用于访问成员",{"2":{"268":1}}],["点运算符只能用于类类型的对象",{"2":{"117":1}}],["点运算符",{"2":{"117":1}}],["头文件numeric中定义了一组数值泛型算法",{"2":{"185":1}}],["头文件根据类名来命名",{"2":{"116":1}}],["头文件通常包含那些只能被定义一次的实体",{"2":{"86":1}}],["习惯上",{"2":{"116":1}}],["语法格式是",{"2":{"284":1}}],["语法上需要一条语句",{"2":{"278":1}}],["语法上需要一条语句但是逻辑上不需要",{"2":{"278":1}}],["语法大致如此",{"2":{"115":1}}],["语句作用域",{"0":{"279":1}}],["语句一次只引入命名空间的一个成员",{"2":{"211":1}}],["语句一般是顺序执行的",{"2":{"111":1}}],["语句块也是语句的一种",{"2":{"112":1}}],["语句块的第一条语句首先执行",{"2":{"111":1}}],["语句",{"0":{"277":1},"1":{"278":1,"279":1,"280":1,"281":1,"282":1,"283":1,"284":1,"285":1,"286":1,"287":1,"288":1,"289":1,"290":1,"291":1,"292":1,"293":1,"294":1,"295":1},"2":{"0":1,"92":1}}],["退出循环",{"2":{"113":1}}],["若提供的初始值少于数组大小时",{"2":{"254":1}}],["若失败",{"2":{"113":1}}],["若要改变str中的字符",{"2":{"92":1}}],["循环头控制循环体的执行次数",{"2":{"113":1}}],["循环头和循环体",{"2":{"113":1}}],["控制内存分配",{"0":{"221":1},"1":{"222":1,"223":1}}],["控制权的转移有两个重要的含义",{"2":{"206":1}}],["控制实例化",{"0":{"170":1}}],["控制布尔值的格式",{"2":{"161":1}}],["控制流",{"0":{"111":1},"1":{"112":1,"113":1,"114":1,"115":1}}],["控制变量将得到数组类型",{"2":{"105":1}}],["结束",{"2":{"292":1}}],["结束的",{"2":{"110":1}}],["结合律",{"2":{"263":1}}],["结合律的信息",{"2":{"262":1}}],["结果得1",{"2":{"271":1}}],["结果只有当variable本身就是一个引用时才是引用",{"2":{"83":1}}],["结果是一个左值",{"2":{"268":1}}],["结果是引用",{"2":{"83":1}}],["结果是未定义的",{"2":{"64":1}}],["结果是初始值对无符号类型表示数值总数取模后的余数",{"2":{"64":1}}],["结果值将仅保留浮点数中小数点之前的部分",{"2":{"64":1}}],["界定符对形式的注释是以",{"2":{"110":1}}],["输入迭代器",{"2":{"199":1}}],["输入范围",{"2":{"186":1}}],["输入失败",{"2":{"138":1}}],["输入和输出运算符",{"0":{"136":1},"1":{"137":1,"138":1}}],["输入ctrl+d",{"2":{"114":1}}],["输入运算符从一个输入流读取字符",{"2":{"156":1}}],["输入运算符必须处理输入可能失败的情况",{"2":{"138":1}}],["输入运算符的第一个形参是运算符将要读取的流的引用",{"2":{"138":1}}],["输入运算符返回其左侧运算对象作为计算结果",{"2":{"109":1}}],["输入运算符",{"2":{"109":1}}],["输出迭代器",{"2":{"199":1}}],["输出操作",{"0":{"162":1}}],["输出",{"2":{"161":2}}],["输出运算符不应该打印换行符",{"2":{"137":1}}],["输出运算符应该主要负责打印对象的内容而非控制格式",{"2":{"137":1}}],["输出运算符的第一个形参是一个非常量ostream对象的引用",{"2":{"137":1}}],["输出42",{"2":{"73":1}}],["输出文件流未关联到任何文件",{"2":{"7":1}}],["输出缓冲区不会刷新",{"2":{"5":1}}],["前者称为嵌套类",{"2":{"232":1}}],["前四个可能会抛出bad",{"2":{"222":1}}],["前向迭代器",{"2":{"199":1}}],["前两个表示第一个序列中的元素的范围",{"2":{"187":1}}],["前置版本将对象本身作为左值返回",{"2":{"267":1}}],["前置版本首先将运算对象加1",{"2":{"267":1}}],["前置版本和后置版本",{"2":{"267":1}}],["前置声明一个在命名空间中的类",{"2":{"247":1}}],["前置声明",{"2":{"167":2}}],["前置运算符",{"2":{"143":1}}],["前导0表示八进制",{"2":{"161":1}}],["前导0x表示十六进制",{"2":{"161":1}}],["前缀std",{"2":{"109":1}}],["前面的小于后面的",{"2":{"99":1}}],["计算结果是左侧的ostream对象",{"2":{"109":1}}],["计数器初始化为1",{"2":{"128":1}}],["计数器就会递减",{"2":{"52":1}}],["计数器都会递增",{"2":{"52":1}}],["告诉编译器采用捕获引用方式",{"2":{"193":1}}],["告诉编译器我们想要使用iostream库",{"2":{"109":1}}],["告诉系统这个文件是一个c++程序",{"2":{"108":1}}],["写容器元素的算法",{"0":{"188":1}}],["写入",{"2":{"161":1}}],["写入endl的效果是结束当前行",{"2":{"109":1}}],["写到cerr的数据是不缓冲的",{"2":{"109":1}}],["写到clog的数据是被缓冲的",{"2":{"109":1}}],["写操作在文件末尾进行",{"2":{"8":1}}],["系统通常将程序所运行的窗口与这些对象关联起来",{"2":{"109":1}}],["名为item1的对象的isbn成员",{"2":{"117":1}}],["名为cerr和clog",{"2":{"109":1}}],["名字冲突与继承",{"2":{"304":1}}],["名字查找与类的作用域",{"0":{"250":1}}],["名字",{"2":{"194":1}}],["名字由一个波浪号接类名构成",{"2":{"122":1}}],["名字main定义于所有花括号之外",{"2":{"70":1}}],["名字的有效区域始于名字的声明语句",{"2":{"70":1}}],["名字的作用域",{"0":{"70":1}}],["名字的作用域是程序文本的一部分",{"2":{"27":1}}],["名字在其中可见",{"2":{"27":1}}],["名字有作用域",{"2":{"27":1}}],["初识泛型算法",{"0":{"186":1},"1":{"187":1,"188":1,"189":1}}],["初识成员函数",{"0":{"117":1}}],["初识输入输出",{"0":{"109":1}}],["初始化过程中",{"2":{"273":1}}],["初始化cval成员",{"2":{"233":1}}],["初始化的元素",{"2":{"94":1}}],["初始化的含义是创建变量时赋予一个初始值",{"2":{"67":1}}],["初始化一个变量",{"2":{"90":1,"109":1}}],["初始化为由n个字符c组成的串",{"2":{"90":1}}],["初始化string对象的方式",{"2":{"90":1}}],["初始化和对const的引用",{"2":{"76":1}}],["初始化不是赋值",{"2":{"67":1}}],["初始化动态分配对象的数组",{"2":{"59":1}}],["初始值转换成变量的类型",{"2":{"273":1}}],["初始值列表都可以为空",{"2":{"266":1}}],["初始值列表只是做了初始化的工作",{"2":{"252":1}}],["初始值是double型对象的地址",{"2":{"73":1}}],["初始值",{"2":{"67":1}}],["初始值为true则结果为1",{"2":{"64":1}}],["初始值为false则结果为0",{"2":{"64":1}}],["初始值为0则结果为false",{"2":{"64":1}}],["初始值被拷贝给变量",{"2":{"31":1}}],["运行时类型识别",{"0":{"224":1},"1":{"225":1,"226":1,"227":1},"2":{"224":1}}],["运行程序",{"0":{"108":1}}],["运算对象可以是带符号的",{"2":{"270":1}}],["运算对象绑定到隐式的this指针上",{"2":{"135":1}}],["运算的结果是左值",{"2":{"269":1}}],["运算结果为右侧运算对象指定的成员",{"2":{"117":1}}],["运算符的内置含义是对其运算对象执行基于二进制位的移动操作",{"2":{"270":1}}],["运算符的优先级和结合律都是无法改变的",{"2":{"261":1}}],["运算符作用于指向成员函数的指针",{"2":{"230":1}}],["运算符前包含头文件",{"2":{"226":1}}],["运算符将使用指针或引用所绑定对象的动态类型",{"2":{"224":1}}],["运算符来实现排序",{"2":{"189":1}}],["运算符来比较两个关键字",{"2":{"16":1}}],["运算符",{"2":{"180":1,"264":2,"270":1}}],["运算符==中的参数所需要的",{"2":{"167":1}}],["运算符接受两个运算对象",{"2":{"109":1}}],["还定义了一个名为assign的成员",{"2":{"315":1}}],["还定义了这类数据上可以进行的运算",{"2":{"107":1}}],["还负责销毁派生类的直接基类",{"2":{"307":1}}],["还有一些操作只适用于一小部分容器",{"2":{"312":1}}],["还有一些概念比较简单",{"2":{"266":1}}],["还有一种情况也应该使用while循环",{"2":{"284":1}}],["还有更多的讨论见书本",{"2":{"212":1}}],["还支持递减",{"2":{"200":1}}],["还要创建一个引用计数",{"2":{"128":1}}],["还可以在模板中定义非类型参数",{"2":{"166":1}}],["还可以用new返回的指针来初始化智能指针",{"2":{"54":1}}],["还可能做一些其他工作",{"2":{"122":1}}],["非顺序访问容器中元素的代价",{"2":{"311":1}}],["非静态",{"2":{"299":1}}],["非布尔值转换成布尔类型",{"2":{"273":1}}],["非可变参数版本的声明必须在作用域中",{"2":{"181":1}}],["非类型参数被一个用户提供的或编译器推断出的值所代替",{"2":{"166":1}}],["非常量的地址转换成const的地址",{"2":{"275":1}}],["非常量",{"2":{"138":1}}],["非0的返回值的含义由系统定义",{"2":{"107":1}}],["非法",{"2":{"101":1}}],["学习一门新的程序设计语言的最好方法就是练习编写程序",{"2":{"106":1}}],["故不做更多笔记",{"2":{"281":1,"282":1,"285":1}}],["故不能存储引用",{"2":{"93":1}}],["故而不做更多笔记",{"2":{"265":1}}],["故此成员函数内",{"2":{"238":1}}],["故使用多维数组名将得到一个指向内层数组的指针",{"2":{"105":1}}],["常常会引入非随机性",{"2":{"158":1}}],["常把第一个维度看作行",{"2":{"105":1}}],["常量整数值0或者字面值nullptr能转换成任意指针类型",{"2":{"275":1}}],["常量和auto",{"2":{"82":1}}],["常量表达式意味着在编译期间就能得到计算",{"2":{"271":1}}],["常量表达式",{"2":{"79":1}}],["常量引用仅对引用可参与的操作做出了限定",{"2":{"76":1}}],["下标操作和安全的随机访问",{"2":{"320":1}}],["下标运算符返回常量引用以确保我们不会给返回的对象赋值",{"2":{"142":1}}],["下标运算符通常以所访问元素的引用作为返回值",{"2":{"142":1}}],["下标运算符",{"0":{"142":1}}],["下标",{"2":{"135":1,"327":1}}],["下标和指针",{"2":{"103":1}}],["下面的准则有助于选择将运算符定义为成员函数还是普通的非成员函数",{"2":{"135":1}}],["下面是一个简单的main函数",{"2":{"107":1}}],["下面得到一个整型指针",{"2":{"103":1}}],["下面得到一个数组类型",{"2":{"103":1}}],["访问操作的结果是未定义的",{"2":{"320":1}}],["访问",{"2":{"318":1}}],["访问控制与继承",{"0":{"303":1},"2":{"298":1}}],["访问控制与封装",{"0":{"242":1},"1":{"243":1}}],["访问说明符",{"2":{"242":1}}],["访问tuple的成员",{"2":{"153":1}}],["访问数组元素",{"0":{"102":1}}],["访问元素",{"0":{"23":1,"320":1}}],["应当为private的",{"2":{"242":1}}],["应当是public的",{"2":{"242":1}}],["应当对内置类型的数据成员提供类内初始值",{"2":{"240":1}}],["应用程序可以在全局作用域定义operator",{"2":{"222":1}}],["应用程序需要重载new运算符和delete运算符以控制内存分配的过程",{"2":{"221":1}}],["应在捕获列表中写一个",{"2":{"193":1}}],["应使用关键字template后跟一个空尖括号对",{"2":{"183":1}}],["应该不会很难懂",{"2":{"268":1}}],["应该令函数的行为尽量模仿这个运算符",{"2":{"238":1}}],["应该把函数声明成const版本的",{"2":{"238":1}}],["应该避免捕获指针或引用",{"2":{"193":1}}],["应该将其",{"2":{"159":1}}],["应该由内向外理解",{"2":{"101":1}}],["应属下列4种状态之一",{"2":{"73":1}}],["维度由编译器推断出来",{"2":{"101":1}}],["维度是类型的一部分",{"2":{"34":1}}],["得到",{"2":{"103":1}}],["得到迭代器之间的距离",{"2":{"99":1}}],["得到指针p所指的对象",{"2":{"73":1}}],["认定某个类型是迭代器类型当且仅当它支持一套操作",{"2":{"98":1}}],["反正这种类似写法的运算不会成为问题",{"2":{"263":1}}],["反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器",{"2":{"198":1}}],["反向迭代器",{"0":{"198":1},"2":{"195":1}}],["反之则不行",{"2":{"303":1}}],["反之",{"2":{"233":1,"268":1,"303":1}}],["反之亦然",{"2":{"123":1,"126":2,"205":1}}],["反之不相等",{"2":{"98":1}}],["反斜线",{"2":{"65":1}}],["尾置返回允许我们在参数列表之后声明返回类型",{"2":{"174":1}}],["尾置返回类型与类型转换",{"0":{"174":1}}],["尾置返回类型跟在形参列表后面并以一个",{"2":{"40":1}}],["尾后指针不能解引用和递增操作",{"2":{"103":1}}],["尾元素的下一个位置",{"2":{"98":1}}],["执行该函数将导致程序非正常退出",{"2":{"294":1}}],["执行与之对应的块",{"2":{"294":1}}],["执行写操作就会产生未定义的后果",{"2":{"276":1}}],["执行输入和输出操作",{"2":{"136":1}}],["执行循环体",{"2":{"113":1}}],["执行类默认初始化",{"2":{"94":1}}],["执行浮点数运算选用double",{"2":{"63":1}}],["索引用于访问对象",{"2":{"93":1}}],["集合中的每个对象都有一个索引",{"2":{"93":1}}],["集合中的函数成为候选函数",{"2":{"47":1}}],["越界的结果是ub",{"2":{"92":1}}],["范围是",{"2":{"92":1}}],["范围for语句",{"0":{"286":1},"2":{"286":1}}],["范围for",{"2":{"92":1}}],["符号位",{"2":{"270":1}}],["符号叫做下标运算符",{"2":{"92":1}}],["符号开头",{"2":{"40":1}}],["每当类对象被创建",{"2":{"240":1}}],["每次调用sum时调用者都必须为t1提供一个显式模板实参",{"2":{"173":1}}],["每次调用函数都会生成相同的序列",{"2":{"159":1}}],["每次运行程序它都会返回相同的数值序列",{"2":{"159":1}}],["每次迭代都会重新定义循环控制变量",{"2":{"286":1}}],["每次迭代时创建并初始化",{"2":{"279":1}}],["每次迭代",{"2":{"92":1}}],["每个容器都支持相等运算符",{"2":{"317":1}}],["每个容器都支持这些大小相关的操作",{"2":{"316":1}}],["每个容器类型都定义了一个默认构造函数",{"2":{"314":1}}],["每个枚举类型定义了一种新的类型",{"2":{"228":1}}],["每个基类分别使用自己的对应成员隐式地完成构造",{"2":{"215":1}}],["每个blob实例将访问权限授予相同类型实例化的blobptr和相等运算符",{"2":{"167":1}}],["每个iostream对象还维护一个格式状态来控制io如何格式化的细节",{"2":{"161":1}}],["每个随机数的范围在0和一个系统相关的最大值",{"2":{"158":1}}],["每个类定义自己的作用域",{"2":{"304":1}}],["每个类还分别控制着其成员对于派生类来说是否可访问",{"2":{"303":1}}],["每个类分别控制自己的成员初始化过程",{"2":{"303":1}}],["每个类分别定义了一个执行命名操作的调用运算符",{"2":{"147":1}}],["每个类控制它自己的成员初始化过程",{"2":{"299":1}}],["每个类是一个唯一的类型",{"2":{"247":1}}],["每个类各自决定其初始化对象的方式",{"2":{"67":1}}],["每个构造函数",{"2":{"128":1}}],["每个对象都应该拥有一份自己的拷贝",{"2":{"127":1}}],["每个对象都有自己的一份数据成员拷贝",{"2":{"85":1}}],["每个成员的类型决定了它如何拷贝",{"2":{"120":1}}],["每个for语句都包含两部分",{"2":{"113":1}}],["每个使用标准库设施的程序都必须包含相关的头文件",{"2":{"109":1}}],["每个c++程序都包含一个或多个函数",{"2":{"107":1}}],["每个元素都会移动到新的存储空间中",{"2":{"311":1}}],["每个元素又是一个含有4个元素的数组",{"2":{"105":1}}],["每个元素的值都是val",{"2":{"94":1}}],["每个元素只包含一个关键字",{"2":{"12":1}}],["每个变量的前面都必须有符号",{"2":{"73":1}}],["每个字面值常量都对应一种数据类型",{"2":{"65":1}}],["每个shared",{"2":{"52":1}}],["每个程序还拥有一个内存池",{"2":{"50":1}}],["每个实参的类型与对应的形参类型相同",{"2":{"47":1}}],["每个函数都有一个const",{"2":{"34":1}}],["每个文件中就会有该模板的一个实例",{"2":{"170":1}}],["每个文件可被独立编译",{"2":{"68":1}}],["每个文件独立编译",{"2":{"29":1}}],["每个文件流类型都定义了一个默认的文件模式",{"2":{"8":1}}],["每个文件流类都定义了一个名为open的成员函数",{"2":{"7":1}}],["每个关键字关联的类型",{"2":{"18":1}}],["每个流都有一个关联的文件模式",{"2":{"8":1}}],["每个输出流都管理一个缓冲区",{"2":{"5":1}}],["目前最好的办法是使用c++11新标准提供的一种语句",{"2":{"92":1}}],["顺序比较字符大小",{"2":{"91":1}}],["顺序容器和关联容器的不同之处在于两者组织元素的方式",{"2":{"318":1}}],["顺序容器操作",{"0":{"318":1},"1":{"319":1,"320":1,"321":1,"322":1,"323":1}}],["顺序容器有",{"2":{"311":1}}],["顺序容器概览",{"0":{"311":1}}],["顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的",{"2":{"12":1}}],["顺序容器",{"0":{"310":1},"1":{"311":1,"312":1,"313":1,"314":1,"315":1,"316":1,"317":1,"318":1,"319":1,"320":1,"321":1,"322":1,"323":1,"324":1,"325":1,"326":1,"327":1,"328":1,"329":1},"2":{"0":1,"315":1}}],["后者又运行quote的默认构造函数",{"2":{"307":1}}],["后四个则不会",{"2":{"222":1}}],["后面紧跟以逗号分隔的基类列表",{"2":{"297":1}}],["后面是关键字namespace以及命名空间的名字",{"2":{"211":1}}],["后面的语句将不再被执行",{"2":{"206":1}}],["后跟模板参数列表",{"2":{"167":1}}],["后续章节的内容将要对其进行改造使其成为一个抽象数据类型",{"2":{"237":1}}],["后续打印bool值的操作都会打印true或false",{"2":{"161":1}}],["后续内容讨论了其他随机数的分布",{"2":{"159":1}}],["后置版本则将对象原始值的副本作为右值返回",{"2":{"267":1}}],["后置版本也会将对象加1",{"2":{"267":1}}],["后置版本接受一个额外的",{"2":{"143":1}}],["后置运算符应该返回对象的原值",{"2":{"143":1}}],["后置运算符",{"2":{"143":1}}],["后",{"2":{"88":1}}],["确保用户代码不会无意间破坏封装对象的状态",{"2":{"243":1}}],["确保头文件多次包含仍能安全工作的常用技术是预处理器",{"2":{"86":1}}],["确定使用哪种容器",{"2":{"311":1}}],["确定变量的用途",{"2":{"110":1}}],["确定一个流对象的状态的最简单的方法是将它当作一个条件来使用",{"2":{"4":1}}],["编号到31结束的二进制位被称为高位",{"2":{"155":1}}],["编号从0开始的二进制位被称为低位",{"2":{"155":1}}],["编译",{"0":{"108":1}}],["编译器都在派生类中生成一个形参列表完全相同的构造函数",{"2":{"309":1}}],["编译器都会自动地将其替换为一个指向数组首元素的指针",{"2":{"103":1}}],["编译器产生的代码直到运行时才能确定应该调用哪个版本的函数",{"2":{"301":1}}],["编译器创建一个值初始化的临时量并将其赋给左侧运算对象",{"2":{"266":1}}],["编译器处理完类的全部声明后",{"2":{"250":1}}],["编译器无法生成默认构造函数",{"2":{"240":1}}],["编译器无法推断t1",{"2":{"173":1}}],["编译器无法推断出模板实参的类型",{"2":{"173":1}}],["编译器检查其调用的方式与处理普通c++函数的方式相同",{"2":{"236":1}}],["编译器在全局作用域查找",{"2":{"222":1}}],["编译器在每个字符串的结尾处添加一个空字符",{"2":{"65":1}}],["编译器调用名为operator",{"2":{"222":1}}],["编译器运行相应的构造函数以构造这些对象",{"2":{"222":1}}],["编译器并不会在编译时检查noexcept说明",{"2":{"208":1}}],["编译器确认函数不会抛出异常",{"2":{"208":1}}],["编译器生成一个与lambda对应的新的",{"2":{"193":1}}],["编译器还会推断包中参数的数目",{"2":{"180":1}}],["编译器从函数的实参推断模板参数类型",{"2":{"180":1}}],["编译器推断t为一个左值引用类型",{"2":{"176":1}}],["编译器推断t的类型为int",{"2":{"176":1}}],["编译器推断模板类型参数为实参左值引用类型",{"2":{"176":1}}],["编译器推断出模板实参为int",{"2":{"166":1}}],["编译器推断出来的auto类型有时候和初始值的类型并不完全一样",{"2":{"82":1}}],["编译器通常不是对实参进行类型转换",{"2":{"172":1}}],["编译器通常需要掌握函数模板或类模板成员函数的定义",{"2":{"166":1}}],["编译器利用调用中的函数实参来确定其模板参数",{"2":{"171":1}}],["编译器必须知道名字是否表示一个类型",{"2":{"168":1}}],["编译器必须确定一个能和指针类型精确匹配的函数",{"2":{"49":1}}],["编译器不检查越界错误",{"2":{"320":1}}],["编译器不能为类模板推断模版参数类型",{"2":{"167":1}}],["编译器不会自动执行这一类型转换",{"2":{"150":1}}],["编译器只需要掌握函数的声明",{"2":{"166":1}}],["编译器才生成代码",{"2":{"166":1}}],["编译器才会对表达式求值",{"2":{"226":1}}],["编译器才会生成代码",{"2":{"166":1}}],["编译器才会为它合成移动构造函数或移动赋值运算符",{"2":{"132":1}}],["编译器遇到模板定义时",{"2":{"166":1}}],["编译器用推断出的模板参数实例化",{"2":{"166":1}}],["编译器使用异常抛出表达式来对异常对象进行拷贝初始化",{"2":{"206":1}}],["编译器使用指针的类型来推断模板实参",{"2":{"175":1}}],["编译器使用函数调用中的实参类型来寻找模板实参",{"2":{"171":1}}],["编译器使用这些模板实参来实例化出特定的类",{"2":{"167":1}}],["编译器使用实参的类型来确定绑定到模板参数t的类型",{"2":{"166":1}}],["编译器使用普通的函数匹配规则来确定使用哪个构造函数",{"2":{"132":1}}],["编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员",{"2":{"146":1}}],["编译器可以选择忽略这个请求",{"2":{"45":1}}],["编译器就会合成一个",{"2":{"241":1}}],["编译器就会自动生成一个",{"2":{"240":1}}],["编译器就会把它当成一个表达式",{"2":{"83":1}}],["编译器就自动为该union创建一个未命名的对象",{"2":{"233":1}}],["编译器就不会为它合成移动构造函数和移动赋值运算符了",{"2":{"132":1}}],["编译器把等号右侧的对象初始值拷贝到新创建的对象中去",{"2":{"90":1}}],["编译器分析表达式并得到它的类型",{"2":{"83":1}}],["编译器允许赋予这些类型更大的尺寸",{"2":{"63":1}}],["编译器将认为新定义的这个函数与基类中原有的函数是相互独立的",{"2":{"301":1}}],["编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员",{"2":{"233":1}}],["编译器将使用我们自定义的版本替换标准库定义的版本",{"2":{"222":1}}],["编译器将调用terminate",{"2":{"207":1}}],["编译器将它应用到模板参数包args中的每个元素",{"2":{"182":1}}],["编译器将该表达式翻译成一个未命名类的未命名对象",{"2":{"146":1}}],["编译器将不允许定义该类型的变量或创建该类型的临时对象",{"2":{"125":1}}],["编译器将实参类型到形参类型的转换划分成几个等级",{"2":{"48":1}}],["编译器将报告无匹配函数的错误",{"2":{"47":1}}],["编译器找到一个与实参",{"2":{"41":1}}],["编译器首先将调用的实参与重载集合中的每一个函数的形参进行比较",{"2":{"41":1}}],["编译器会自动地转换运算对象的类型",{"2":{"273":1}}],["编译器会自动为它定义缺失的操作",{"2":{"118":1}}],["编译器会应用正常的引用绑定规则",{"2":{"176":1}}],["编译器会用函数实参推断出模板实参",{"2":{"166":1}}],["编译器会把模板转换成特定的类或者函数",{"2":{"164":1}}],["编译器会把一些合成的成员定义为删除的函数",{"2":{"125":1}}],["编译器会为它合成一个",{"2":{"121":1}}],["编译器会为我们定义一个",{"2":{"120":1}}],["编译器会忽略掉注释",{"2":{"110":1}}],["编译器会认为外层控制变量是指针类型",{"2":{"105":1}}],["编译器会适当地改变结果类型使其更符合初始化规则",{"2":{"82":1}}],["编译器会优先选用非常量版本的函数",{"2":{"41":1}}],["编译器会根据传递的实参类型推断想要的是哪个函数",{"2":{"41":1}}],["编译器负责验证函数的定义和声明是否匹配",{"2":{"28":1}}],["编写异常安全的代码非常困难",{"2":{"292":1}}],["编写如下命名空间定义",{"2":{"210":1}}],["编写可变参数函数模板",{"0":{"181":1}}],["编写好程序后",{"2":{"108":1}}],["编写一个简单的c++程序",{"0":{"107":1},"1":{"108":1}}],["编写自己的头文件",{"0":{"86":1}}],["紧跟着类名和类体",{"2":{"85":1}}],["自定义数据结构",{"0":{"84":1},"1":{"85":1,"86":1}}],["自动执行默认构造函数",{"2":{"254":1}}],["自动用delete",{"2":{"59":1}}],["自动对象",{"2":{"27":1}}],["切记",{"2":{"83":1}}],["切勿混用带符号类型和无符号类型",{"2":{"64":1}}],["yellow",{"2":{"228":1}}],["yang",{"2":{"216":6}}],["ying",{"2":{"216":6}}],["y绑定到x",{"2":{"83":1}}],["y的类型是const",{"2":{"83":1}}],["y",{"2":{"83":1,"294":1}}],["却不实际计算表达式的值",{"2":{"83":1}}],["绑定到zooanimal",{"2":{"216":1}}],["绑定到endangered",{"2":{"216":1}}],["绑定到bear",{"2":{"216":1}}],["绑定到左值和const右值",{"2":{"176":1}}],["绑定到非const右值",{"2":{"176":1}}],["绑定到任意类型的x",{"2":{"133":1}}],["绑定到cin",{"2":{"163":1}}],["绑定到ci",{"2":{"82":1}}],["绑定到一个普通int对象上",{"2":{"76":1}}],["真正参与初始化的其实是引用对象的值",{"2":{"82":1}}],["真正传递的是指向数组首元素的指针",{"2":{"34":1}}],["显示模板实参在尖括号中给出",{"2":{"173":1}}],["显示传递一个表示数组大小的形参",{"2":{"34":1}}],["显式转换",{"0":{"276":1}}],["显式地进行强制类型转换包含两种形式",{"2":{"276":1}}],["显式地初始化所有基类",{"2":{"215":1}}],["显式地请求类型转换",{"2":{"150":1}}],["显式的析构函数调用",{"2":{"223":1}}],["显式的实例化定义会实例化所有成员",{"2":{"170":1}}],["显式的类型转换运算符",{"2":{"150":1}}],["显式初始化数组元素",{"2":{"101":1}}],["显然",{"2":{"82":1}}],["拼写",{"2":{"80":1}}],["随机访问迭代器",{"2":{"199":1}}],["随机数发生器有一个特性经常会使新手迷惑",{"2":{"159":1}}],["随机数引擎是函数对象类",{"2":{"159":1}}],["随机数引擎和分布",{"0":{"159":1}}],["随机数引擎",{"2":{"158":1}}],["随机数",{"0":{"158":1},"1":{"159":1}}],["随即用临时string对象来初始化bitset",{"2":{"156":1}}],["随着程序越来越复杂",{"2":{"80":1}}],["随后是命名空间的名字",{"2":{"210":1}}],["随后重新抛出异常",{"2":{"207":1}}],["随后紧跟由一个或多个变量名组成的列表",{"2":{"67":1}}],["随后再打印",{"2":{"5":1}}],["叫做合成的默认构造函数",{"2":{"240":1}}],["叫尾后迭代器",{"2":{"98":1}}],["叫字面值类型",{"2":{"79":1}}],["叫常量指针",{"2":{"77":1}}],["才可以使用关系运算符比较两个容器",{"2":{"317":1}}],["才可对其解引用",{"2":{"98":1}}],["才会讲解",{"2":{"276":1}}],["才会处理成员函数的定义",{"2":{"250":1}}],["才会自动对基类部分执行这些操作",{"2":{"215":1}}],["才能访问其成员",{"2":{"247":1}}],["才能执行确切的删除动作",{"2":{"203":1}}],["才提供成员所属的对象",{"2":{"229":1}}],["才是一条正确的声明语句",{"2":{"79":1}}],["才把形参定义成指向非常量的指针",{"2":{"34":1}}],["+的返回类型是t",{"2":{"178":1}}],["+=",{"2":{"113":1,"135":1,"139":1,"141":2}}],["+",{"2":{"79":2,"82":1,"83":1,"91":3,"99":1,"103":2,"109":1,"135":1,"150":3,"273":1,"278":1}}],["++i",{"2":{"263":1}}],["++iter",{"2":{"98":1,"263":1}}],["++v1",{"2":{"193":1}}],["++val",{"2":{"113":1}}],["++b",{"2":{"178":1}}],["++ctr",{"2":{"27":1}}],["++map",{"2":{"19":1}}],["靠左的是底层const",{"2":{"78":1}}],["靠右的const是顶层const",{"2":{"78":1}}],["底层const则与指针和引用等复合类型的基本类型部分有关",{"2":{"78":1}}],["底层const",{"2":{"78":1}}],["顶层const会被忽略",{"2":{"226":1}}],["顶层const和引用丢失了",{"2":{"178":1}}],["顶层const无论是在形参中还是在实参中",{"2":{"172":1}}],["顶层const可以表示任意的对象是常量",{"2":{"78":1}}],["顶层const",{"0":{"78":1},"2":{"78":1}}],["顶层const不影响传入函数的对象",{"2":{"41":1}}],["想要存放常量对象的地址",{"2":{"77":1}}],["称之为重载运算符",{"2":{"261":1}}],["称之为对常量的引用",{"2":{"76":1}}],["称为二义性调用",{"2":{"41":1}}],["任何非常量对象的地址都能存入void",{"2":{"276":1}}],["任何具有明确定义的类型转换",{"2":{"276":1}}],["任何算法的最基本的特性是它要求其迭代器提供哪些操作",{"2":{"199":1}}],["任何额外的参数都必须有默认实参",{"2":{"132":1}}],["任何一种可能改变vector对象容量的操作",{"2":{"98":1}}],["任何试图为bufsize赋值的行为都将引发错误",{"2":{"75":1}}],["任何函数的定义都能使用尾置返回",{"2":{"40":1}}],["从下标",{"2":{"325":2}}],["从基类继承而来的旧定义",{"2":{"298":1}}],["从它的几个基类中分别继承名字相同的成员是完全合法的",{"2":{"217":1}}],["从base2继承构造函数",{"2":{"215":1}}],["从base1继承构造函数",{"2":{"215":1}}],["从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员",{"2":{"193":1}}],["从左值引用函数参数推断类型",{"2":{"176":1}}],["从函数实参来确定模板实参的过程被称为模板实参推断",{"2":{"171":1}}],["从逻辑上讲",{"2":{"163":1}}],["从istream",{"2":{"162":1}}],["从cin读取最多16个0或1",{"2":{"156":1}}],["从一个右值移动数据",{"2":{"177":1}}],["从一个string初始化bitset",{"2":{"155":1}}],["从一个对象移动数据并不会销毁此对象",{"2":{"132":1}}],["从一个返回类型为非引用类型的函数返回一个对象",{"2":{"120":1}}],["从花括号列表初始化一个数组中的元素或一个聚合类中的成员",{"2":{"120":1}}],["从流读取数据",{"2":{"109":1}}],["从输入流中读取一行赋值给s",{"2":{"91":1}}],["从输入流中读取字符串赋值给s",{"2":{"91":1}}],["从最基本的层面理解",{"2":{"84":1}}],["从右向左阅读有助于弄清楚它的真实含义",{"2":{"74":1}}],["从而导致无限递归",{"2":{"301":1}}],["从而确保后面所有case标签都在变量的作用域之外",{"2":{"282":1}}],["从而方便它们直接操作成员变量",{"2":{"239":1}}],["从而函数参数间接实例化成一个引用的引用",{"2":{"176":1}}],["从而允许编译器在编译时实例化模板",{"2":{"166":1}}],["从而使其它文件也使用了using声明",{"2":{"88":1}}],["从而关闭调试状态",{"2":{"46":1}}],["从而编译器不知道该调用哪一个",{"2":{"33":1}}],["从而作为结果传出",{"2":{"32":1}}],["面对一条比较复杂的指针或引用的声明语句时",{"2":{"74":1}}],["面向对象程序设计",{"0":{"296":1},"1":{"297":1,"298":1,"299":1,"300":1,"301":1,"302":1,"303":1,"304":1,"305":1,"306":1,"307":1,"308":1,"309":1},"2":{"0":1,"297":1}}],["理解算法的最基本的方法就是了解它们是否读取元素",{"2":{"186":1}}],["理解std",{"0":{"177":1}}],["理解复合类型的声明",{"0":{"74":1}}],["理解这两个概念非常重要",{"2":{"27":1}}],["作为代价",{"2":{"311":1}}],["作为接口",{"2":{"242":1}}],["作为成员的二元运算符",{"2":{"141":1}}],["作为函数的输入或输出",{"2":{"73":1}}],["作用于两个运算对象的运算符是二元运算符",{"2":{"261":1}}],["作用于一个运算对象的运算符是一元运算符",{"2":{"261":1}}],["作用于常量引用",{"2":{"41":1}}],["作用域运算符将覆盖掉原有的查找规则",{"2":{"304":1}}],["作用域中一旦声明了某个名字",{"2":{"70":1}}],["作用域能彼此包含",{"2":{"70":1}}],["作用域",{"2":{"70":1}}],["利用void",{"2":{"73":1}}],["利用指针访问对象",{"2":{"73":1}}],["意味着当优先级相同时",{"2":{"264":1}}],["意味着这些函数",{"2":{"246":1}}],["意味着它们有两个参数",{"2":{"191":1}}],["意味着它们只接受单一参数",{"2":{"191":1}}],["意味着它应该有自己的状态",{"2":{"126":1}}],["意味着拷贝一个对象时",{"2":{"126":1}}],["意味着该表达式的结果对象能作为一条赋值语句的左值",{"2":{"83":1}}],["意味着指针没有指向任何对象",{"2":{"73":1}}],["意味着我们可以对函数的调用结果执行解引用操作",{"2":{"40":1}}],["操作的含义会颠倒过来",{"2":{"198":1}}],["操作两个序列的算法",{"2":{"187":1}}],["操作",{"0":{"324":1},"1":{"325":1,"326":1,"327":1,"328":1,"329":1},"2":{"162":1,"163":1,"227":1,"325":1,"326":1}}],["操作系统通过调用main来运行c++程序",{"2":{"107":1}}],["操作符",{"2":{"73":2}}],["操作重载与类型转换",{"0":{"134":1},"1":{"135":1,"136":1,"137":1,"138":1,"139":1,"140":1,"141":1,"142":1,"143":1,"144":1,"145":1,"146":1,"147":1,"148":1,"149":1,"150":1},"2":{"0":1}}],["需要用到异常处理",{"2":{"292":1}}],["需要用引用",{"2":{"92":1}}],["需要转换成同一种类型",{"2":{"273":1}}],["需要使用域运算符",{"2":{"249":1}}],["需要使用取地址符",{"2":{"73":1}}],["需要通过访问限定符来访问",{"2":{"232":1}}],["需要声明它包含多少个二进制位",{"2":{"155":1}}],["需要指出每个成员的类型",{"2":{"153":1}}],["需要拷贝操作的类也需要赋值操作",{"2":{"123":1}}],["需要析构函数的类也需要拷贝和赋值操作",{"2":{"123":1}}],["需要明确指出",{"2":{"82":1}}],["需要从程序的上下文中寻求帮助",{"2":{"80":1}}],["需要首先",{"2":{"73":1}}],["需要将其绑定到一个new返回的指针上",{"2":{"56":1}}],["相同的查找过程在所有直接基类中同时进行",{"2":{"217":1}}],["相同的实例可能出现在多个对象文件中",{"2":{"170":1}}],["相关声明",{"2":{"210":1}}],["相反",{"2":{"207":1}}],["相反的",{"2":{"72":1}}],["相互之间应该在参数数量或类型上有所区别",{"2":{"145":1}}],["相等运算符",{"0":{"140":1}}],["相等性",{"2":{"135":1}}],["相对于智能指针",{"2":{"53":1}}],["包扩展",{"0":{"182":1}}],["包中除了最后一个元素之外的其他元素都会调用这个版本的print",{"2":{"181":1}}],["包中有三个参数",{"2":{"180":1}}],["包含s中从pos开始的n个字符的拷贝",{"2":{"325":1}}],["包含",{"2":{"153":1,"159":1}}],["包含着别的作用域的作用域称为外层作用域",{"2":{"70":1}}],["包括函数在内",{"2":{"234":1}}],["包括内置的数组类型",{"2":{"184":1}}],["包括实参类型是否是const的以及实参是左值还是右值",{"2":{"178":1}}],["包括引擎和分布对象",{"2":{"159":1}}],["包括计数器",{"2":{"128":1}}],["包括赋值运算符",{"2":{"121":1}}],["包括",{"2":{"118":1}}],["包括顶层const和引用在内",{"2":{"83":1}}],["包括以下情况",{"2":{"48":1}}],["被删除元素之前的元素的迭代器仍有效",{"2":{"323":1}}],["被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个",{"2":{"301":1}}],["被调函数",{"2":{"26":1}}],["被封装的类的具体实现可以随时改变",{"2":{"243":1}}],["被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码",{"2":{"206":1}}],["被包含的作用域称为内层作用域",{"2":{"70":1}}],["同一个基类只能出现一次",{"2":{"215":1}}],["同一个名字在不同的作用域中可能指向不同的实体",{"2":{"70":1}}],["同样",{"2":{"143":1}}],["同时派生类的派生访问说明符也会有影响",{"2":{"303":1}}],["同时定义了一个新类型和该类型的一个对象",{"2":{"193":1}}],["同时创建构造函数",{"2":{"146":1}}],["同时底层const则会保留下来",{"2":{"82":1}}],["同时避免对同一变量的重复定义",{"2":{"75":1}}],["同时",{"2":{"69":1,"70":1}}],["同时也更安全",{"2":{"51":1}}],["同时一个普通的引用必须用同类型的对象初始化",{"2":{"33":1}}],["标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰",{"2":{"291":1}}],["标记的当前位置",{"2":{"163":1}}],["标准异常",{"0":{"295":1}}],["标准输入输出对象",{"2":{"109":1}}],["标准容器迭代器的运算符",{"2":{"98":1}}],["标准库提供了数值转换的函数",{"2":{"329":1}}],["标准库提供了一对函数",{"2":{"163":1}}],["标准库提供了一组低层操作",{"2":{"162":1}}],["标准库提供了一个可以管理new分配的数组的unique",{"2":{"59":1}}],["标准库在头文件iterator中还定义了额外几种迭代器",{"2":{"195":1}}],["标准库bind函数",{"2":{"194":1}}],["标准库算法使用的谓词分为两类",{"2":{"191":1}}],["标准库算法都对一个范围内的元素进行操作",{"2":{"186":1}}],["标准库为这些算法定义了额外的版本",{"2":{"190":1}}],["标准库为allocator类定义了两个伴随算法",{"2":{"60":1}}],["标准库并未给每个容器都定义成员函数来实现一些特殊的操作",{"2":{"184":1}}],["标准库move函数是使用右值引用的模板的一个很好的例子",{"2":{"177":1}}],["标准库实际上定义了两对seek和tell函数",{"2":{"163":1}}],["标准库容器提供了灵活的内存管理",{"2":{"319":1}}],["标准库容器和异常",{"2":{"132":1}}],["标准库容器都拥有名为begin和end的成员",{"2":{"98":1}}],["标准库的头文件通常不带后缀",{"2":{"116":1}}],["标准库定义的函数对象",{"0":{"147":1}}],["标准库定义的版本可能像这样",{"2":{"129":1}}],["标准库定义的所有名字都在命名空间std中",{"2":{"109":1}}],["标准库定义了operator",{"2":{"222":1}}],["标准库定义了一组操纵符来修改流的格式状态",{"2":{"161":1}}],["标准库定义了一组表示算术运算符",{"2":{"147":1}}],["标准库定义了bitset类",{"2":{"154":1}}],["标准库定义了make",{"2":{"153":1}}],["标准库定义了4个io对象",{"2":{"109":1}}],["标准库定义了这几种类型",{"2":{"2":1}}],["标准库类型使用iterator和const",{"2":{"98":1}}],["标准库类型vector",{"0":{"93":1},"1":{"94":1,"95":1,"96":1}}],["标准库类型string",{"0":{"89":1},"1":{"90":1,"91":1,"92":1}}],["标准库允许把字符字面值和字符串字面值转换成string对象",{"2":{"91":1}}],["标准库allocator类定义在头文件memory中",{"2":{"60":1}}],["标准库中包含一个名为allocator的类",{"2":{"58":1}}],["标准库还定义了一个名为weak",{"2":{"51":1}}],["标准库使用关键字类型的",{"2":{"16":1}}],["标准库特殊设施",{"0":{"151":1},"1":{"152":1,"153":1,"154":1,"155":1,"156":1,"157":1,"158":1,"159":1,"160":1,"161":1,"162":1,"163":1},"2":{"0":1}}],["标识符的长度没有限制",{"2":{"69":1}}],["标识符",{"0":{"69":1}}],["使隐式的形参变成显式的",{"2":{"231":1}}],["使我们可以将一组整型常量组织在一起",{"2":{"228":1}}],["使得begin",{"2":{"313":1}}],["使得用户可以直接访问其成员",{"2":{"256":1}}],["使得我们可以为命名空间的名字设定一个短得多的同义词",{"2":{"211":1}}],["使得我们可以保持const属性",{"2":{"178":1}}],["使得位运算的使用更为容易",{"2":{"154":1}}],["使得名字为程序所知",{"2":{"68":1}}],["使类的行为看起来像一个值或者像一个指针",{"2":{"126":1}}],["使用失效的迭代器",{"2":{"323":1}}],["使用assign",{"2":{"315":1}}],["使用allocator通常会提供更好的性能和更灵活的内存管理能力",{"2":{"58":1}}],["使用左闭合区间蕴含的编程假定",{"2":{"313":1}}],["使用vector是最好的选择",{"2":{"311":1}}],["使用它是不正确的",{"2":{"301":1}}],["使用它来初始化成员",{"2":{"240":1}}],["使用动态绑定",{"2":{"297":1}}],["使用继承",{"2":{"297":1}}],["使用while循环比较合适",{"2":{"284":1}}],["使用while循环",{"2":{"284":1}}],["使用强制类型转换获得写权限是合法的行为",{"2":{"276":1}}],["使用类的静态成员",{"2":{"258":1}}],["使用类型别名可以让复杂的名字变得简单",{"2":{"81":1}}],["使用类型别名",{"2":{"40":1}}],["使用explicit阻止这种隐式转换机制",{"2":{"255":1}}],["使用等号或者花括号",{"2":{"245":1}}],["使用typedef或using",{"2":{"245":1}}],["使用typeid运算符",{"2":{"226":1}}],["使用作用域运算符可以实现这一目的",{"2":{"301":1}}],["使用作用域运算符访问静态成员",{"2":{"258":1}}],["使用作用域运算符",{"2":{"238":1}}],["使用成员指针的类型别名",{"2":{"230":1}}],["使用下面这些方法可以构造",{"2":{"325":1}}],["使用下面这个类作为例子",{"2":{"229":1}}],["使用下标操作的返回值",{"2":{"22":1}}],["使用b引用的derived对象",{"2":{"225":1}}],["使用bp指向的base对象",{"2":{"225":1}}],["使用dp指向的derived对象",{"2":{"225":1}}],["使用rtti必须加倍小心",{"2":{"224":1}}],["使用random",{"2":{"159":2}}],["使用虚基类",{"2":{"218":1}}],["使用命名空间的成员",{"0":{"211":1}}],["使用各种库",{"2":{"204":1}}],["使用placeholders名字",{"2":{"194":1}}],["使用模板版本时",{"2":{"183":1}}],["使用function生成一个可调用对象",{"2":{"231":1}}],["使用forward",{"2":{"178":1}}],["使用find比较好",{"2":{"23":1}}],["使用相同模板参数类型的函数形参",{"2":{"172":1}}],["使用户重载删除器更为方便",{"2":{"170":1}}],["使用给定的种子值",{"2":{"159":1}}],["使用给定格式替换一个正则表达式",{"2":{"157":1}}],["使用默认种子",{"2":{"159":1}}],["使用默认实参调用函数",{"2":{"44":1}}],["使用引擎返回服从特定概率分布的随机数",{"2":{"158":1}}],["使用引用而非常量引用也会极大地限制函数所能接受的实参类型",{"2":{"33":1}}],["使用引用形参返回额外信息",{"2":{"32":1}}],["使用引用避免拷贝",{"2":{"32":1}}],["使用unsigned值初始化bitset",{"2":{"155":1}}],["使用调用运算符的方式是令一个absint对象作用于一个实参列表",{"2":{"145":1}}],["使用移动赋值",{"2":{"132":1}}],["使用移动而不是拷贝的另一个原因源于io类或unique",{"2":{"130":1}}],["使用移动而非拷贝会大幅提升性能",{"2":{"130":1}}],["使用拷贝赋值",{"2":{"132":1}}],["使用=default",{"0":{"124":1}}],["使用swap",{"2":{"315":1}}],["使用sales",{"2":{"121":1}}],["使用string类型需要包含string头文件",{"2":{"89":1}}],["使用",{"2":{"116":1,"117":1,"242":1}}],["使用这种语句来让编译器生成一个默认构造函数",{"2":{"240":1}}],["使用这样的例子解释",{"2":{"126":1}}],["使用这样的方法连续读入数据",{"2":{"114":1}}],["使用这两个运算符管理内存非常容易出错",{"2":{"53":1}}],["使用名为cout的ostream类型的对象",{"2":{"109":1}}],["使用名为cin的istream类型的对象",{"2":{"109":1}}],["使用数组初始化vector对象",{"2":{"104":1}}],["使用数组下标的时候",{"2":{"102":1}}],["使用递增运算符既可以让指向数组元素的指针向前移动到下一个位置上",{"2":{"103":1}}],["使用迭代器",{"0":{"98":1},"2":{"97":1}}],["使用基于范围的for语句",{"2":{"92":1}}],["使用别名声明",{"2":{"81":1}}],["使用到的每个名字都会指向一个特定的实体",{"2":{"70":1}}],["使用intadd",{"2":{"147":1}}],["使用int执行整数运算",{"2":{"63":1}}],["使用istringstream",{"0":{"10":1}}],["使用容器更为简单",{"2":{"58":1}}],["使用我们自己的释放操作",{"2":{"55":1}}],["使用了直接初始化形式",{"2":{"54":1}}],["使用了动态生存期的资源的类",{"2":{"52":1}}],["使用new动态分配和初始化对象",{"2":{"53":1}}],["使用尾置返回类型",{"2":{"40":1}}],["使用标准库中的名字",{"2":{"109":1}}],["使用标准库规范",{"2":{"34":1}}],["使用标记指定数组长度",{"2":{"34":1}}],["使用关键字类型的比较函数",{"2":{"16":1}}],["使用关联容器",{"0":{"13":1}}],["使用ostringstream",{"0":{"11":1}}],["使用文件流对象",{"0":{"7":1}}],["使用操纵符",{"2":{"5":1}}],["声明语句位于语句块内部",{"2":{"282":1}}],["声明静态成员",{"2":{"258":1}}],["声明一个前置类型的方法",{"2":{"247":1}}],["声明一个非c++的函数",{"2":{"236":1}}],["声明以不完全类型为参数or返回值的函数",{"2":{"247":1}}],["声明的类型决定了处理代码所能捕获的异常类型",{"2":{"207":1}}],["声明而不实例化",{"2":{"170":1}}],["声明但不定义compare和blob",{"2":{"168":1}}],["声明为constexpr的变量一定是一个常量",{"2":{"79":1}}],["声明并定义j",{"2":{"68":1}}],["声明i而非定义i",{"2":{"68":1}}],["声明",{"2":{"68":1}}],["机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理",{"2":{"205":1}}],["机制",{"2":{"68":1}}],["建议",{"2":{"193":1,"246":1,"267":1}}],["建议初始化每一个内置类型的变量",{"2":{"67":1}}],["建议使用引用类型的形参代替指针",{"2":{"31":1}}],["了异常",{"2":{"292":1}}],["了boolalpha",{"2":{"161":1}}],["了",{"2":{"67":1}}],["首先初始化基类的部分",{"2":{"299":1}}],["首先一个冒号",{"2":{"297":1}}],["首先搜索抛出该异常的函数",{"2":{"294":1}}],["首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数",{"2":{"270":1}}],["首先求cond的值",{"2":{"269":1}}],["首先编译成员的声明",{"2":{"238":1}}],["首先构造虚基类zooanimal",{"2":{"219":1}}],["首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分",{"2":{"219":1}}],["首先是关键字namespace",{"2":{"210":1}}],["首先是类型说明符",{"2":{"67":1}}],["首先执行函数体",{"2":{"122":1}}],["首先定义两个名为v1和v2的变量",{"2":{"109":1}}],["首先",{"2":{"82":1}}],["首先将它的实参强制转换成了对const的引用",{"2":{"41":1}}],["数值转换",{"0":{"329":1}}],["数量和每册书的价格",{"2":{"153":1}}],["数据成员可以是常量",{"2":{"258":1}}],["数据成员都是字面值类型",{"2":{"257":1}}],["数据成员都是字面值类型的聚合类是字面值常量类",{"2":{"257":1}}],["数据成员或相关函数",{"2":{"242":1}}],["数据成员指针",{"2":{"229":1}}],["数据抽象就是接口",{"2":{"237":1}}],["数据将从程序正在运行的窗口读入",{"2":{"109":1}}],["数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法",{"2":{"84":1}}],["数据类型决定着变量所占内存空间的大小和布局方式",{"2":{"66":1}}],["数字和下画线组成",{"2":{"69":1}}],["数组自动转换成指向数组首元素的指针",{"2":{"275":1}}],["数组转换成指针",{"2":{"275":1}}],["数组初始化时",{"2":{"254":1}}],["数组或函数指针转换",{"2":{"172":1}}],["数组的下标是否在合理范围之内由程序员负责检查",{"2":{"102":1}}],["数组的元素应为对象",{"2":{"101":1}}],["数组的元素执行默认初始化",{"2":{"101":1}}],["数组的大小确定不变",{"2":{"100":1}}],["数组是一种复合类型",{"2":{"101":1}}],["数组是一种内置类型",{"2":{"100":1}}],["数组是存放相同类型的对象的容器",{"2":{"100":1}}],["数组",{"0":{"100":1},"1":{"101":1,"102":1,"103":1,"104":1},"2":{"286":1}}],["数组第二维",{"2":{"34":1}}],["数组引用形参",{"2":{"34":1}}],["数组形参应该是指向const的指针",{"2":{"34":1}}],["数组形参和const",{"2":{"34":1}}],["数组形参",{"0":{"34":1}}],["数组类似",{"2":{"13":1}}],["问号",{"2":{"65":1}}],["双向迭代器",{"2":{"199":1}}],["双引号括起来的零个或多个字符则构成字符串字面值",{"2":{"65":1}}],["双精度和扩展精度值",{"2":{"63":1}}],["十六进制",{"2":{"65":1}}],["十进制字面值的类型是int",{"2":{"65":1}}],["十进制",{"2":{"65":1}}],["八进制或是改回十进制",{"2":{"161":1}}],["八进制和十六进制字面值的类型是能容纳其数值的int",{"2":{"65":1}}],["八进制",{"2":{"65":1}}],["八进制数或十六进制数的形式",{"2":{"65":1}}],["字面常量是右值",{"2":{"131":1}}],["字面值和变量是最简单的表达式",{"2":{"259":1}}],["字面值和string对象相加",{"2":{"91":1}}],["字面值",{"2":{"79":1}}],["字面值常量类",{"0":{"257":1}}],["字面值常量的形式和值决定了它的数据类型",{"2":{"65":1}}],["字面值常量",{"0":{"65":1}}],["字符都直接表示位模式",{"2":{"155":1}}],["字符处理函数的头文件是cctype",{"2":{"92":1}}],["字符",{"2":{"65":1}}],["字符字面值",{"2":{"65":1}}],["字符和字符串字面值",{"2":{"65":1}}],["字符型被分成了三种",{"2":{"63":1}}],["字符串字面量转换成string类型",{"2":{"275":1}}],["字符串字面值的实际长度要比它的内容多1",{"2":{"65":1}}],["字符串字面值的类型实际上是由常量字符构成的数组",{"2":{"65":1}}],["字符串字面值",{"2":{"65":1}}],["字符串中下标最小的字符对应高位",{"2":{"155":1}}],["字符串以空白分隔",{"2":{"91":1}}],["字符串",{"0":{"87":1},"1":{"88":1,"89":1,"90":1,"91":1,"92":1,"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1},"2":{"0":1}}],["精度有可能损失",{"2":{"64":1}}],["精确匹配",{"2":{"48":1}}],["选择一个好种子",{"2":{"159":1}}],["选择作为成员或者非成员",{"2":{"135":1}}],["选择类型的一些经验准则",{"2":{"63":1}}],["选用long",{"2":{"63":1}}],["选用无符号类型",{"2":{"63":1}}],["布尔字面值和指针字面值",{"2":{"65":1}}],["布尔类型",{"2":{"63":1}}],["布尔值和浮点数",{"2":{"62":1}}],["某个类对其继承而来的成员的访问权限受到两个因素影响",{"2":{"303":1}}],["某个时刻只能有一个unique",{"2":{"56":1}}],["某些操作仅针对顺序容器",{"2":{"312":1}}],["某些操作是通用的",{"2":{"312":1}}],["某些类不能依赖合成的版本",{"2":{"241":1}}],["某些类不能依赖合成的默认构造函数",{"2":{"240":1}}],["某些类类型还会对它们所分配的对象使用拷贝初始化",{"2":{"120":1}}],["某些程序需要自定义内存分配的细节",{"2":{"221":1}}],["某些算法会重排容器中元素的顺序",{"2":{"189":1}}],["某些函数需要将其一个或多个实参连同类型不变地转发给其他函数",{"2":{"178":1}}],["某些运算符",{"2":{"121":1}}],["某些对vector对象的操作会使迭代器失效",{"2":{"98":1}}],["某一类型所占的比特数不同",{"2":{"63":1}}],["仅顺序容器",{"2":{"315":1}}],["仅用于一些特殊的场合",{"2":{"62":1}}],["仅在其定义的程序块运行时才存在",{"2":{"50":1}}],["空块",{"2":{"278":1}}],["空块的作用等价于空语句",{"2":{"278":1}}],["空语句",{"2":{"278":1}}],["空包",{"2":{"180":1}}],["空",{"2":{"168":1}}],["空指针",{"2":{"73":3}}],["空类型不对应具体的值",{"2":{"62":1}}],["空容器",{"2":{"15":1}}],["基类名的using声明语句",{"2":{"309":1}}],["基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数",{"2":{"307":1}}],["基类的默认构造函数初始化对象的基类部分",{"2":{"308":1}}],["基类的友元在访问派生类成员时不具有特殊性",{"2":{"303":1}}],["基类的部分定义",{"2":{"297":1}}],["基类对象",{"2":{"299":1}}],["基类必须将它的两种成员函数区分开来",{"2":{"298":1}}],["基类通常都应该定义一个虚析构函数",{"2":{"298":1}}],["基类希望它的派生类各自定义适合自身的版本",{"2":{"297":1}}],["基类负责定义在层次关系中所有类共同拥有的成员",{"2":{"297":1}}],["基础",{"0":{"260":1},"1":{"261":1,"262":1,"263":1}}],["基于此",{"2":{"282":1}}],["基于",{"2":{"135":1}}],["基于同样的道理",{"2":{"34":1}}],["基本概念",{"0":{"135":1,"261":1}}],["基本内置类型",{"0":{"62":1},"1":{"63":1,"64":1,"65":1}}],["释放一个数组",{"2":{"222":1}}],["释放一个对象",{"2":{"222":1}}],["释放",{"2":{"222":1}}],["释放已有资源",{"2":{"132":1}}],["释放内存通过调用deallocate来完成",{"2":{"60":1}}],["释放我们真正构造的string",{"2":{"60":1}}],["未初始化的token对象",{"2":{"233":1}}],["未初始化的无名对象",{"2":{"53":1}}],["未命名的内存空间以便存储特定类型的对象",{"2":{"222":1}}],["未命名的",{"2":{"193":1,"228":1}}],["未格式化的输入",{"0":{"162":1}}],["未定义行为",{"2":{"92":1}}],["未构造的",{"2":{"60":1}}],["另外",{"2":{"276":1,"292":1}}],["另外一部分则源于计算机的特点",{"2":{"264":1}}],["另外一种类型的复合类型",{"2":{"73":1}}],["另外还有其他两个ostream对象",{"2":{"109":1}}],["另外只要表达式的类型可以转换成形参类型",{"2":{"44":1}}],["另一个版本接受一个额外的谓词参数",{"2":{"202":1}}],["另一个事例见",{"2":{"59":1}}],["另一些只有特定类别的迭代器才支持",{"2":{"200":1}}],["另一种是基类希望派生类直接继承而不要改变的函数",{"2":{"298":1}}],["另一种是switch语句",{"2":{"280":1}}],["另一种是",{"2":{"176":1}}],["另一类是有特殊含义的字符",{"2":{"65":1}}],["销毁它是无害的",{"2":{"132":1}}],["销毁左侧对象的现有成员就是安全的了",{"2":{"127":1}}],["销毁类类型的成员需要执行成员自己的析构函数",{"2":{"122":1}}],["销毁时做什么",{"2":{"118":1}}],["销毁其指针",{"2":{"59":1}}],["销毁该对象",{"2":{"51":1}}],["更有效的办法是先定义一个空的vector对象",{"2":{"95":1}}],["更一般的",{"2":{"78":1}}],["更不容易出现内存管理错误并且可能有更好的性能",{"2":{"58":1}}],["更多细节可查阅书本p127",{"2":{"265":1}}],["更多讨论见p728",{"2":{"222":1}}],["更多讨论见书本p383",{"2":{"19":1}}],["更多命名空间的定义方式见p698",{"2":{"210":1}}],["更多关于基类和派生类之间类型转换的讨论见p534",{"2":{"300":1}}],["更多关于枚举的讨论见p738",{"2":{"228":1}}],["更多关于using指示的讨论见p703",{"2":{"211":1}}],["更多关于noexcept的讨论见p691",{"2":{"208":1}}],["更多关于智能指针使用的讨论见p412",{"2":{"54":1}}],["更多内容详见p596",{"2":{"169":1}}],["更多有关unique",{"2":{"56":1}}],["更多有关使用原生指针管理动态内存的危险的讨论见书本p409",{"2":{"53":1}}],["\\t~d",{"2":{"308":1}}],["\\tfriend",{"2":{"303":2}}],["\\tquote",{"2":{"298":2}}],["\\tvirtual",{"2":{"297":1,"298":2,"306":1}}],["\\tvoid",{"2":{"210":1,"213":1,"301":1}}],["\\tpos",{"2":{"229":2}}],["\\traccoon",{"2":{"219":1}}],["\\trevenue",{"2":{"141":1}}],["\\treturn",{"2":{"137":1,"138":1,"139":1,"140":2,"141":1,"213":1}}],["\\tusing",{"2":{"215":2,"303":2,"309":1}}],["\\tunits",{"2":{"141":1}}],["\\tbase",{"2":{"308":1}}],["\\tbase2",{"2":{"215":1}}],["\\tbase1",{"2":{"215":1}}],["\\tbear",{"2":{"215":1,"219":1}}],["\\tbulk",{"2":{"213":1,"299":2}}],["\\tchar",{"2":{"229":2,"233":2,"236":1}}],["\\tclass",{"2":{"210":1,"213":1}}],["\\tcatch",{"2":{"207":1}}],["\\tcout",{"2":{"162":1}}],["\\tconst",{"2":{"142":1}}],["\\ttypedef",{"2":{"229":1}}],["\\ttry",{"2":{"207":1,"225":1}}],["\\tthrow",{"2":{"207":2}}],["\\tendangered",{"2":{"215":2,"219":1}}],["\\teobj",{"2":{"207":2}}],["\\texplicit",{"2":{"150":1}}],["\\telse",{"2":{"138":1,"222":1}}],["\\toperator",{"2":{"150":1}}],["\\tos",{"2":{"137":1}}],["\\tsleeping",{"2":{"219":1}}],["\\tsmallint",{"2":{"150":1}}],["\\tstatic",{"2":{"229":1}}],["\\tstrblobptr",{"2":{"143":4}}],["\\tstrvec",{"2":{"141":1}}],["\\tstd",{"2":{"55":1,"142":2,"144":2,"150":1,"229":1,"297":1,"298":2,"299":1,"303":2}}],["\\tsum",{"2":{"139":1}}],["\\tsales",{"2":{"139":1}}],["\\t\\tquote",{"2":{"299":1}}],["\\t\\tconst",{"2":{"225":1}}],["\\t\\tthrow",{"2":{"207":1,"222":1}}],["\\t\\tif",{"2":{"150":1}}],["\\t\\titem",{"2":{"138":2}}],["\\t\\t\\tthrow",{"2":{"150":1}}],["\\t\\t\\t",{"2":{"147":1,"148":1,"150":3,"153":2,"156":2,"215":2,"216":1,"226":1,"230":2,"233":1,"299":1,"303":1}}],["\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"207":2,"303":1}}],["\\t\\t\\t\\t\\t\\t\\t",{"2":{"156":1}}],["\\t\\t\\t\\t\\t\\t",{"2":{"150":1,"156":7,"208":1,"228":1}}],["\\t\\t\\t\\t\\t",{"2":{"139":1,"156":1,"159":1,"216":1,"222":1,"233":1}}],["\\t\\t\\t\\t",{"2":{"135":2,"156":1,"208":1,"216":1,"222":1,"228":1,"233":1,"299":2}}],["\\t\\treturn",{"2":{"144":1,"145":1,"222":1,"229":1}}],["\\t\\t",{"2":{"139":1,"141":1,"143":2,"144":1,"145":1,"148":1,"153":1,"156":3,"159":2,"207":3,"222":1,"225":2,"228":1,"299":3,"303":1}}],["\\tint",{"2":{"145":1,"233":2,"236":1,"303":2}}],["\\tif",{"2":{"138":1,"222":1}}],["\\tis",{"2":{"138":1}}],["\\tdisc",{"2":{"309":1}}],["\\tdisplay",{"2":{"213":1}}],["\\td",{"2":{"308":2}}],["\\td1",{"2":{"215":1}}],["\\tdouble",{"2":{"138":1,"233":2,"297":1,"298":1,"299":2,"309":1}}],["\\tdelete",{"2":{"55":1}}],["\\t",{"2":{"135":2,"137":1,"140":2,"141":2,"142":1,"144":2,"145":1,"147":1,"148":1,"150":4,"153":2,"155":2,"156":1,"159":2,"161":2,"207":3,"210":1,"215":2,"219":1,"222":1,"225":5,"226":2,"229":1,"233":1,"298":2,"299":2,"301":1,"303":1,"306":2,"308":3}}],["直至condition为假时停止",{"2":{"112":1}}],["直到找到适当类型的catch子句为止",{"2":{"294":1}}],["直到找到所需的名字",{"2":{"217":1}}],["直到19章",{"2":{"276":1}}],["直到使用成员指针时",{"2":{"229":1}}],["直到最外层的全局命名空间查找过程终止",{"2":{"212":1}}],["直到实例化时才会知道",{"2":{"168":1}}],["直到读取的字符数达到对应bitset的大小时",{"2":{"156":1}}],["直到遇到文件尾",{"2":{"114":1}}],["直到给定条件为假为止",{"2":{"112":1}}],["直到程序结束才会销毁",{"2":{"27":1}}],["直接拷贝整个容器",{"2":{"314":1}}],["直接",{"2":{"302":1,"309":1}}],["直接抛弃",{"2":{"264":1}}],["直接调用一个重载的运算符函数",{"2":{"135":1}}],["直接检测自赋值",{"2":{"132":1}}],["直接初始化",{"2":{"90":2}}],["直接管理内存",{"0":{"53":1}}],["本书中会介绍一些比较常规的提升异常安全性的技术",{"2":{"292":1}}],["本章介绍前三种",{"2":{"288":1}}],["本章介绍出于第三种原因的例子",{"2":{"52":1}}],["本章节主要是介绍如何使用c++正则表达式库",{"2":{"157":1}}],["本例中",{"2":{"153":1}}],["本质上是函数",{"2":{"121":1}}],["本节的概念比较简单",{"2":{"265":1}}],["本节介绍c++从c语言继承而来的两种不可移植的特性",{"2":{"235":1}}],["本节",{"2":{"47":1}}],["qty",{"2":{"299":4,"309":2}}],["qlib",{"2":{"211":1}}],["querylib",{"2":{"211":1}}],["qualifier",{"2":{"133":1}}],["quote类中",{"2":{"309":1}}],["quote的构造函数",{"2":{"309":1}}],["quote的默认构造函数",{"2":{"307":1}}],["quote默认构造函数运行disc",{"2":{"307":1}}],["quote",{"2":{"213":4,"297":3,"298":1,"299":6,"306":1,"309":6}}],["quot",{"0":{"236":2},"2":{"65":2,"95":2,"109":2,"222":2,"226":2,"236":2,"243":2,"264":2,"267":2}}],["q是一个整型常量引用",{"2":{"82":1}}],["q为hi",{"2":{"60":1}}],["q为空字符串",{"2":{"60":1}}],["q++",{"2":{"60":2}}],["q指向最后构造元素之后的位置",{"2":{"60":1}}],["q",{"2":{"52":1,"60":3,"82":1}}],["智能指针类也支持派生类向基类的类型转换",{"2":{"300":1}}],["智能指针和动态数组",{"2":{"59":1}}],["智能指针和异常",{"0":{"55":1}}],["智能指针也是模板",{"2":{"52":1}}],["智能指针的行为类似常规指针",{"2":{"51":1}}],["两种情况下",{"2":{"155":1}}],["两种",{"2":{"63":1}}],["两种智能指针的区别在于管理底层指针的方式",{"2":{"51":1}}],["两个容器中的元素将会交换",{"2":{"315":1}}],["两个容器的类型和元素的类型都必须匹配",{"2":{"314":1}}],["两个不同类型的可调用对象却可能共享同一种调用形式",{"2":{"148":1}}],["两个指针都指向derived对象",{"2":{"226":1}}],["两个指针相减的结果是它们之间的距离",{"2":{"103":1}}],["两个指针是不同的指针",{"2":{"31":1}}],["两个成员分别是first",{"2":{"17":1}}],["新元素进行值初始化",{"2":{"322":1}}],["新标准引入了一种新的类型",{"2":{"131":1}}],["新标准的一个最主要的特性是可以移动而非拷贝对象的能力",{"2":{"130":1}}],["新迭代器向后移动若干个元素",{"2":{"99":1}}],["新迭代器向前移动若干个元素",{"2":{"99":1}}],["新的标准提供了两种智能指针",{"2":{"51":1}}],["新函数",{"2":{"41":1}}],["地使用动态内存",{"2":{"51":1}}],["动态绑定析构函数",{"2":{"306":1}}],["动态类型直到运行时才可知",{"2":{"300":1}}],["动态类型则是变量或表达式表示的内存中的对象的类型",{"2":{"300":1}}],["动态数组",{"0":{"58":1},"1":{"59":1,"60":1}}],["动态分配一个新对象",{"2":{"55":1}}],["动态分配的对象是默认初始化的",{"2":{"53":1}}],["动态对象的生存周期由程序来控制",{"2":{"50":1}}],["动态内存的管理是通过一对运算符来完成的",{"2":{"51":1}}],["动态内存与智能指针",{"0":{"51":1},"1":{"52":1,"53":1,"54":1,"55":1,"56":1,"57":1}}],["动态内存",{"0":{"50":1},"1":{"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1},"2":{"0":1}}],["分离的技术",{"2":{"237":1}}],["分离式编译允许我们把程序分割到几个文件中去",{"2":{"29":1}}],["分离式编译",{"0":{"29":1}}],["分的讨论见p626",{"2":{"172":1}}],["分布对象使用它的引擎参数生成随机数",{"2":{"159":1}}],["分布类型定义了一个调用运算符",{"2":{"159":1}}],["分布类型和引擎",{"2":{"159":1}}],["分布",{"2":{"158":1}}],["分别指出this可以指向一个左值或右值",{"2":{"133":1}}],["分别表示输入流和输出流",{"2":{"109":1}}],["分配给一个union的存储空间至少能容纳它的最大的数据成员",{"2":{"233":1}}],["分配",{"2":{"223":1}}],["分配n个未初始化的string",{"2":{"60":1}}],["分配一个数组",{"2":{"222":1}}],["分配一个数组会得到一个元素类型的指针",{"2":{"59":1}}],["分配一个对象",{"2":{"55":1,"222":1}}],["分配在静态或栈内存中的对象由编译器自动创建和销毁",{"2":{"50":1}}],["栈内存用来保存定义在函数内的非static对象",{"2":{"50":1}}],["见表9",{"2":{"312":1,"314":1,"321":1}}],["见书本更详细的解读",{"2":{"294":1}}],["见书本p130",{"2":{"266":1}}],["见书本p293的详细讨论",{"2":{"311":1}}],["见书本p233的详细讨论",{"2":{"238":1}}],["见书本p223",{"2":{"49":1}}],["见书本p646更详细的讨论",{"2":{"157":1}}],["见书本p43",{"2":{"69":1}}],["见p173",{"2":{"293":1}}],["见p351",{"2":{"193":1}}],["见p381",{"2":{"14":1}}],["见p388",{"2":{"14":1}}],["见p471",{"2":{"178":1}}],["见p429",{"2":{"60":1}}],["见p643",{"2":{"156":1}}],["见p292表9",{"2":{"311":1}}],["见p243",{"2":{"246":1}}],["见p287",{"2":{"9":1}}],["见p286",{"2":{"8":1}}],["见p283",{"2":{"6":1}}],["见p279",{"2":{"4":1}}],["指示",{"2":{"236":1}}],["指的是可以指向类的非静态成员的指针",{"2":{"229":1}}],["指出任意非c++函数所用的语言",{"2":{"236":1}}],["指出接下来的参数表示零个或多个类型的列表",{"2":{"180":1}}],["指出名字cout和endl是定义在名为std的命名空间",{"2":{"109":1}}],["指定某个函数不会抛出异常",{"2":{"208":1}}],["指定显式模板实参",{"2":{"173":1}}],["指定模板实参",{"2":{"166":1}}],["指定字面值的类型",{"2":{"65":1}}],["指向容器其他位置的迭代器仍有效",{"2":{"323":1}}],["指向容器的迭代器仍有效",{"2":{"323":1}}],["指向插入位置之前的元素的迭代器仍有效",{"2":{"323":1}}],["指向vector或string中删除点之后位置的迭代器",{"2":{"321":1}}],["指向对象的指针可以转换成void",{"2":{"275":1}}],["指向成员函数的对象将被传给隐式的this形参",{"2":{"231":1}}],["指向同一类型的对象",{"2":{"226":1}}],["指向数组首元素的指针",{"2":{"142":1}}],["指向整数j",{"2":{"79":1}}],["指向整型常量i",{"2":{"79":1}}],["指向常量的指针",{"2":{"77":1}}],["指向紧邻对象所占用空间的下一个位置",{"2":{"73":1}}],["指向一个未初始化的token对象的指针",{"2":{"233":1}}],["指向一个对象",{"2":{"73":1}}],["指向一个值为42的int的shared",{"2":{"52":1}}],["指向",{"2":{"73":1}}],["指向shared",{"2":{"51":1}}],["指向该函数的",{"2":{"49":1}}],["指针失效",{"2":{"321":1}}],["指针的转换",{"2":{"275":1}}],["指针的值",{"2":{"73":1}}],["指针不需要有效",{"2":{"271":1}}],["指针类型的dynamic",{"2":{"225":1}}],["指针类型既可以是顶层const也可以是底层const",{"2":{"78":1}}],["指针或io缓冲",{"2":{"130":1}}],["指针或引用形参与const",{"2":{"33":1}}],["指针都支持",{"2":{"103":1}}],["指针都属于字面值类型",{"2":{"79":1}}],["指针和引用的静态类型决定了我们能够使用哪些成员",{"2":{"216":1}}],["指针和多维数组",{"2":{"105":1}}],["指针和数组",{"0":{"103":1}}],["指针和constexpr",{"2":{"79":1}}],["指针和const",{"0":{"77":1}}],["指针是一个对象",{"2":{"77":1}}],["指针能做的事儿比较有限",{"2":{"73":1}}],["指针pi的类型和pd的类型不匹配",{"2":{"73":1}}],["指针存放某个对象的地址",{"2":{"73":1}}],["指针本身就是一个对象",{"2":{"73":1}}],["指针",{"0":{"73":1},"2":{"73":3,"258":1,"275":1}}],["指针形参",{"2":{"31":1}}],["要记住的是",{"2":{"282":1}}],["要记住我们所说的动态数组并不是数组类型",{"2":{"59":1}}],["要不然就是左值",{"2":{"261":1}}],["要创建一个类的对象",{"2":{"247":1}}],["要自己定义一个",{"2":{"240":1}}],["要么一次也不出现",{"2":{"208":1}}],["要么是在表达式求值过程中创建的临时对象",{"2":{"131":1}}],["要注意的一点是",{"2":{"207":1}}],["要求",{"2":{"199":1}}],["要求显式指定模板实参会给用户增添额外负担",{"2":{"174":1}}],["要访问它们",{"2":{"153":1}}],["要想使用拷贝或移动构造函数",{"2":{"308":1}}],["要想使用function",{"2":{"231":1}}],["要想通过一个指向成员函数的指针进行函数调用",{"2":{"231":1}}],["要想获取该地址",{"2":{"73":1}}],["要想定义一个名为units",{"2":{"67":1}}],["要想声明一个指向该函数的指针",{"2":{"49":1}}],["要用一个shared",{"2":{"57":1}}],["要先屏蔽掉调试代码",{"2":{"46":1}}],["参数个数差异",{"2":{"240":1}}],["参数列表后",{"2":{"240":1}}],["参数列表之后",{"2":{"238":1}}],["参数列表以及函数体",{"2":{"135":1}}],["参数绑定",{"0":{"194":1}}],["参数可以绑定到一个右值",{"2":{"176":1}}],["参数的实参必须是一个左值",{"2":{"176":1}}],["参数传递",{"0":{"30":1},"1":{"31":1,"32":1,"33":1,"34":1,"35":1,"36":1}}],["参与取余运算的运算对象必须是整数类型",{"2":{"264":1}}],["参与运算的两个指针必须指向同一个数组当中的元素",{"2":{"103":1}}],["参与计算的迭代器必须是指向同一个容器中的元素或者尾元素的下一个位置",{"2":{"99":2}}],["参见14",{"2":{"48":1}}],["实现就是数据成员",{"2":{"237":1}}],["实例化代码",{"2":{"176":2}}],["实例化compare",{"2":{"173":1}}],["实例化定义",{"2":{"170":1}}],["实例化声明",{"2":{"170":1}}],["实例化类模板的所有成员",{"2":{"170":1}}],["实例化类模板",{"2":{"167":1}}],["实例化函数模板",{"2":{"166":1}}],["实例",{"2":{"166":1}}],["实参相关的查找与类类型形参",{"2":{"212":1}}],["实参是一个左值",{"2":{"176":1}}],["实参是一个int类型的右值",{"2":{"176":1}}],["实参中的const是无关的",{"2":{"176":1}}],["实参必须是一个左值",{"2":{"176":1}}],["实参可以是const类型",{"2":{"176":1}}],["实参列表之前",{"2":{"173":1}}],["实参从数组类型或函数类型转换成对应的指针类型",{"2":{"48":1}}],["实参类型和形参类型相同",{"2":{"48":1}}],["实参类型转换",{"0":{"48":1}}],["实际指向derived对象",{"2":{"226":1}}],["实际上放入到容器中的是对象值的一个拷贝",{"2":{"319":1}}],["实际上我们并不清除该引用",{"2":{"300":1}}],["实际上是替某个对象调用它",{"2":{"238":1}}],["实际上是数组的数组",{"2":{"105":1}}],["实际上执行的是拷贝初始化",{"2":{"90":1}}],["实际上形参是指向含有10个整数的数组的指针",{"2":{"34":1}}],["实际上传递的是指向数组首元素的指针",{"2":{"34":1}}],["实际不一定",{"2":{"34":1}}],["没有virtual函数",{"2":{"256":1}}],["没有基类",{"2":{"256":1}}],["没有类内初始值",{"2":{"256":1}}],["没有类似make",{"2":{"56":1}}],["没有定义任何构造函数",{"2":{"256":1}}],["没有任何意义",{"2":{"222":1}}],["没有对应的using声明",{"2":{"88":1}}],["没有初始值的成员将被默认初始化",{"2":{"85":1}}],["没有实际地址",{"2":{"73":1}}],["没有一个能脱颖而出",{"2":{"47":1}}],["没有返回值的return语句只能用在返回类型是void的函数中",{"2":{"38":1}}],["寻找第一个与正则表达式匹配的子序列",{"2":{"157":1}}],["寻找形参类型与实参类型最匹配的那个可行函数",{"2":{"47":1}}],["寻找最佳匹配",{"2":{"47":1}}],["讲述编译器如何确定调用哪个重载函数",{"2":{"47":1}}],["除array之外",{"2":{"314":1}}],["除非你有很好的理由选择其他容器",{"2":{"311":1}}],["除非必须",{"2":{"267":1}}],["除非标准库知道我们的移动构造函数不会抛出异常",{"2":{"132":1}}],["除去布尔类型和扩展的字符型之外",{"2":{"63":1}}],["除此之外",{"2":{"46":1,"123":1,"326":1}}],["除了顺序容器共同的操作之外",{"2":{"324":1}}],["除了无序关联容器外的所有容器都支持关系运算符",{"2":{"317":1}}],["除了array",{"2":{"315":2}}],["除了覆盖继承而来的虚函数之外",{"2":{"304":1}}],["除了",{"2":{"264":1}}],["除了在常规的作用域查找外还会查找实参类所属的命名空间",{"2":{"212":1}}],["除了参数规范",{"2":{"202":1}}],["除了输出迭代器之外",{"2":{"200":1}}],["除了每个容器的迭代器",{"2":{"195":1}}],["除了少数例外",{"2":{"186":1}}],["除了获取其大小外",{"2":{"182":1}}],["除了定义类型参数",{"2":{"166":1}}],["除了条件状态外",{"2":{"161":1}}],["除了void之外",{"2":{"150":1}}],["除了构造函数和赋值运算符之外",{"2":{"133":1}}],["除了将移后源对象置为析构安全的状态之外",{"2":{"132":1}}],["除了完成资源的移动",{"2":{"132":1}}],["除了对i赋值或销毁它外",{"2":{"131":1}}],["除了拷贝构造函数",{"2":{"128":1}}],["除了初始化对象外",{"2":{"128":1}}],["除了最内层的循环外",{"2":{"105":1}}],["除了静态内存和栈内存",{"2":{"50":1}}],["除了用于assert",{"2":{"46":1}}],["除了表9",{"2":{"18":1}}],["除了与顺序容器相同的操作之外",{"2":{"14":1}}],["除了继承自iostream类型的行为之外",{"2":{"6":1}}],["是额外的成员函数",{"2":{"326":1}}],["是没有意义的",{"2":{"287":1}}],["是聚合的",{"2":{"256":1}}],["是因为调用运算符的优先级更高",{"2":{"230":1}}],["是用来生成类的蓝图的",{"2":{"167":1}}],["是调用者的责任",{"2":{"166":1}}],["是极其困难的",{"2":{"159":1}}],["是类的一种特殊成员函数",{"2":{"150":1}}],["是常量是因为打印对象不会改变对象的内容",{"2":{"137":1}}],["是引用是因为我们希望避免复制实参",{"2":{"137":1}}],["是引用是因为无法复制一个ostream对象",{"2":{"137":1}}],["是非常量是因为向流写入内容会改变其状态",{"2":{"137":1}}],["是从io设备读出或写入io设备的",{"2":{"109":1}}],["是c标准库stddef",{"2":{"102":1}}],["是一个指向模板类型参数的右值引用",{"2":{"177":1}}],["是一个右值",{"2":{"132":1}}],["是一个字符串字面值常量",{"2":{"109":1}}],["是一个名字",{"2":{"81":1}}],["是一种特殊的语句",{"2":{"291":1}}],["是一种特殊的类",{"2":{"233":1}}],["是一种特殊的对象",{"2":{"206":1}}],["是一种特殊的指针类型",{"2":{"73":1}}],["是一种极其强大的计算工具",{"2":{"157":1}}],["是一种描述字符序列的方法",{"2":{"157":1}}],["是一种通用的访问容器中元素的方法",{"2":{"97":1}}],["是",{"2":{"73":1}}],["是ival的另一个名字",{"2":{"72":1}}],["是程序的一部分",{"2":{"70":1}}],["是放弃对指针的控制权",{"2":{"59":1}}],["是编译器定义的一个局部静态变量",{"2":{"46":1}}],["是指内部没有任何语句的一对花括号",{"2":{"278":1}}],["是指用花括号括起来的语句和声明的序列",{"2":{"278":1}}],["是指含有两个或多个运算符的表达式",{"2":{"262":1}}],["是指分布对象和引擎对象的组合",{"2":{"159":1}}],["是指如果是内置类型",{"2":{"94":1}}],["是指值不会改变",{"2":{"79":1}}],["是指基于其他类型定义的类型",{"2":{"71":1}}],["是指能用于常量表达式的函数",{"2":{"45":1}}],["是指一个过程",{"2":{"41":1}}],["发生了就崩溃吧",{"2":{"46":1}}],["程序员必须确保它们是存在的",{"2":{"321":1}}],["程序员可以使用括号将表达式的某个局部括起来使得其得到优先运算",{"2":{"262":1}}],["程序转到名为terminate的标准库函数",{"2":{"294":1}}],["程序跳转到try语句块最后一个catch子句之后的那条语句继续执行",{"2":{"294":1}}],["程序就会调用terminate以确保遵守不在运行时抛出异常的承诺",{"2":{"208":1}}],["程序的控制权从throw转移到与之匹配的catch模块",{"2":{"206":1}}],["程序的一部分负责检测问题的出现",{"2":{"205":1}}],["程序通常需要一个随机数源",{"2":{"158":1}}],["程序文件通常被称为源文件",{"2":{"108":1}}],["程序源文件命名约定",{"2":{"108":1}}],["程序所处理的数据都保存在变量中",{"2":{"107":1}}],["程序中用到的类型也越来越复杂",{"2":{"80":1}}],["程序把引用和它的初始值绑定",{"2":{"72":1}}],["程序可能继续工作",{"2":{"64":1}}],["程序可以包含一些用于调试的代码",{"2":{"46":1}}],["程序会自动进行类型转换",{"2":{"64":1}}],["程序需要确保在异常发生后资源能被正确地释放",{"2":{"55":1}}],["程序需要在多个对象间共享数据",{"2":{"52":1}}],["程序不知道所需对象的准确类型",{"2":{"52":1}}],["程序不知道自己需要多少对象",{"2":{"52":1}}],["程序使用动态内存出于以下三种原因之一",{"2":{"52":1}}],["程序用堆来存储动态分配",{"2":{"50":1}}],["程序正常结束",{"2":{"5":1}}],["调试帮助",{"0":{"46":1}}],["调用swap操作后",{"2":{"315":1}}],["调用seed设置一个种子值",{"2":{"159":1}}],["调用析构函数会销毁对象",{"2":{"223":1}}],["调用析构函数可以清除给定的对象但是不会释放该对象所在的空间",{"2":{"223":1}}],["调用free",{"2":{"222":1}}],["调用f3",{"2":{"176":1}}],["调用regex",{"2":{"157":1}}],["调用形式指明了调用返回的类型以及传递给调用的实参类型",{"2":{"148":1}}],["调用",{"2":{"135":2}}],["调用move就意味着承诺",{"2":{"131":1}}],["调用get",{"2":{"59":1}}],["调用void",{"2":{"47":1}}],["调用普通函数比直接写其语句要慢",{"2":{"45":1}}],["调用含有默认实参的函数时",{"2":{"44":1}}],["调用重载的函数",{"2":{"41":1}}],["调用者应该为此提供一些额外的信息",{"2":{"34":1}}],["调用结束后",{"2":{"27":1}}],["调用表达式的类型就是函数的返回类型",{"2":{"26":1}}],["调用运算符的形式是一对圆括号",{"2":{"26":1}}],["调用运算符",{"2":{"26":1,"117":1}}],["且存储空间被重新分配",{"2":{"323":1}}],["且元素类型只要能够转换即可",{"2":{"314":1}}],["且都可以指定容器大小和元素初始值的参数",{"2":{"314":1}}],["且begin指向该范围中的第一个元素",{"2":{"313":1}}],["且没有介绍应用场景",{"2":{"276":1}}],["且没有定义自己的操作",{"2":{"237":1}}],["且该值即使转换的话其所占空间也不应该大于目标类型的空间",{"2":{"266":1}}],["且要求静态成员必须是字面值常量类型",{"2":{"258":1}}],["且是隐式const的",{"2":{"257":1}}],["且符合constexpr函数的所有要求",{"2":{"257":1}}],["且其中一个模板最特例化",{"2":{"179":1}}],["且此右值引用指向模板类型参数",{"2":{"176":1}}],["且我们希望使用这些默认实参",{"2":{"168":1}}],["且定义在类模板内的成员函数被隐式声明为内联函数",{"2":{"167":1}}],["且类的每个非static数据成员都可以移动时",{"2":{"132":1}}],["且按照它们在类中出现的顺序进行初始化",{"2":{"122":1}}],["且任何额外参数都有默认值",{"2":{"120":1}}],["且必须保存相同类型的元素",{"2":{"317":1}}],["且必须是一个常量表达式",{"2":{"101":1}}],["且必须完全一致",{"2":{"45":1}}],["且运算代价和float没有相差无几",{"2":{"63":1}}],["且异常未在f中被捕获",{"2":{"55":1}}],["且在编译过程中就能得到计算结果的表达式",{"2":{"79":1}}],["且在new之后在对应的delete之前发生了异常",{"2":{"55":1}}],["且在f中未被捕获",{"2":{"55":2}}],["且函数体内必须有且只有一条return语句",{"2":{"45":1}}],["把一个运算符",{"2":{"259":1}}],["把rhs加到sum中",{"2":{"139":1}}],["把lhs的数据成员拷贝给sum",{"2":{"139":1}}],["把",{"2":{"77":1}}],["把引用绑定到const对象上",{"2":{"76":1}}],["把内联函数和constexpr函数放在头文件内",{"2":{"45":1}}],["把函数不会改变的形参定义成",{"2":{"33":1}}],["n默认为",{"2":{"325":1}}],["ntry",{"2":{"294":1}}],["n等于",{"2":{"264":1}}],["n和m",{"2":{"264":1}}],["net",{"2":{"297":2,"298":1,"299":1,"300":1,"301":1,"302":2,"309":1}}],["nested",{"2":{"232":2}}],["new版本",{"2":{"223":1}}],["new分配的内存空间来说我们无法使用construct函数构造对象",{"2":{"223":1}}],["new分配的对象",{"2":{"59":1}}],["new函数以获取内存空间",{"2":{"222":1}}],["new函数",{"2":{"222":1}}],["new函数和operator",{"2":{"222":4}}],["new接口和operator",{"2":{"222":1}}],["new表达式调用一个名为operator",{"2":{"222":1}}],["new表达式就会失败",{"2":{"53":1}}],["newcallable会调用callable",{"2":{"194":1}}],["newcallable",{"2":{"194":1}}],["new将内存分配和对象构造组合在了一起",{"2":{"60":1}}],["new和operator",{"2":{"222":2}}],["new和delete有一些灵活性上的局限",{"2":{"60":1}}],["new和数组",{"0":{"59":1}}],["new抛出std",{"2":{"53":1}}],["new返回一个空指针",{"2":{"53":2}}],["new",{"2":{"45":2,"51":1,"53":6,"54":3,"55":3,"56":1,"59":5,"222":10,"223":7,"226":1,"233":1}}],["ns",{"2":{"213":2}}],["nsp",{"2":{"210":1}}],["n都定义在一个名为placeholders的命名空间中",{"2":{"194":1}}],["n的名字",{"2":{"194":1}}],["num",{"2":{"279":1}}],["number",{"2":{"158":2}}],["numbers",{"2":{"109":3,"168":4,"327":1}}],["nullptr",{"2":{"73":1,"79":2,"132":2}}],["null",{"2":{"73":2,"104":1,"278":1}}],["n叫维度",{"2":{"101":1}}],["name是static",{"2":{"276":1}}],["name这样使用命名空间的成员显然非常烦琐",{"2":{"211":1}}],["name表示全局命名空间中的一个成员",{"2":{"210":1}}],["name的名字都可以在我们的程序中直接使用",{"2":{"194":1}}],["name",{"2":{"88":1,"167":1,"194":1,"211":1,"215":2,"219":4,"227":1,"276":1,"282":2}}],["namespace",{"2":{"88":1,"109":1,"194":3,"209":2,"211":2,"247":1}}],["n",{"2":{"60":2,"77":2,"90":1,"91":1,"94":3,"96":1,"99":2,"101":1,"103":1,"142":4,"168":2,"264":5,"294":2,"297":1,"298":2,"300":1,"303":3,"325":3}}],["npos",{"2":{"327":1}}],["np与p共享对象",{"2":{"57":1}}],["np",{"2":{"57":1}}],["ndebug",{"2":{"46":3}}],["ndebug预处理变量",{"2":{"46":1}}],["noderived不能作为基类",{"2":{"299":1}}],["noderived",{"2":{"299":1}}],["noshowbase",{"2":{"161":1}}],["noboolalpha",{"2":{"161":2}}],["nonportable",{"2":{"235":1}}],["nonprintable",{"2":{"65":1}}],["nontype",{"2":{"166":1}}],["none",{"2":{"156":1}}],["noexcept说明要么出现在该函数的所有声明语句和定义语句中",{"2":{"208":1}}],["noexception异常说明",{"0":{"208":1}}],["noexcept",{"2":{"132":1,"208":2,"222":7}}],["noexcpet",{"2":{"132":1}}],["nocopy",{"2":{"125":5}}],["not",{"2":{"156":1}}],["nothrow",{"2":{"53":1,"222":4}}],["note",{"2":{"4":1,"7":1,"19":2,"22":1,"29":1,"30":1,"31":1,"34":1,"40":1,"41":2,"42":1,"47":2,"48":1,"49":1,"52":1,"58":1,"59":2,"63":1,"65":1,"67":1,"70":1,"72":1,"75":1,"95":1,"109":2,"122":1,"137":1,"138":1,"143":1,"150":1,"153":1,"155":1,"157":1,"158":1,"159":3,"166":1,"167":2,"176":1,"178":4,"183":1,"188":1,"203":1,"206":1,"207":2,"211":1,"218":1,"219":1,"222":1,"223":2,"226":2,"233":1,"234":1,"236":1,"237":1,"238":1,"240":1,"242":1,"243":1,"246":2,"252":1,"253":1,"263":1,"265":1,"266":1,"267":1,"268":1,"270":1,"271":1,"274":1,"276":1,"279":1,"281":1,"282":2,"285":1,"287":1,"291":1,"292":1,"293":1,"294":1,"298":1,"299":1,"300":1,"302":1,"303":2,"304":1,"317":1}}],["no",{"2":{"41":1}}],["nounitbuf",{"2":{"5":1}}],["频繁调用的函数",{"2":{"45":1}}],["展开",{"2":{"45":1}}],["内存中的位置",{"2":{"261":1}}],["内存耗尽",{"2":{"53":1}}],["内容",{"2":{"261":1}}],["内置类型没有析构函数",{"2":{"122":1}}],["内置类型的成员则直接拷贝",{"2":{"120":1}}],["内置类型产生未定义的值",{"2":{"27":1}}],["内置的下标运算符可以处理负值",{"2":{"103":1}}],["内联机制用于优化规模小",{"2":{"45":1}}],["内联说明只是向编译器发出一个请求",{"2":{"45":1}}],["内联地",{"2":{"45":1}}],["内联函数可以避免函数调用的开销",{"2":{"45":1}}],["内联函数和constexpr函数",{"0":{"45":1}}],["goto绕过了ix的声明",{"2":{"291":1}}],["goto",{"2":{"291":3}}],["goto语句绕过了一个带初始化的变量定义",{"2":{"291":1}}],["goto语句也不能将程序的控制权从变量的作用域之外转移到作用域之内",{"2":{"291":1}}],["goto语句的语法形式是",{"2":{"291":1}}],["goto语句",{"0":{"291":1},"2":{"291":1}}],["goto和return",{"2":{"288":1}}],["grade",{"2":{"269":1}}],["green",{"2":{"228":1}}],["greater",{"2":{"147":1}}],["game",{"2":{"247":1}}],["g版本表示我们正在读取数据",{"2":{"163":1}}],["guard",{"2":{"86":1}}],["global",{"2":{"70":1}}],["gcc下",{"2":{"65":1}}],["getvec返回一个右值",{"2":{"132":1}}],["getvec",{"2":{"132":3}}],["getline返回输入流",{"2":{"91":1}}],["getline函数会读取换行符",{"2":{"91":1}}],["getline",{"2":{"91":1}}],["get",{"2":{"59":1,"153":3,"162":3,"229":2,"230":6,"279":1,"282":1,"291":1}}],["g",{"2":{"44":2,"178":2,"180":1}}],["gt",{"0":{"138":2},"2":{"18":1,"40":1,"91":4,"94":9,"96":2,"98":3,"99":2,"109":3,"135":1,"136":2,"147":1,"153":1,"167":1,"178":5,"230":1,"231":1,"268":1,"270":8,"317":2}}],["handler",{"2":{"294":1}}],["handling",{"2":{"205":1}}],["hasptr仍然需要通过析构函数来释放string",{"2":{"128":1}}],["hasptr需要",{"2":{"127":1}}],["hasptr",{"2":{"126":1,"129":2}}],["h作为头文件的后缀",{"2":{"116":1}}],["h中",{"2":{"103":1}}],["h头文件的c++版本",{"2":{"102":1}}],["h",{"2":{"82":1,"86":2}}],["height",{"2":{"229":1}}],["hex",{"2":{"161":4}}],["header",{"2":{"86":1,"109":1}}],["heap",{"2":{"50":1}}],["hello",{"2":{"33":1,"49":3,"101":1,"104":1}}],["highlight",{"2":{"216":2}}],["high",{"2":{"155":1}}],["hiya",{"2":{"90":2}}],["hi",{"2":{"49":3,"52":1,"60":1,"91":1,"177":1,"180":1}}],["http",{"2":{"59":1}}],["ht",{"2":{"44":1}}],["默认就是inline的",{"2":{"245":1}}],["默认使用标准库的less函数对象模板",{"2":{"168":1}}],["默认构造函数在以下情况发生",{"2":{"254":1}}],["默认构造函数的作用",{"0":{"254":1}}],["默认构造函数可能执行的是错误的操作",{"2":{"240":1}}],["默认构造函数",{"2":{"120":1,"240":1}}],["默认初始化",{"2":{"67":1,"90":1,"94":1}}],["默认的",{"2":{"65":1}}],["默认状态下没有定义ndebug",{"2":{"46":1}}],["默认实参初始值",{"2":{"44":1}}],["默认实参负责填补函数调用缺少的尾部实参",{"2":{"44":1}}],["默认实参",{"0":{"44":1}}],["默认情况下union是未初始化的",{"2":{"233":1}}],["默认情况下排序算法使用operator",{"2":{"147":1}}],["默认情况下",{"2":{"8":1,"16":1,"53":1,"59":1,"75":2,"101":1,"109":1,"146":1,"161":2,"168":1,"190":1,"193":2,"202":1,"228":1,"308":1}}],["那么会抛出一个",{"2":{"329":1}}],["那么所有的迭代器都会失效",{"2":{"323":1}}],["那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的",{"2":{"313":1}}],["那么这样的子对象也有多个",{"2":{"299":1}}],["那么通常也会有专门的代码处理问题",{"2":{"292":1}}],["那么位运算如何处理运算对象的",{"2":{"270":1}}],["那么结果也是左值",{"2":{"272":1}}],["那么结果是右值",{"2":{"268":1}}],["那么结果就是左值",{"2":{"268":1}}],["那么初始值列表最多只能包含一个值",{"2":{"266":1}}],["那么该成员将执行默认初始化",{"2":{"252":1}}],["那么也可以重载",{"2":{"245":1}}],["那么就不可依赖合成的版本",{"2":{"241":1}}],["那么编译器就不会生成默认的构造函数",{"2":{"240":1}}],["那么编译阶段会报错",{"2":{"153":1}}],["那么为了提高灵活性",{"2":{"238":1}}],["那么求值顺序的规则无法得到应用",{"2":{"135":1}}],["那么算法将使用类自定义的版本",{"2":{"129":1}}],["那么它同样需要拷贝和赋值操作",{"2":{"306":1}}],["那么它实际上也同时定义了默认构造函数",{"2":{"252":1}}],["那么它的返回类型将是常量引用",{"2":{"246":1}}],["那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符",{"2":{"126":1}}],["那么它只对指针有效",{"2":{"79":1}}],["那么指向动态内存的指针就会被拷贝",{"2":{"123":1}}],["那么几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符",{"2":{"123":1}}],["那么检测成功",{"2":{"114":1}}],["那么在定义vector对象的时候设定其大小就没有什么必要了",{"2":{"95":1}}],["那么外层的同名的函数都将变得不可见",{"2":{"42":1}}],["那就是通过引用形参并修改它",{"2":{"32":1}}],["总之",{"2":{"42":1}}],["将元素插入到deque",{"2":{"319":1}}],["将元素写到一个指定的输出目的位置",{"2":{"202":1}}],["将执行析构函数",{"2":{"306":1}}],["将产生未定义的后果",{"2":{"276":1}}],["将void",{"2":{"276":1}}],["将val的值增加1",{"2":{"113":1}}],["将会引发错误并产生未定义的行为",{"2":{"263":1}}],["将会写到同一个窗口",{"2":{"109":1}}],["将隐式传递this指针",{"2":{"238":1}}],["将该指针绑定到一个对象上",{"2":{"231":1}}],["将成员函数用作可调用对象",{"0":{"231":1}}],["将获得一个成员指针",{"2":{"229":1}}],["将抛出一个名为bad",{"2":{"226":1}}],["将在程序中查找可供调用的operator函数",{"2":{"222":1}}],["将在13",{"2":{"195":1}}],["将返回一个左值引用类型",{"2":{"178":1}}],["将其绑定到模板参数上",{"2":{"166":1}}],["将其初始化为1",{"2":{"113":1}}],["将流置于一个无效状态",{"2":{"163":1}}],["将下一个字节作为int返回",{"2":{"162":1}}],["将字符ch放回is",{"2":{"162":1}}],["将字符ch输出到ostream",{"2":{"162":1}}],["将is向后移动一个字节",{"2":{"162":1}}],["将is的下一个字节作为int返回",{"2":{"162":1}}],["将i传递给absobj",{"2":{"145":1}}],["将生成相同的序列",{"2":{"159":1}}],["将最后一位设置为与第一位一样",{"2":{"156":1}}],["将第一位复位",{"2":{"156":1}}],["将所有位置位",{"2":{"156":1}}],["将所有位复位",{"2":{"156":1}}],["将序列按照升序排列",{"2":{"147":1}}],["将由程序负责确保lambda执行时引用所引用的对象确实存在",{"2":{"146":1}}],["将实际工作委托给解引用运算符",{"2":{"144":1}}],["将实参的值拷贝后赋给形参",{"2":{"30":1}}],["将rhs置于可析构状态",{"2":{"132":1}}],["将rr2绑定到乘法结果上",{"2":{"131":1}}],["将它定义为删除的",{"2":{"125":1}}],["将一个容器初始化为另一个容器的拷贝",{"2":{"314":1}}],["将一个右值引用绑定到一个左值的特性允许它们截断左值",{"2":{"177":1}}],["将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明",{"2":{"170":1}}],["将一个字符序列与一个正则表达式匹配",{"2":{"157":1}}],["将一个对象作为实参传递给一个非引用类型的形参",{"2":{"120":1}}],["将一个weak",{"2":{"57":1}}],["将s写入输出流os当中",{"2":{"91":1}}],["将函数指定为内联函数",{"2":{"45":1}}],["将函数声明置于局部作用域内不是一个明智的选择",{"2":{"42":1}}],["找不到任何一个函数与调用的实参匹配",{"2":{"41":1}}],["比int类型小的整型值首先提升为较大的整数类型",{"2":{"273":1}}],["比长度",{"2":{"96":1}}],["比首个相异元素的大小",{"2":{"96":1}}],["比较两个容器实际上是进行元素的逐对比较",{"2":{"317":1}}],["比较两个string对象的长度",{"2":{"41":1}}],["比较迭代器所处的位置",{"2":{"99":1}}],["比较特殊的是",{"2":{"78":1}}],["比如解引用操作",{"2":{"313":1}}],["比如用花括号括起来的初始值列表",{"2":{"286":1}}],["比如ival+5",{"2":{"278":1}}],["比如iostream类阻止了拷贝",{"2":{"125":1}}],["比如下面的表达式是未定义的",{"2":{"263":1}}],["比如下面这个例子将导致编译错误",{"2":{"33":1}}],["比如动态内存",{"2":{"241":1}}],["比如类成员中有类",{"2":{"240":1}}],["比如内置类型若没有类内初始值",{"2":{"240":1}}],["比如说内置的赋值运算符把它的左侧运算对象当成左值返回",{"2":{"238":1}}],["比如公有的成员函数",{"2":{"237":1}}],["比如使用关键字new将对象放置在特定的内存空间中",{"2":{"221":1}}],["比如sort",{"2":{"189":1}}],["比如find",{"2":{"187":1}}],["比如为一个指针",{"2":{"170":1}}],["比如push",{"2":{"98":1}}],["比如拿有符号数和无符号数做比较",{"2":{"64":1}}],["比如这两个重载函数",{"2":{"41":1}}],["比如",{"2":{"41":2,"46":1,"108":1,"113":1,"141":1,"147":1,"159":1,"174":1,"185":1,"194":1,"233":1,"236":2,"276":1}}],["比如无法传入一个常量对象了",{"2":{"33":1}}],["比如一个函数指针类型",{"2":{"16":1}}],["重新抛出",{"2":{"207":1}}],["重排元素的算法将重排后的元素写回给定的输入序列中",{"2":{"202":1}}],["重排元素的算法",{"0":{"189":1}}],["重排元素等",{"2":{"184":1}}],["重声明模板参数b",{"2":{"168":1}}],["重要概念",{"2":{"107":1}}],["重要的区别是它负责自动释放所指向的对象",{"2":{"51":1}}],["重载成员函数",{"2":{"245":1}}],["重载new和delete",{"0":{"222":1}}],["重载与命名空间",{"0":{"213":1}}],["重载与模板",{"0":{"179":1}}],["重载与作用域",{"0":{"42":1}}],["重载输入运算符",{"0":{"138":1}}],["重载输出运算符",{"0":{"137":1}}],["重载的运算符也包含返回类型",{"2":{"135":1}}],["重载的运算符是具有特殊名字的函数",{"2":{"135":1}}],["重载运算符函数的参数数量与该运算符作用的运算对象数量一样多",{"2":{"135":1}}],["重载运算符的参数表示运算符的运算对象",{"2":{"121":1}}],["重载运算符",{"2":{"121":1,"261":1}}],["重载函数的指针",{"2":{"49":1}}],["重载",{"0":{"149":1},"1":{"150":1},"2":{"41":1}}],["重载和const形参",{"2":{"41":1}}],["重复第二个步骤",{"2":{"113":1}}],["重复声明",{"2":{"41":1}}],["重复定义",{"2":{"33":1}}],["记名字的负担",{"2":{"41":1}}],["80",{"2":{"44":3}}],["8",{"2":{"40":1,"45":1,"59":1,"67":1,"105":1,"312":1}}],["60",{"2":{"269":1}}],["64比特",{"2":{"63":1}}],["66",{"2":{"44":2}}],["6",{"2":{"40":1,"47":1,"59":1,"105":1,"195":1,"228":1,"313":1,"320":1}}],["99页",{"2":{"313":1}}],["999",{"2":{"153":1}}],["96页",{"2":{"313":1}}],["9节",{"2":{"48":1}}],["9",{"2":{"40":1,"59":1,"105":1,"150":2,"159":1}}],["78345",{"2":{"153":1}}],["7",{"2":{"40":1,"59":1,"105":1,"312":1,"313":1,"321":1}}],["案例",{"2":{"40":1}}],["形式构造对象",{"2":{"223":1}}],["形式如下",{"2":{"40":1}}],["形如catch",{"2":{"207":1}}],["形如t",{"2":{"176":1}}],["形成了",{"2":{"176":1}}],["形参",{"2":{"172":1}}],["形参传递给main函数",{"2":{"35":1}}],["形参是数组的引用",{"2":{"34":1}}],["形参是一种自动对象",{"2":{"27":1}}],["形参也可以是数组的引用",{"2":{"34":1}}],["形参和实参是两个相互独立的对象",{"2":{"30":1}}],["形参和函数体内部定义的变量统称为局部变量",{"2":{"27":1}}],["形参初始化的机理与变量初始化一样",{"2":{"30":1}}],["形参类型",{"2":{"28":1}}],["形参就被销毁",{"2":{"27":1}}],["u",{"2":{"159":2}}],["ulong",{"2":{"156":4}}],["ulong和to",{"2":{"156":1}}],["ullong操作都返回一个值",{"2":{"156":1}}],["ui",{"2":{"145":1}}],["undiscounted",{"2":{"301":1}}],["undefined",{"2":{"64":1,"92":1}}],["unary",{"2":{"261":1}}],["unget",{"2":{"162":1}}],["unformatted",{"2":{"162":1}}],["unsigned>",{"2":{"159":1}}],["unsigned",{"2":{"63":1,"65":2,"85":1,"86":1}}],["unconstructed",{"2":{"60":1}}],["union的名字是一个类型名",{"2":{"233":1}}],["union提供了一种有效的途径使得我们可以方便地表示一组类型不同的互斥值",{"2":{"233":1}}],["union可以定义包括构造函数和析构函数在内的成员函数",{"2":{"233":1}}],["union不能包含引用类型的成员",{"2":{"233":1}}],["union",{"0":{"233":1},"2":{"233":2}}],["uniform",{"2":{"159":1}}],["uninitialized",{"2":{"67":1}}],["units",{"2":{"67":4,"85":1,"86":1,"137":1,"138":2,"140":2,"141":1}}],["unitbuf",{"2":{"5":1}}],["unitbuf操纵符",{"2":{"5":1}}],["unique",{"0":{"56":1},"2":{"51":1,"56":1,"59":2,"170":1,"202":2,"203":1}}],["up",{"2":{"59":2}}],["up指向一个包含10个未初始化int的数组",{"2":{"59":1}}],["using指示以关键字using开始",{"2":{"211":1}}],["using指示",{"2":{"211":2}}],["using声明语句将令编译器产生代码",{"2":{"309":1}}],["using声明语句只是令某个名字在当前作用域内可见",{"2":{"309":1}}],["using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定",{"2":{"303":1}}],["using声明与using指示都会把命名空间的函数注入当前的作用域",{"2":{"213":1}}],["using声明或using指示能将某些函数添加到候选函数集",{"2":{"213":1}}],["using声明",{"2":{"211":1}}],["using",{"2":{"40":1,"49":2,"81":1,"88":2,"211":2}}],["换句话说",{"2":{"39":1}}],["递归调用",{"2":{"181":1}}],["递归下去",{"2":{"39":1}}],["递减和解引用运算符",{"2":{"135":1}}],["递减左侧运算对象的计数器",{"2":{"128":1}}],["递增运算符改变iter的值",{"2":{"263":1}}],["递增运算令迭代器每次移动一个元素",{"2":{"99":1}}],["递增",{"2":{"198":1}}],["递增和递减运算符有两种形式",{"2":{"267":1}}],["递增和递减运算符既有前置版本也有后置版本",{"2":{"143":1}}],["递增和递减运算符",{"0":{"143":1,"267":1}}],["递增迭代器",{"2":{"19":1}}],["永远",{"2":{"39":1}}],["表3",{"2":{"313":2}}],["表11",{"2":{"312":2}}],["表9",{"2":{"312":1,"319":1,"320":1}}],["表明返回的就是this所指的对象",{"2":{"238":1}}],["表明传入的this指针是一个指向常量对象的指针",{"2":{"238":1}}],["表示t1是否位于t2之前",{"2":{"227":1}}],["表示类型名字的可打印形式",{"2":{"227":1}}],["表示newcallable的参数",{"2":{"194":1}}],["表示零个或多个函数参数",{"2":{"180":1}}],["表示零个或多个模板参数",{"2":{"180":1}}],["表示有一个正则表达式的类",{"2":{"157":1}}],["表示书店交易记录的tuple",{"2":{"153":1}}],["表示接受两个int",{"2":{"148":1}}],["表示运算符的函数对象类常用来替换算法中的默认运算符",{"2":{"147":1}}],["表示容器的类通常可以通过元素在容器中的位置访问元素",{"2":{"142":1}}],["表示右侧的迭代器要移动多少个位置才能到达左侧的",{"2":{"99":1}}],["表示指针所指对象是一个常量",{"2":{"78":1}}],["表示指针本身是一个常量",{"2":{"78":1}}],["表示没有指向任何函数",{"2":{"49":1}}],["表示数组中的元素是int类型",{"2":{"40":1}}],["表示解引用func的调用将得到一个大小是10的数组",{"2":{"40":1}}],["表示调用func函数时需要一个int类型的实参",{"2":{"40":1}}],["表示返回的是一个指针",{"2":{"40":1}}],["表示含有10个整数的数组",{"2":{"40":1}}],["表示执行成功",{"2":{"39":1}}],["表达式的静态类型在编译时总是已知的",{"2":{"300":1}}],["表达式语句的作用是执行表达式并丢弃掉求值结果",{"2":{"278":1}}],["表达式ptr",{"2":{"268":1}}],["表达式中的括号无视上述规则",{"2":{"262":1}}],["表达式由一个或多个运算对象",{"2":{"259":1}}],["表达式与operator",{"2":{"222":1}}],["表达式rr1是左值",{"2":{"131":1}}],["表达式",{"0":{"259":1},"1":{"260":1,"261":1,"262":1,"263":1,"264":1,"265":1,"266":1,"267":1,"268":1,"269":1,"270":1,"271":1,"272":1,"273":1,"274":1,"275":1,"276":1},"2":{"0":1,"292":1}}],["主函数main的返回值",{"2":{"39":1}}],["主调函数",{"2":{"26":1}}],["临时量执行值初始化",{"2":{"39":1}}],["则抛出一个",{"2":{"329":1}}],["则抛出的对象将被切掉一部分",{"2":{"206":1}}],["则范围至少包含一个元素",{"2":{"313":1}}],["则范围为空",{"2":{"313":1}}],["则这些成员将被默认初始化",{"2":{"309":1}}],["则这些成员应该置于头文件中",{"2":{"210":1}}],["则需要虚析构函数",{"2":{"306":1}}],["则有可能出现指针的静态类型与被删除对象的动态类型不符的情况",{"2":{"306":1}}],["则不能使用",{"2":{"303":1}}],["则用户代码不能使用该转换",{"2":{"303":1}}],["则基类和派生类中定义的默认实参最好一致",{"2":{"301":1}}],["则之后任何尝试覆盖该函数的操作都将引发错误",{"2":{"301":1}}],["则在运行时该调用将被解析为对派生类版本的自身调用",{"2":{"301":1}}],["则在所有派生类中它都是虚函数",{"2":{"301":1}}],["则在整个继承体系中只存在该成员的唯一实例",{"2":{"299":1}}],["则派生类向基类的类型转换也是可访问的",{"2":{"303":1}}],["则派生类无权访问它",{"2":{"299":1}}],["则派生类中将包含该类的多个子对象",{"2":{"218":1}}],["则将其定义为虚函数",{"2":{"298":1}}],["则what返回该字符串",{"2":{"295":1}}],["则应该使用复合语句",{"2":{"278":1}}],["则结果是左值",{"2":{"276":1}}],["则结果为0",{"2":{"225":1}}],["则右侧运算对象将转换成左侧运算对象的类型",{"2":{"266":1}}],["则其组合规则由结合律确定",{"2":{"262":1}}],["则内置类型成员的初始值必须是一条常量表达式",{"2":{"257":1}}],["则内存就永远不会被释放了",{"2":{"55":1}}],["则内存不会被释放",{"2":{"55":1}}],["则必须已经定义好了这个类",{"2":{"247":1}}],["则必须在完整的对象上执行拷贝",{"2":{"215":1}}],["则进行默认初始化",{"2":{"240":1}}],["则没有这个要求",{"2":{"228":1}}],["则delete一个指向派生类对象的基类指针将产生未定义的行为",{"2":{"306":1}}],["则decltype将得到引用类型",{"2":{"83":1}}],["则decltype返回表达式结果对应的类型",{"2":{"83":1}}],["则decltype返回该变量的类型",{"2":{"83":1}}],["则d的派生类的成员和友元可以使用d向b的转换",{"2":{"303":1}}],["则dynamic",{"2":{"225":1}}],["则转换可以成功",{"2":{"225":1}}],["则使用标准库定义的版本",{"2":{"222":1}}],["则使用该版本执行new表达式或delete表达式",{"2":{"222":1}}],["则使用元素的拷贝构造函数来逐个进行拷贝",{"2":{"120":1}}],["则对该名字的使用将具有二义性",{"2":{"217":1}}],["则对应的成员函数将被定义为删除的",{"2":{"125":1}}],["则程序将产生错误",{"2":{"215":1}}],["则catch",{"2":{"207":1}}],["则catch无法使用派生类特有的任何成员",{"2":{"207":1}}],["则我们既能通过基类使用它也能通过派生类使用它",{"2":{"299":1}}],["则我们应该把继承链最底端的类",{"2":{"207":1}}],["则我们可以像使用函数一样使用该类的对象",{"2":{"145":1}}],["则他是异常对象的一个别名",{"2":{"207":1}}],["则表达式将被转换成与之对应的指针类型",{"2":{"206":1}}],["则沿着调用链创建的对象将被销毁",{"2":{"206":1}}],["则称它为可调用的",{"2":{"192":1}}],["则此参数也是一个函数参数包",{"2":{"180":1}}],["则此构造函数是拷贝构造函数",{"2":{"120":1}}],["则选择此模板",{"2":{"179":1}}],["则选择此函数",{"2":{"179":2}}],["则",{"2":{"179":1,"313":1}}],["则通过引用折叠",{"2":{"178":1}}],["则通过区分其指向的是常量对象还是非常量对象可以实现函数重载",{"2":{"41":1}}],["则typeid",{"2":{"226":1}}],["则typeid返回表达式的静态类型",{"2":{"226":1}}],["则typeid返回该引用所引对象的类型",{"2":{"226":1}}],["则type是一个普通类型",{"2":{"178":1}}],["则t将被推断为const类型",{"2":{"176":1}}],["则函数参数被实例化为一个普通的左值引用",{"2":{"176":1}}],["则可以传递给它任意类型的实参",{"2":{"176":1}}],["则可以对数组或函数类型的实参应用正常的指针转换",{"2":{"172":1}}],["则意味着对一个左值调用f3",{"2":{"176":1}}],["则产生错误",{"2":{"175":1}}],["则友元被授权可以访问所有模板实例",{"2":{"167":1}}],["则regex",{"2":{"157":2}}],["则bitset的高位被置为0",{"2":{"155":1}}],["则只使用给定值中的低位",{"2":{"155":1}}],["则剩余高位被置为0",{"2":{"155":1}}],["则编译器将为派生类合成它们",{"2":{"309":1}}],["则编译器将为union合成对应的版本并将其声明为删除的",{"2":{"233":1}}],["则编译器将报错",{"2":{"67":1}}],["则编译器首先在类及其基类的作用域中查找",{"2":{"222":1}}],["则编译器会将显示的类型转换自动应用于它",{"2":{"150":1}}],["则它的动态类型永远与静态类型一致",{"2":{"300":1}}],["则它的值会被自动提升成较大的整数类型",{"2":{"270":1}}],["则它的第一个",{"2":{"135":1}}],["则它实际上定义了转换构造函数",{"2":{"255":1}}],["则它必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数",{"2":{"206":1}}],["则它将终止当前的程序",{"2":{"206":1}}],["则它就是一个左值",{"2":{"178":1}}],["则它一般也会定义一个对应的复合赋值运算符",{"2":{"139":1}}],["则销毁状态",{"2":{"128":1}}],["则析构函数释放状态",{"2":{"128":1}}],["则初始值为0",{"2":{"94":1}}],["则相等",{"2":{"91":1,"96":1,"98":1}}],["则执行的是直接初始化",{"2":{"90":1}}],["则允许使用解引用符",{"2":{"73":1}}],["则变量被默认初始化",{"2":{"67":1}}],["则会报告二义性调用错误",{"2":{"47":1}}],["则匹配成功",{"2":{"47":1}}],["则assert什么也不做",{"2":{"46":1}}],["则该实参值由本次调用的静态类型决定",{"2":{"301":1}}],["则该虚函数的行为类似于其他的普通成员",{"2":{"299":1}}],["则该union的用法将变得很复杂",{"2":{"233":1}}],["则该初始值被用于初始化第一个成员",{"2":{"233":1}}],["则该参数是异常对象的一个副本",{"2":{"207":1}}],["则该类的派生仍按常规方式进行",{"2":{"218":1}}],["则该类的对象称作函数对象",{"2":{"145":1}}],["则该类的拷贝版本会被定义为删除的",{"2":{"132":1}}],["则该引用仅是它所引对象的一个别名",{"2":{"39":1}}],["则该函数内的每条return语句必须返回一个值",{"2":{"39":1}}],["则open会被自动调用",{"2":{"7":1}}],["特定容器的算法",{"0":{"203":1}}],["特例化不影响函数匹配",{"2":{"183":1}}],["特例化的本质是实例化一个模板",{"2":{"183":1}}],["特殊用途语言特性",{"0":{"43":1},"1":{"44":1,"45":1,"46":1}}],["特殊工具与技术",{"0":{"220":1},"1":{"221":1,"222":1,"223":1,"224":1,"225":1,"226":1,"227":1,"228":1,"229":1,"230":1,"231":1,"232":1,"233":1,"234":1,"235":1,"236":1},"2":{"0":1}}],["特别应该注意的是",{"2":{"36":1}}],["省略符形参只能出现在形参列表的最后一个位置",{"2":{"36":1}}],["省略符形参应该仅仅用于c和c++通用的类型",{"2":{"36":1}}],["省略符形参是为了便于c++程序访问某些特殊的c代码而设置的",{"2":{"36":1}}],["省略符形参",{"2":{"36":1}}],["541",{"2":{"273":1}}],["5类迭代器",{"0":{"200":1}}],["512",{"2":{"75":2}}],["5下面",{"2":{"67":1}}],["5",{"2":{"35":1,"40":1,"47":1,"59":1,"105":1,"176":2,"278":1,"319":1}}],["41",{"2":{"161":1}}],["42",{"2":{"52":2,"54":1,"55":3,"56":1,"57":1,"73":2,"76":2,"78":1,"79":1,"82":2,"83":1,"131":3,"145":1,"153":1,"159":2,"176":1,"178":3,"180":1,"192":1,"193":1,"233":2,"301":1}}],["4节介绍",{"2":{"36":1}}],["4",{"2":{"35":1,"40":1,"59":1,"67":1,"105":7,"148":3,"150":2}}],["395页",{"2":{"312":1}}],["388页",{"2":{"312":1}}],["31",{"2":{"156":1}}],["3两位为1",{"2":{"155":1}}],["32位",{"2":{"155":1}}],["32>",{"2":{"155":2,"156":1}}],["32比特",{"2":{"63":1}}],["3节讨论了避免二义性的类型转换和函数匹配遇到重载运算符时可选函数的问题",{"2":{"150":1}}],["3",{"2":{"35":1,"40":1,"47":1,"53":1,"59":1,"65":2,"77":2,"82":1,"101":2,"104":1,"105":6,"150":4,"153":1,"157":1,"161":1,"180":1,"266":1,"273":2,"312":1,"314":1}}],["最简单的语句是空语句",{"2":{"278":1}}],["最常见的是调用c语言编写的函数",{"2":{"236":1}}],["最先初始化",{"2":{"215":1}}],["最终结果",{"2":{"176":1}}],["最右",{"2":{"155":1}}],["最有效的方式是使用复合赋值来定义算术运算符",{"2":{"139":1}}],["最好在后面加上override关键字",{"2":{"297":1}}],["最好在类定义的开始或结束前的位置集中声明友元",{"2":{"243":1}}],["最好定义一个函数",{"2":{"229":1}}],["最好定义虚函数而非直接接管类型管理的重任",{"2":{"224":1}}],["最好同时定义下标运算符的常量版本和非常量版本",{"2":{"142":1}}],["最好的方式是用单行注释方式注释掉代码段的每一行",{"2":{"110":1}}],["最好将其声明为常量引用",{"2":{"32":1}}],["最后构造panda部分",{"2":{"219":1}}],["最后初始化panda",{"2":{"215":1}}],["最后以分号结束",{"2":{"67":1}}],["最后一个元素首先被销毁",{"2":{"59":1}}],["最后一个指针之后的元素值保证为0",{"2":{"35":1}}],["最安全的分配和使用动态内存的方法是调用标准库函数make",{"2":{"52":1}}],["最佳匹配",{"2":{"41":1}}],["接口的实现",{"2":{"237":1}}],["接口就是暴露给用户的操作",{"2":{"237":1}}],["接下来构造bear部分",{"2":{"219":1}}],["接下来按照直接基类在派生列表中出现的次序依次对齐进行初始化",{"2":{"219":1}}],["接下来初始化panda的第一个直接基类bear",{"2":{"215":1}}],["接下来的元素依次传递命令行提供的实参",{"2":{"35":1}}],["接管资源",{"2":{"132":1}}],["接着再将数据从临时对象拷贝到左侧运算对象的成员中",{"2":{"127":1}}],["接受panda的基类引用的一系列操作",{"2":{"216":1}}],["接受谓词参数的算法都有附加的",{"2":{"202":1}}],["接受谓词的算法对输入序列中的元素调用谓词",{"2":{"191":1}}],["接受单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大",{"2":{"201":1}}],["接受单个目标迭代器的算法",{"2":{"201":1}}],["接受单个元素的insert操作返回一个指向新元素的迭代器",{"2":{"20":1}}],["接受beg2或beg2和end2的算法用这些迭代器表示第二个输入范围",{"2":{"201":1}}],["接受第二个输入序列的算法",{"2":{"201":1}}],["接受一个元素值的算法通常有另一个不同名的",{"2":{"202":1}}],["接受一个可调用对象和另外两个参数的模板",{"2":{"178":1}}],["接受一个对象作为其右侧运算对象",{"2":{"109":1}}],["接受一个istream作为其左侧运算对象",{"2":{"109":1}}],["接受一个动态对象的指针",{"2":{"51":1}}],["接受一个key",{"2":{"21":1}}],["例如溢出",{"2":{"264":1}}],["例如除数是0的情况",{"2":{"264":1}}],["例如对于blob的成员应该是这样的",{"2":{"167":1}}],["例如算术",{"2":{"135":1}}],["例如赋值运算符",{"2":{"121":1}}],["例如",{"2":{"35":1,"49":2,"65":1,"147":2,"148":1,"166":1,"168":1,"170":1,"174":1,"175":1,"178":1,"203":1,"211":1,"218":1,"219":1,"229":1,"230":1,"263":1,"276":1,"301":1,"307":1}}],["例如push",{"2":{"14":1}}],["处理异常的某些特殊操作",{"2":{"207":1}}],["处理字符数组的指针",{"2":{"183":1}}],["处理序列",{"2":{"174":3}}],["处理每个字符",{"2":{"92":1}}],["处理string对象中的字符",{"0":{"92":1}}],["处理类型转换失败的情况",{"2":{"225":1}}],["处理类型",{"0":{"80":1},"1":{"81":1,"82":1,"83":1}}],["处理命令行选项",{"0":{"35":1}}],["处理v",{"2":{"17":1}}],["该处由用户定义清除派生类成员的操作",{"2":{"308":1}}],["该直接基类又销毁它自己的直接基类",{"2":{"307":1}}],["该调用将在编译时完成解析",{"2":{"301":1}}],["该调用将被动态绑定",{"2":{"298":1}}],["该调用可能执行基类的版本",{"2":{"298":1}}],["该成员的类型可能是下列类型中的任意一种",{"2":{"233":1}}],["该union的其他成员就变成未定义的状态了",{"2":{"233":1}}],["该对象可能是基类的对象",{"2":{"300":1}}],["该对象接受一个string实参",{"2":{"231":1}}],["该对象的类型是标准库类型type",{"2":{"226":1}}],["该代码",{"2":{"231":1}}],["该指针并没有指向任何数据",{"2":{"229":1}}],["该指针指向含有5个整数的数组",{"2":{"40":1}}],["该指针指向含有10个整数的数组",{"2":{"40":1}}],["该catch可能是同一个函数中的局部catch",{"2":{"206":1}}],["该版本接受一个谓词代替元素值",{"2":{"202":1}}],["该迭代器调用容器操作来向给定容器的指定位置插入一个元素",{"2":{"196":1}}],["该运算符不接受参数并返回一个随机unsigned整数",{"2":{"159":1}}],["该变量将被用于访问序列中的基础元素",{"2":{"92":1}}],["该机制允许将程序分割为若干个文件",{"2":{"68":1}}],["该空间能存储的值的范围",{"2":{"66":1}}],["该函数没有任何参数",{"2":{"295":1}}],["该函数的行为与系统有关",{"2":{"294":1}}],["该函数不分配任何内存",{"2":{"223":1}}],["该函数分配一块足够大的",{"2":{"222":1}}],["该函数名自动转换成指针",{"2":{"49":1}}],["该函数每个实参的匹配都不劣于其他可行函数需要的匹配",{"2":{"47":1}}],["该表达式的静态编译时类型决定了异常对象的类型",{"2":{"206":1}}],["该表达式的结果将是给定类型的元素",{"2":{"105":1}}],["该表达式就可以作为默认实参",{"2":{"44":1}}],["该表达式是函数或者指向函数的指针",{"2":{"26":1}}],["该临时量就是函数调用的结果",{"2":{"39":1}}],["该数组的元素是由10个整数构成的数组",{"2":{"34":1}}],["的异常",{"2":{"329":1}}],["的一种简写形式",{"2":{"326":1}}],["的一部分或全部的拷贝",{"2":{"325":1}}],["的其他方法",{"0":{"325":1,"326":1}}],["的名字",{"2":{"304":1}}],["的名字将隐藏定义在外层作用域",{"2":{"304":1}}],["的状态",{"2":{"301":1}}],["的核心思想是数据抽象",{"2":{"297":1}}],["的作用是从goto语句无条件跳转到同一函数内的另一条语句",{"2":{"291":1}}],["的值作为匹配位置",{"2":{"327":1}}],["的值是多少",{"2":{"325":1}}],["的值",{"2":{"286":1}}],["的值又是解引用运算符的运算对象",{"2":{"263":1}}],["的语法形式是",{"2":{"286":1}}],["的指针中的值",{"2":{"276":1}}],["的含义是把一种算术类型转换成另外一种算术类型",{"2":{"274":1}}],["的行为依赖于左侧运算对象的类型",{"2":{"270":1}}],["的特性",{"2":{"235":1}}],["的特殊值",{"2":{"109":1}}],["的形式声明一个指向成员函数的指针",{"2":{"230":1}}],["的使用形式如下所示",{"2":{"225":1}}],["的功能由两个运算符实现",{"2":{"224":1}}],["的标准库函数释放内存空间",{"2":{"222":1}}],["的标准库函数",{"2":{"222":1}}],["的机制解决上述问题",{"2":{"218":1}}],["的处理代码",{"2":{"207":1}}],["的操作将异常传递给另外一个catch语句",{"2":{"207":1}}],["的链表版本会删除第二个和后继的重复元素",{"2":{"203":1}}],["的链表版本会删除指定的元素",{"2":{"203":1}}],["的返回类型进行引用折叠",{"2":{"178":1}}],["的参数调用给定的可调用对象",{"2":{"178":1}}],["的拷贝",{"2":{"174":1}}],["的表达式显式请求值初始化时",{"2":{"254":1}}],["的表达式",{"2":{"135":1}}],["的技术",{"2":{"129":1}}],["的迭代器",{"2":{"98":1}}],["的副本",{"2":{"90":1}}],["的结果永远是引用",{"2":{"83":1}}],["的取值是true或者false",{"2":{"63":1}}],["的对象是类类型",{"2":{"222":1}}],["的对象",{"2":{"50":1}}],["的条件",{"2":{"46":1}}],["的错误信息",{"2":{"41":1}}],["的函数",{"2":{"41":1}}],["的大小都是数组类型的一部分",{"2":{"34":1}}],["的执行暂时被中断",{"2":{"26":1}}],["管理资源的类通常还定义一个名为swap的函数",{"2":{"129":1}}],["管理的类外资源",{"2":{"126":1}}],["管理类外资源的类必须定义拷贝控制成员",{"2":{"126":1}}],["管理指针形参有三种常用技术",{"2":{"34":1}}],["管理输出缓冲",{"0":{"5":1}}],["以确保编译器为我们做语法检查",{"2":{"297":1}}],["以调用类的成员函数",{"2":{"230":1}}],["以表示当前定义的指针可以指向classname的成员",{"2":{"229":1}}],["以我们的程序为例",{"2":{"219":1}}],["以避免多个对象写入或读取相同的io缓冲",{"2":{"125":1}}],["以此类推直至继承链的顶端",{"2":{"307":1}}],["以此类推",{"2":{"111":1,"173":1,"294":1,"308":1}}],["以",{"2":{"110":1}}],["以右花括号结束的语句块",{"2":{"107":1}}],["以下",{"2":{"325":1}}],["以下两条经验准则对书写复合表达式有益",{"2":{"263":1}}],["以下几个基础概念涉及大多数表达式",{"2":{"260":1}}],["以下列出几个生成空指针的方法",{"2":{"73":1}}],["以下4条语句都可以做到这一点",{"2":{"67":1}}],["以声明语句所在的作用域末端为结束",{"2":{"70":1}}],["以0x或0x开头的代表十六进制数",{"2":{"65":1}}],["以0开头的整数代表八进制数",{"2":{"65":1}}],["以及实参类的基类",{"2":{"213":1}}],["以及声明作为类接口的函数及对象",{"2":{"210":1}}],["以及递减",{"2":{"198":1}}],["以及这些操作在模板中能正确工作",{"2":{"166":1}}],["以及在函数体内用于变量声明或类型转换",{"2":{"166":1}}],["以及告诉",{"2":{"163":1}}],["以及与其关联的一组操作",{"2":{"116":1}}],["以及一个表达式",{"2":{"113":1}}],["以及很多其他设施",{"2":{"109":1}}],["以及变量能参与的运算",{"2":{"66":1}}],["以及使用尾置返回类型的方法来确定一个返回类型为函数指针的函数",{"2":{"49":1}}],["以及指针",{"2":{"49":1}}],["以及后面所有维度",{"2":{"34":1}}],["以上面的为例",{"2":{"35":1}}],["以上技术详细解读见书本p194",{"2":{"34":1}}],["以数组作为形参的函数也必须确保使用数组时不会越界",{"2":{"34":1}}],["以out模式打开文件会丢失已有数据",{"2":{"8":1}}],["和c标准库的",{"2":{"328":1}}],["和构造函数及赋值运算符不同的是",{"2":{"308":2}}],["和公有成员类似",{"2":{"303":1}}],["和私有成员类似",{"2":{"303":1}}],["和内置指针一样",{"2":{"300":1}}],["和switch语句类似",{"2":{"291":1}}],["和逗号运算符",{"2":{"263":1}}],["和二元运算符",{"2":{"261":1}}],["和普通函数的重载规则一样",{"2":{"245":1}}],["和封装",{"2":{"237":1}}],["和mem",{"2":{"231":1}}],["和使用指向数据成员的指针一样",{"2":{"230":1}}],["和类一样",{"2":{"228":1}}],["和类型别名",{"2":{"14":1}}],["和上面相反",{"2":{"227":1}}],["和调用allocator的destroy类似",{"2":{"223":1}}],["和往常一样",{"2":{"215":1,"219":1}}],["和using声明不同的是",{"2":{"211":1}}],["和using声明类似的地方是",{"2":{"211":1}}],["和一个或多个运算对象组合起来可以生成较复杂的表达式",{"2":{"259":1}}],["和一个默认函数实参",{"2":{"168":1}}],["和一组声明符",{"2":{"74":1}}],["和随机数分布类",{"2":{"158":1}}],["和",{"2":{"136":1,"226":1,"270":1,"326":3}}],["和析构函数",{"2":{"118":1}}],["和迭代器一样",{"2":{"103":1}}],["和其他类一样",{"2":{"305":1}}],["和其他作用域一样",{"2":{"304":1}}],["和其他对象一样",{"2":{"148":1}}],["和其他函数一样",{"2":{"135":1}}],["和其他内置类型一样",{"2":{"73":1,"233":1}}],["和其他使用数组的代码一样",{"2":{"34":1}}],["和无符号的",{"2":{"63":1}}],["和空类型",{"2":{"62":1}}],["和所有数组一样",{"2":{"34":1}}],["尽量保持lambda的变量捕获简单化",{"2":{"193":1}}],["尽量让不怎么使用默认值的形参出现在前面",{"2":{"44":1}}],["尽量使用常量引用",{"2":{"33":1}}],["尽管派生类对象中含有从基类继承而来的成员",{"2":{"299":1}}],["尽管在派生列表中同一个基类只能出现一次",{"2":{"218":1}}],["尽管指针和引用都能定义成constexpr",{"2":{"79":1}}],["尽管传给常量版本的也可以",{"2":{"41":1}}],["尽管不能以值传递的方式传递数组",{"2":{"34":1}}],["无法继续下去了",{"2":{"292":1}}],["无法编译通过",{"2":{"33":1}}],["无意义的表达式语句",{"2":{"278":1}}],["无返回类型",{"2":{"240":1}}],["无返回值函数",{"0":{"38":1}}],["无须在意成员出现的顺序",{"2":{"238":1}}],["无须解引用指针",{"2":{"49":1}}],["无效的代码",{"2":{"176":1}}],["无效指针",{"2":{"73":1}}],["无论左侧运算对象的类型是什么",{"2":{"266":1}}],["无论左值还是右值",{"2":{"178":1}}],["无论是普通类还是类模板",{"2":{"169":1}}],["无论何时使用一个类模板",{"2":{"168":1}}],["无论何时一个对象被销毁",{"2":{"122":1}}],["无论何时我们拷贝一个shared",{"2":{"52":1}}],["无前导字符串表示十进制",{"2":{"161":1}}],["无符号类型仅能表示大于等于0的值",{"2":{"63":1}}],["无匹配",{"2":{"41":1}}],["无序容器是非常有用的",{"2":{"24":1}}],["无序容器不是使用比较运算符来组织元素",{"2":{"24":1}}],["无序容器",{"0":{"24":1}}],["普通的成员只能通过对象",{"2":{"249":1}}],["普通的表达式",{"2":{"135":1}}],["普通的",{"2":{"33":1}}],["允许从一个相容的序列中赋值",{"2":{"315":1}}],["允许将指向非常量类型的指针转换成底层const版本的指针",{"2":{"275":1}}],["允许将const",{"2":{"76":1}}],["允许派生类从它的一个或几个基类中继承构造函数",{"2":{"215":1}}],["允许改变p2的值",{"2":{"78":1}}],["允许对指针赋值和拷贝",{"2":{"73":1}}],["允许在内层作用域中重新定义外层作用域已有的名字",{"2":{"70":1}}],["允许我们把简单的if",{"2":{"269":1}}],["允许我们提供自己定义的操作来替代默认运算符",{"2":{"190":1}}],["允许我们使用自定义的操作来代替默认的运算符",{"2":{"185":1}}],["允许我们写出更为复杂的执行路径",{"2":{"111":1}}],["允许我们将分配和初始化分离",{"2":{"58":1}}],["允许我们定义若干具有相同名字的函数",{"2":{"33":1}}],["允许函数改变一个或多个实参的值",{"2":{"32":1}}],["错误",{"2":{"33":1,"41":1,"54":1,"73":1,"76":1,"82":2,"83":2,"88":1,"96":1,"131":2,"150":1,"168":1,"172":1,"173":1,"176":1,"178":1,"215":1,"230":1,"266":1,"279":1,"291":2,"303":1}}],["忽略形参的顶层const可能产生意想不到的结果",{"2":{"33":1}}],["也都提供下标运算符",{"2":{"320":1}}],["也要拷贝和移动基类部分的成员",{"2":{"308":1}}],["也要在参数列表后加const",{"2":{"238":1}}],["也将被添加到候选函数集当中",{"2":{"213":1}}],["也将拥有一个不确定的值",{"2":{"73":1}}],["也进行正常的类型转换",{"2":{"173":1}}],["也有很多程序员需要不同范围的随机数",{"2":{"158":1}}],["也有拷贝构造函数",{"2":{"132":1}}],["也没有形参",{"2":{"150":1}}],["也不接受参数",{"2":{"122":1}}],["也不能定义成员函数",{"2":{"233":1}}],["也不能作为基类使用",{"2":{"233":1}}],["也不能以下画线紧连大写字母开头",{"2":{"69":1}}],["也不能代替程序本身应该包含的错误检查",{"2":{"46":1}}],["也叫循环体",{"2":{"112":1}}],["也叫容器",{"2":{"93":1}}],["也会自动将其转换成指向数组首元素的指针",{"2":{"105":1}}],["也是一种字符数组",{"2":{"104":1}}],["也支持==和",{"2":{"99":1}}],["也可能是派生类的对象",{"2":{"300":1}}],["也可能是为已经存在的命名空间添加一些新成员",{"2":{"210":1}}],["也可能执行某个派生类的版本",{"2":{"298":1}}],["也可能位于直接或间接调用了发生异常的函数的另一个函数中",{"2":{"206":1}}],["也可能生成垃圾数据",{"2":{"64":1}}],["也可以把类",{"2":{"248":1}}],["也可以定义在类的外部",{"2":{"238":1}}],["也可以定义在其他命名空间中",{"2":{"210":1}}],["也可以是无符号的",{"2":{"270":1}}],["也可以是指针",{"2":{"231":1}}],["也可以是重载的",{"2":{"41":1}}],["也可以通过指针调用",{"2":{"231":1}}],["也可以通过对象的指针或引用调用析构函数",{"2":{"223":1}}],["也可以将它们定义为成员函数",{"2":{"222":1}}],["也可以将其归还给系统",{"2":{"60":1}}],["也可以直接继承某个基类",{"2":{"218":1}}],["也可以不是",{"2":{"176":1}}],["也可以只授权给特定实例",{"2":{"167":1}}],["也可以在外部定义成员函数",{"2":{"167":1}}],["也可以生成不同的序列",{"2":{"159":1}}],["也可以为每个成员提供一个初始值",{"2":{"153":1}}],["也可以为每个成员提供初始化器",{"2":{"17":1}}],["也可以使用ndebug编写自己的调试代码",{"2":{"46":1}}],["也可以省略该实参",{"2":{"44":1}}],["也可以指向一个空字符串",{"2":{"35":1}}],["也可以向string写数据",{"2":{"9":1}}],["也就是说",{"2":{"264":1}}],["也就是上述情况之外的其他值",{"2":{"73":1}}],["也就是一个指向数组的指针",{"2":{"34":1}}],["也就是绑定到数组上",{"2":{"34":1}}],["也就是修改了其引用的对象",{"2":{"32":1}}],["然而这么做并非必须",{"2":{"301":1}}],["然而如果对象是一个常量",{"2":{"276":1}}],["然而",{"2":{"148":1,"303":1,"319":1}}],["然而有时函数需要同时返回多个值",{"2":{"32":1}}],["然后按照声明的顺序依次初始化派生类的成员",{"2":{"299":1}}],["然后重新创建它",{"2":{"291":1}}],["然后再检查条件",{"2":{"283":1}}],["然后根据这个值从几条执行路径中选择一条",{"2":{"280":1}}],["然后根据比较的结果决定到底调用哪个函数",{"2":{"41":1}}],["然后将求值结果丢弃掉",{"2":{"272":1}}],["然后将经过移动的",{"2":{"270":1}}],["然后将改变后的对象作为求值结果",{"2":{"267":1}}],["然后才轮到成员函数体",{"2":{"238":1}}],["然后我们调用析构函数",{"2":{"223":1}}],["然后由new表达式负责在指定的地址初始化对象以完成整个工作",{"2":{"223":1}}],["然后在得到的内存空间中构造对象",{"2":{"222":1}}],["然后在运行时再利用vector的成员函数push",{"2":{"95":1}}],["然后构造第三个直接基类endangered",{"2":{"219":1}}],["然后构造raccoon部分",{"2":{"219":1}}],["然后通过另一个基类再一次间接继承该类",{"2":{"218":1}}],["然后初始化panda的第二个直接基类endangered",{"2":{"215":1}}],["然后解决该问题的任务传递给程序的另一部分",{"2":{"205":1}}],["然后用剩余实参调用自身",{"2":{"181":1}}],["然后用迭代器来遍历容器",{"2":{"19":1}}],["然后执行整数的加法",{"2":{"150":1}}],["然后调用operator",{"2":{"222":1}}],["然后调用赋值运算符",{"2":{"150":1}}],["然后调用了shorterstring函数的const版本",{"2":{"41":1}}],["然后返回该实参的绝对值",{"2":{"145":1}}],["然后销毁成员",{"2":{"122":1}}],["然后是基类的析构函数",{"2":{"308":1}}],["然后是乘法和除法",{"2":{"264":1}}],["然后是第二条",{"2":{"111":1}}],["然后是倒数第二个",{"2":{"59":1}}],["然后从候选函数中选出能被这组实参调用的函数",{"2":{"47":1}}],["然后刷新缓冲区",{"2":{"5":1}}],["然后转换字符串为数字",{"2":{"4":1}}],["甚至有的类型根本就不支持拷贝操作",{"2":{"32":1}}],["通用版本的sort要求随机访问迭代器",{"2":{"203":1}}],["通用定义可能编译失败或做的不正确",{"2":{"183":1}}],["通用模板的定义对特定类型是不合适的",{"2":{"183":1}}],["通用和特定的模板友好关系",{"2":{"167":1}}],["通知的方法是在构造函数中指明noexcept",{"2":{"132":1}}],["通过作用域运算符来使用隐藏的成员",{"2":{"304":1}}],["通过在类的内部使用using声明语句",{"2":{"303":1}}],["通过在函数体的位置",{"2":{"302":1}}],["通过using声明可以达到这一目的",{"2":{"303":1}}],["通过继承",{"2":{"297":1}}],["通过数据抽象",{"2":{"297":1}}],["通过抽象数据类型",{"2":{"237":1}}],["通过异常对象初始化异常声明中的参数",{"2":{"207":1}}],["通过使用块把变量定义在块内",{"2":{"282":1}}],["通过使用标准库功能mem",{"2":{"231":1}}],["通过使用流迭代器",{"2":{"197":1}}],["通过使用引用形参",{"2":{"32":1}}],["通过返回类型上的引用折叠",{"2":{"178":1}}],["通过将一个函数参数定义为一个指向模板类型参数的右值引用",{"2":{"178":1}}],["通过将声明符写成",{"2":{"72":1}}],["通过flip1调用f不会改变j",{"2":{"178":1}}],["通过引用折叠",{"2":{"177":1}}],["通过对流使用boolalpha操纵符来修改原有格式",{"2":{"161":1}}],["通过定义类型转换运算符可以做到这一点",{"2":{"149":1}}],["通过定义一个类",{"2":{"116":1}}],["通过值捕获的变量被拷贝到lambda中",{"2":{"146":1}}],["通过添加一些前缀和后缀",{"2":{"65":1}}],["通过类类型转换实现的匹配",{"2":{"48":1}}],["通过类型提升实现的匹配",{"2":{"48":1}}],["通过算数类型转换或指针转换实现的匹配",{"2":{"48":1}}],["通过const转换实现的匹配",{"2":{"48":1}}],["通常被称为begin和end",{"2":{"313":1}}],["通常被称为关联数组",{"2":{"13":1}}],["通常放在类的开头位置",{"2":{"245":1}}],["通常需要重新编写该程序",{"2":{"235":1}}],["通常与重新抛出语句一起使用",{"2":{"207":1}}],["通常可以用函数来代替它",{"2":{"194":1}}],["通常可以使用istringstream",{"2":{"10":1}}],["通常应该定义一个函数",{"2":{"194":1}}],["通常应该是普通的非成员函数",{"2":{"135":1}}],["通常应该是成员",{"2":{"135":1}}],["通常我们不能将一个右值引用绑定到一个左值上",{"2":{"176":1}}],["通常改变后的状态对所有后续io都生效",{"2":{"161":1}}],["通常用于概述算法",{"2":{"110":1}}],["通常用来指出错误类型",{"2":{"107":1}}],["通常是",{"2":{"109":1}}],["通常将其定义为size",{"2":{"102":1}}],["通常情况下",{"2":{"67":1,"137":1,"138":1,"139":1,"231":1}}],["通常称其为引用计数",{"2":{"52":1}}],["通常就是将它在每个调用点上",{"2":{"45":1}}],["通常",{"2":{"25":1,"73":1,"122":1,"126":1,"137":1,"166":1,"185":1,"258":1,"311":1}}],["通常读取一个字符串",{"2":{"4":1}}],["熟悉c的程序员常常使用指针类型的形参访问函数外部的对象",{"2":{"31":1}}],["所绑定对象的真实类型",{"2":{"300":1}}],["所属的命名空间中搜寻候选函数",{"2":{"213":1}}],["所谓空块",{"2":{"278":1}}],["所谓不能依赖",{"2":{"240":1}}],["所谓不可移植的特性是指因机器而异的特性",{"2":{"235":1}}],["所谓语句块",{"2":{"112":1}}],["所谓条件就是一个产生真或假的结果的表达式",{"2":{"112":1}}],["所谓预处理宏其实是一个预处理变量",{"2":{"46":1}}],["所指的元素",{"2":{"103":1}}],["所指的对象",{"2":{"73":1}}],["所指向的对象",{"2":{"51":1}}],["所有顺序容器都提供了快速顺序访问元素的能力",{"2":{"311":1}}],["所有运算对象最终会转换成同一类型",{"2":{"264":1}}],["所有成员都是public的",{"2":{"256":1}}],["所有成员都可以被考虑",{"2":{"250":1}}],["所有别名都与命名空间原来的名字等价",{"2":{"211":1}}],["所有实参必须具有相容的类型",{"2":{"181":1}}],["所有迭代器操作都不会生成元素",{"2":{"174":1}}],["所有五个拷贝控制成员应该看作一个整体",{"2":{"132":1}}],["所有的标准库容器的迭代器都支持递增运算",{"2":{"99":1}}],["所有元素将执行值初始化",{"2":{"94":1}}],["所有指针的类型都要和它所指的对象严格匹配",{"2":{"73":1}}],["所有输出操作后都会立即刷新缓冲区",{"2":{"5":1}}],["所占比特数",{"2":{"63":1}}],["所以派生类才能像使用自己的成员一样使用基类的成员",{"2":{"304":1}}],["所以继承而来的成员size和n默认情况下是derived的私有成员",{"2":{"303":1}}],["所以一旦转换过程出现问题",{"2":{"276":1}}],["所以一开始函数并不知道数组的确切尺寸",{"2":{"34":1}}],["所以要向上面那样加上括号",{"2":{"268":1}}],["所以要让初始值列表中的成员顺序与定义顺序一致",{"2":{"252":1}}],["所以结果无法预知",{"2":{"263":1}}],["所以成员函数的复杂性不可能太高",{"2":{"234":1}}],["所以我们通常不能直接获得数据成员的指针",{"2":{"229":1}}],["所以我们说这些对象的行为像函数一样",{"2":{"145":1}}],["所以它没有名字",{"2":{"210":1}}],["所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中",{"2":{"150":1}}],["所以与普通函数相比它们更灵活",{"2":{"145":1}}],["所以形参都是常量的引用",{"2":{"139":1}}],["所以不存在存储引用的数组",{"2":{"101":1}}],["所以不能定义指向引用的指针",{"2":{"73":1}}],["所以在union中不能含有虚函数",{"2":{"233":1}}],["所以在panda中只有一个zooanimal基类部分",{"2":{"218":1}}],["所以在需要string对象的地方就可以使用这两种字面值来替代",{"2":{"91":1}}],["所以在上面的代码中传入两个fcn函数的参数可以完全一样",{"2":{"33":1}}],["所以这样的decltype就会得到引用类型",{"2":{"83":1}}],["所以该语句中所有变量的初始基本数据类型都必须一样",{"2":{"82":1}}],["所以const对象必须初始化",{"2":{"75":1}}],["所以把它们都定义在头文件内",{"2":{"45":1}}],["所以函数不能返回数组",{"2":{"40":1}}],["所以通过指针可以修改它所指对象的值",{"2":{"31":1}}],["拷贝一个迭代器范围",{"2":{"314":1}}],["拷贝一个资源会导致一些额外开销",{"2":{"132":1}}],["拷贝和移动构造函数",{"2":{"309":1}}],["拷贝和填充未初始化内存的算法",{"2":{"60":1}}],["拷贝左值",{"2":{"132":1}}],["拷贝并交换",{"2":{"129":1}}],["拷贝",{"0":{"119":1,"241":1},"1":{"120":1,"121":1,"122":1,"123":1,"124":1,"125":1},"2":{"125":1,"133":1,"305":1}}],["拷贝赋值运算符或者析构函数",{"2":{"132":1}}],["拷贝赋值运算符递增右侧运算对象的计数器",{"2":{"128":1}}],["拷贝赋值运算符接受一个与其所在类相同类型的参数",{"2":{"121":1}}],["拷贝赋值运算符",{"0":{"121":1},"2":{"118":1,"126":1}}],["拷贝构造函数递增共享的计数器",{"2":{"128":1}}],["拷贝构造函数不分配新的计数器",{"2":{"128":1}}],["拷贝构造函数",{"0":{"120":1},"2":{"118":1,"120":1,"126":1,"241":1}}],["拷贝初始化不仅在用=定义变量时会发生",{"2":{"120":1}}],["拷贝初始化通常使用拷贝构造函数来完成",{"2":{"120":1}}],["拷贝初始化",{"2":{"90":1,"120":1}}],["拷贝大的类类型对象或者容器对象比较低效",{"2":{"32":1}}],["拷贝之后",{"2":{"31":1}}],["拷贝的是指针的值",{"2":{"31":1}}],["拷贝控制和资源管理",{"0":{"126":1},"1":{"127":1,"128":1}}],["拷贝控制",{"0":{"118":1},"1":{"119":1,"120":1,"121":1,"122":1,"123":1,"124":1,"125":1,"126":1,"127":1,"128":1,"129":1,"130":1,"131":1,"132":1,"133":1},"2":{"0":1}}],["传统for语句我已经比较熟悉了",{"2":{"285":1}}],["传统的for语句",{"0":{"285":1}}],["传统的定义类型别名的方法是使用typedef",{"2":{"81":1}}],["传入const",{"2":{"245":1}}],["传入一个临时的函数对象用于执行两个string对象的>比较运算",{"2":{"147":1}}],["传入非常量的实参将调用非常量的版本",{"2":{"41":1}}],["传递多维数组",{"2":{"34":1}}],["传递给函数的右值引用参数",{"2":{"176":1}}],["传递给一个",{"2":{"176":1}}],["传递给一个const的引用",{"2":{"172":1}}],["传递给os的实参会进行正常的类型转换",{"2":{"172":1}}],["传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值",{"2":{"60":1}}],["传递给它常量对象或者非常量对象都是可以的",{"2":{"33":1}}],["传递给erase一个迭代器或一个迭代器范围来删除一个元素或一个元素范围",{"2":{"21":1}}],["传引用参数",{"0":{"32":1}}],["传值参数",{"0":{"31":1}}],["或将一个对象插入到容器中时",{"2":{"319":1}}],["或无序容器",{"2":{"312":1}}],["或拷贝控制成员",{"2":{"233":1}}],["或嵌套类型",{"2":{"232":1}}],["或==",{"2":{"202":1}}],["或==运算符完成比较",{"2":{"190":1}}],["或=",{"2":{"193":1}}],["或不希望",{"2":{"183":1}}],["或typename",{"2":{"180":1}}],["或指针是一种严重的错误",{"2":{"323":1}}],["或指针",{"2":{"172":2,"300":2}}],["或指向尾元素的下一个位置",{"2":{"97":1}}],["或输出流中",{"2":{"163":1}}],["或是遇到文件尾或输入错误时",{"2":{"156":1}}],["或是遇到不是1或0的字符时",{"2":{"156":1}}],["或是尾后迭代器",{"2":{"99":2}}],["或",{"2":{"133":1,"231":1,"264":1}}],["或遇到一个无效输入时",{"2":{"114":1}}],["或者不想考虑它是否适合作为一个基类",{"2":{"299":1}}],["或者vector或string等类型的对象",{"2":{"286":1}}],["或者说它把它自己的一些职责委托给了其他构造函数",{"2":{"253":1}}],["或者说p是指向变量ival的指针",{"2":{"73":1}}],["或者属于某种未提供默认构造函数的类类型",{"2":{"252":1}}],["或者",{"2":{"230":1}}],["或者对象的数组",{"2":{"222":1}}],["或者operator",{"2":{"222":2}}],["或者一个操作需要很多语句完成",{"2":{"194":1}}],["或者一个返回引用的表达式",{"2":{"176":1}}],["或者其某个成员删除了析构函数",{"2":{"125":1}}],["或者解释晦涩难懂的代码段",{"2":{"110":1}}],["或者从某个元素移动到另外一个元素",{"2":{"98":1}}],["或者它们都是尾后迭代器",{"2":{"98":1}}],["或者是存储于某个固定地址中的对象",{"2":{"79":1}}],["或者赋给另外一个void",{"2":{"73":1}}],["或者将相同的指针值释放多次",{"2":{"53":1}}],["或者能转换成形参的类型",{"2":{"47":1}}],["或者能隐式地转换成函数的返回类型",{"2":{"39":1}}],["或者使用编译器提供的命令行选项定义预处理变量",{"2":{"46":1}}],["或者argv",{"2":{"35":1}}],["或者函数被传引用调用",{"2":{"30":1}}],["或函数被传值调用",{"2":{"30":1}}],["否则是true",{"2":{"275":1}}],["否则是右值",{"2":{"269":1}}],["否则就会产生未定义的行为",{"2":{"270":1}}],["否则就很难读懂了",{"2":{"234":1}}],["否则对expr2求值并返回该值",{"2":{"269":1}}],["否则不用后置版本",{"2":{"267":1}}],["否则表示真",{"2":{"265":1}}],["否则表达式的结果是内层数组",{"2":{"105":1}}],["否则应当使用构造函数初始值列表形式的默认构造函数",{"2":{"240":1}}],["否则转换失败",{"2":{"225":1}}],["否则将会抛出overflow",{"2":{"156":1}}],["否则其行为将异于常态",{"2":{"135":1}}],["否则其行为是未定义的",{"2":{"73":1}}],["否则它会认为移动我们的类对象时可能会抛出异常",{"2":{"132":1}}],["否则算法将使用标准库定义的swap",{"2":{"129":1}}],["否则返回的内容由编译器决定",{"2":{"295":1}}],["否则返回false",{"2":{"227":1,"316":1}}],["否则返回iterator",{"2":{"98":1}}],["否则返回一个空shared",{"2":{"57":1}}],["否则结果为true",{"2":{"64":1}}],["否则",{"2":{"30":1,"39":2,"159":1,"179":1,"181":1,"240":1}}],["否则执行默认初始化",{"2":{"27":1,"240":1}}],["描述了函数的接口",{"2":{"28":1}}],["0>",{"2":{"153":1}}],["00",{"2":{"153":1}}],["001",{"2":{"65":1}}],["0e0",{"2":{"65":1}}],["0x14",{"2":{"65":1}}],["024",{"2":{"65":1}}],["0",{"2":{"27":1,"35":4,"40":1,"44":1,"59":1,"65":2,"67":6,"73":2,"77":1,"78":1,"79":1,"82":3,"83":3,"85":3,"86":3,"88":1,"92":1,"101":1,"105":1,"107":1,"109":5,"145":1,"150":2,"153":1,"156":7,"159":2,"161":1,"166":2,"167":1,"168":2,"193":1,"213":1,"222":1,"230":2,"263":1,"266":1,"279":1,"291":1,"298":2,"299":3,"302":1,"303":2}}],["统计函数被调用了多少次",{"2":{"27":1}}],["就一直存在于程序的整个生命周期中",{"2":{"258":1}}],["就无法继续让返回的对象调用非常量版本的成员函数",{"2":{"246":1}}],["就无法销毁此类对象",{"2":{"125":1}}],["就需要重载函数模板",{"2":{"176":1}}],["就间接创建了一个引用的引用",{"2":{"176":1}}],["就必须在模板名之后跟一个尖括号对",{"2":{"168":1}}],["就必须显式告诉编译器该名字是一个类型",{"2":{"168":1}}],["就像我们能为函数参数提供默认实参一样",{"2":{"168":1}}],["就像内置类型或类类型说明符一样使用",{"2":{"166":1}}],["就像第1章的sales",{"2":{"84":1}}],["就要使用get标准库函数模板",{"2":{"153":1}}],["就不定义这些成员",{"2":{"125":1}}],["就会出现问题",{"2":{"178":1}}],["就会自动调用其析构函数",{"2":{"122":1}}],["就会产生此类错误",{"2":{"102":1}}],["就如对bufsize的定义一样",{"2":{"75":1}}],["就在变量名前添加关键字extern",{"2":{"68":1}}],["就是不可以让编译器生成默认构造函数",{"2":{"240":1}}],["就是一个接受可变数目参数的模板函数或模板类",{"2":{"180":1}}],["就是一个公式",{"2":{"166":1}}],["就是用花括号包围的语句序列",{"2":{"112":1}}],["就是在变量创建的同时为它赋予一个值",{"2":{"109":1}}],["就是将对象从一种给定的类型转换",{"2":{"64":1}}],["就是使用尾置返回类型",{"2":{"40":1}}],["就可以重载",{"2":{"245":1}}],["就可以重新用这部分内存来保存其他string",{"2":{"60":1}}],["就可以省略掉名字前的前缀了",{"2":{"88":1}}],["就可以使用decltype关键字声明返回类型",{"2":{"40":1}}],["就能确保同一函数的所有声明保持一致",{"2":{"28":1}}],["就用这个初始值进行初始化",{"2":{"27":1}}],["就使用此默认模式",{"2":{"8":1}}],["局部类的成员函数一般只有几行代码",{"2":{"234":1}}],["局部类的所有成员",{"2":{"234":1}}],["局部类定义的类型只在定义它的作用域内可见",{"2":{"234":1}}],["局部类",{"0":{"234":1}}],["局部变量不可以作为默认实参",{"2":{"44":1}}],["局部变量的生命周期依赖于定义的方式",{"2":{"27":1}}],["局部静态对象",{"2":{"27":2}}],["局部对象都会被销毁",{"2":{"55":1}}],["局部对象",{"0":{"27":1}}],["此类就没有了默认构造函数",{"2":{"240":1}}],["此类对象在程序启动时被创建",{"2":{"27":1}}],["此参数是一个谓词",{"2":{"191":1}}],["此参数可以与任何类型的实参匹配",{"2":{"177":1}}],["此算法接受三个迭代器",{"2":{"187":1}}],["此模式为print调用生成实参列表",{"2":{"182":1}}],["此调用有歧义",{"2":{"179":1}}],["此值将被转换为unsigned",{"2":{"155":1}}],["此处需要隐式的类型转换",{"2":{"150":1}}],["此处的列表也用来对表示函数返回的临时量进行初始化",{"2":{"39":1}}],["此额外信息是指该function类型能够表示的对象的调用形式",{"2":{"148":1}}],["此例子引入了第二个基本原则",{"2":{"123":1}}],["此指针指向的内存可能被释放两次",{"2":{"123":1}}],["此循环条件检测的是std",{"2":{"114":1}}],["此运算符将给定的值写到给定的ostream对象中",{"2":{"109":1}}],["此对象有两个引用者",{"2":{"52":1}}],["此函数接受第二个参数",{"2":{"196":1}}],["此函数必须在可变参数版本的print定义之前声明",{"2":{"181":1}}],["此函数生成均匀分布的伪随机整数",{"2":{"158":1}}],["此函数在动态内存中分配一个对象并初始化它",{"2":{"52":1}}],["此函数作用于account的引用",{"2":{"41":1}}],["此外",{"2":{"33":1,"69":1,"141":1,"303":1,"307":1}}],["此时定义在内层作用域",{"2":{"304":1}}],["此时基类就将这些函数声明成虚函数",{"2":{"297":1}}],["此时应该使用空语句",{"2":{"278":1}}],["此时应该使用引用形参访问该类型的对象",{"2":{"32":1}}],["此时可以忽略数组的维度",{"2":{"101":1}}],["此时原来的初始化规则仍然适用",{"2":{"82":1}}],["此时assert将执行运行时检查",{"2":{"46":1}}],["此时也将发生错误",{"2":{"41":1}}],["此时编译器将报错",{"2":{"301":1}}],["此时编译器以引用对象的类型作为auto的类型",{"2":{"82":1}}],["此时编译器发出",{"2":{"41":1}}],["此时编译器会一如既往地忽略掉第一个维度",{"2":{"34":1}}],["此时的const是底层的",{"2":{"41":1}}],["此时",{"2":{"26":1,"31":1,"34":1,"44":1,"64":1,"139":1,"217":1,"219":1,"263":1,"266":1,"276":1,"292":1}}],["此容器类型的关键字类型",{"2":{"18":1}}],["一套异常类",{"2":{"292":1}}],["一部分原因是数学性质本身",{"2":{"264":1}}],["一直到using指示所在的作用域结束都能使用",{"2":{"211":1}}],["一直到using声明所在的作用域结束为止",{"2":{"211":1}}],["一条delete表达式的执行过程总是先销毁对象",{"2":{"222":1}}],["一条new表达式的执行过程总是先调用operator",{"2":{"222":1}}],["一条using声明",{"2":{"211":1}}],["一条catch语句通过重新抛出",{"2":{"207":1}}],["一条表达式来引发",{"2":{"206":1}}],["一元运算符的优先级最高",{"2":{"264":1}}],["一元运算符有一个参数",{"2":{"135":1}}],["一元谓词",{"2":{"191":1}}],["一对一友好关系",{"2":{"167":1}}],["一些操作所有迭代器都支持",{"2":{"200":1}}],["一些算法使用重载形式传递一个谓词",{"2":{"202":1}}],["一些算法将新值赋予序列中的元素",{"2":{"188":1}}],["一些算法只会读取其输入范围内的元素",{"2":{"187":1}}],["一些算法会在需要交换两个元素时调用swap",{"2":{"129":1}}],["一些未格式化io操作一次处理大块数据",{"2":{"162":1}}],["一些程序需要非均匀分布的数",{"2":{"158":1}}],["一些应用需要随机浮点数",{"2":{"158":1}}],["一般情况下",{"2":{"294":1}}],["一般dest被绑定到一个插入迭代器或是一个ostream",{"2":{"201":1}}],["一般被定义成const成员",{"2":{"150":1}}],["一般要返回它的ostream形参",{"2":{"137":1}}],["一般有两种选择",{"2":{"126":1}}],["一般来说",{"2":{"42":1,"63":1,"83":1,"132":2,"166":1,"238":1,"243":1,"262":1,"270":1}}],["一是在基类中该成员的访问说明符",{"2":{"303":1}}],["一是一些类难于",{"2":{"80":1}}],["一是用实参初始化函数对应的形参",{"2":{"26":1}}],["一类是不可打印",{"2":{"65":1}}],["一旦在序列中添加",{"2":{"286":1}}],["一旦语句结束",{"2":{"279":1}}],["一旦定义",{"2":{"258":1}}],["一旦我们定义了一个匿名union",{"2":{"233":1}}],["一旦程序开始执行异常处理代码",{"2":{"206":1}}],["一旦元素的值有所不同",{"2":{"95":1}}],["一旦初始化完成",{"2":{"72":1}}],["一旦声明后",{"2":{"70":1}}],["一旦最后一个指向对象的shared",{"2":{"57":1}}],["一旦一个类需要析构函数",{"2":{"126":1}}],["一旦一个程序用光了它所有可用的内存",{"2":{"53":1}}],["一旦一个shared",{"2":{"52":1}}],["一定不能在遍历vector的时候改变vector对象的大小",{"2":{"95":1}}],["一定有某条路径是不包含递归调用的",{"2":{"39":1}}],["一定要记得可选的实参从argv",{"2":{"35":1}}],["一种是基类希望其派生类进行覆盖的函数",{"2":{"298":1}}],["一种是if语句",{"2":{"280":1}}],["一种是move这种标准库设施",{"2":{"176":1}}],["一种节省空间的类",{"0":{"233":1}}],["一种方法是使用标准库模板function",{"2":{"231":1}}],["一种常见的用法是将其存入一个函数表当中",{"2":{"230":1}}],["一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作",{"2":{"35":1}}],["一种简单的using语句是",{"2":{"194":1}}],["一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器",{"2":{"188":1}}],["一种调用形式对应一个函数类型",{"2":{"148":1}}],["一种类型不仅定义了数据元素的内容",{"2":{"107":1}}],["一种new表达式语法",{"2":{"58":1}}],["一种特殊的返回类型是void",{"2":{"27":1}}],["一个对象",{"2":{"304":1}}],["一个与派生类继承的基类对应的子对象",{"2":{"299":1}}],["一个与赋值号右侧值相等的元素被添加到容器中",{"2":{"188":1}}],["一个包含派生类自己定义的",{"2":{"299":1}}],["一个派生类对象包含多个组成部分",{"2":{"299":1}}],["一个简要的例子",{"2":{"294":1}}],["一个简单的确保资源被释放的方法是使用智能指针",{"2":{"55":1}}],["一个好的办法是",{"2":{"282":1}}],["一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中",{"2":{"127":1}}],["一个块就是一个作用域",{"2":{"278":1}}],["一个命名的强制类型转换有如下形式",{"2":{"276":1}}],["一个命名空间可以有好几个同义词或别名",{"2":{"211":1}}],["一个命名空间的定义包含两部分",{"2":{"210":1}}],["一个提升例子就是",{"2":{"270":1}}],["一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程",{"2":{"253":1}}],["一个解决的办法就是重载一个非常量版本的接口",{"2":{"246":1}}],["一个union可以有多个数据成员",{"2":{"233":1}}],["一个panda对象的初始化顺序如下",{"2":{"215":1}}],["一个pair保存两个数据成员",{"2":{"17":1}}],["一个endangered部分以及在panda中声明的非静态数据成员",{"2":{"215":1}}],["一个重新抛出语句并不指定新的表达式",{"2":{"207":1}}],["一个单独的catch语句不能完整地处理某个异常",{"2":{"207":1}}],["一个异常如果没有被捕获",{"2":{"206":1}}],["一个异常",{"2":{"206":1}}],["一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速",{"2":{"203":1}}],["一个高层类别的迭代器支持低层类别迭代器的所有操作",{"2":{"200":1}}],["一个参数列表和一个函数体",{"2":{"192":1}}],["一个lambda表达式具有如下形式",{"2":{"192":1}}],["一个lambda表达式具有一个返回类型",{"2":{"192":1}}],["一个lambda表达式表示一个可调用的代码单元",{"2":{"192":1}}],["一个特例化版本就是模板的一个独立的定义",{"2":{"183":1}}],["一个特定版本的函数",{"2":{"166":1}}],["一个可变参数模板",{"2":{"180":1}}],["一个const成员函数如果以引用的形式返回",{"2":{"246":1}}],["一个const",{"2":{"176":1}}],["一个constexpr指针的初始值必须是nullptr或者0",{"2":{"79":1}}],["一个变量",{"2":{"176":1}}],["一个数组实参可以转换为一个指向其首元素的指针",{"2":{"172":1}}],["一个显式实例化有如下形式",{"2":{"170":1}}],["一个模板类型参数可以用作多个函数形参的类型",{"2":{"172":1}}],["一个模板参数的名字没有什么内在的含义",{"2":{"168":1}}],["一个模板声明包括模板参数列表",{"2":{"167":1}}],["一个static成员函数只有在使用时才会实例化",{"2":{"167":1}}],["一个set中的关键字也是const的",{"2":{"19":1}}],["一个非类型参数表示一个值而非一个类型",{"2":{"166":1}}],["一个操纵符是一个函数或是一个对象",{"2":{"161":1}}],["一个输出元素的宽度等",{"2":{"161":1}}],["一个函数实参可以转换为一个该函数类型的指针",{"2":{"172":1}}],["一个函数模板可能像下面这样",{"2":{"166":1}}],["一个函数模板",{"2":{"166":1}}],["一个函数如果定义了局部的随机数发生器",{"2":{"159":1}}],["一个函数只能返回一个值",{"2":{"32":1}}],["一个版本有一个右值引用参数",{"2":{"133":1}}],["一个将要销毁的对象",{"2":{"131":1}}],["一个基本原则是首先确定这个类是否需要一个析构函数",{"2":{"123":1}}],["一个类也只继承其直接基类的构造函数",{"2":{"309":1}}],["一个类只初始化它的直接基类",{"2":{"309":1}}],["一个类只能有一个析构函数",{"2":{"122":1}}],["一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员",{"2":{"303":1}}],["一个类就是一个作用域",{"2":{"249":1}}],["一个类可以有多个虚基类",{"2":{"219":1}}],["一个类可以定义在另一个类的内部",{"2":{"232":1}}],["一个类可以定义多个不同版本的调用运算符",{"2":{"145":1}}],["一个类可以定义很多种初始化对象的方式",{"2":{"90":1}}],["一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表",{"2":{"180":1}}],["一个类",{"2":{"169":1}}],["一个类模板的每个实例都形成一个独立的类",{"2":{"167":1}}],["一个类通过定义五种特殊的成员函数来控制这些操作",{"2":{"118":1}}],["一个类定义了一个类型",{"2":{"116":1}}],["一个循环条件",{"2":{"113":1}}],["一个初始化语句",{"2":{"113":1}}],["一个注释不能嵌套在另一个注释之内",{"2":{"110":1}}],["一个表达式",{"2":{"278":1}}],["一个表达式接一个分号就是一条语句",{"2":{"109":1}}],["一个表达式产生一个计算结果",{"2":{"109":1}}],["一个运算符组成",{"2":{"109":1}}],["一个使用io库的程序",{"2":{"109":1}}],["一个流就是一个字符序列",{"2":{"109":1}}],["一个流一旦发生错误",{"2":{"4":1}}],["一个文件如果想使用别处定义的名字则必须包含对那个名字的声明",{"2":{"68":1}}],["一个未被初始化的内置类型变量的值是未定义的",{"2":{"67":1}}],["一个形如42的值被称作字面值常量",{"2":{"65":1}}],["一个用来初始化智能指针的普通指针必须指向动态内存",{"2":{"54":1}}],["一个动态分配的const对象必须进行初始化",{"2":{"53":1}}],["一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来",{"2":{"41":1}}],["一个例子",{"2":{"27":1}}],["一个典型的函数",{"2":{"26":1}}],["一个map的value",{"2":{"19":1}}],["一个map或set中的关键字必须是唯一的",{"2":{"15":1}}],["一个io错误的例子",{"2":{"4":1}}],["圆括号内是一个用逗号隔开的实参列表",{"2":{"26":1}}],["由元素的下标来计算其地址是非常快速的",{"2":{"311":1}}],["由panda的构造函数独自控制zooanimal的初始化过程",{"2":{"219":1}}],["由vector生成的类型必须包含元素的类型",{"2":{"93":1}}],["由val1和val2相加的结果可以推断出item的类型",{"2":{"82":1}}],["由符号",{"2":{"73":1}}],["由字母",{"2":{"69":1}}],["由单引号括起来的一个字符称为char型字面值",{"2":{"65":1}}],["由0个或多个形参",{"2":{"26":1}}],["由于元素是连续存储的",{"2":{"311":1}}],["由于一个multi容器中的关键字不必唯一",{"2":{"20":1}}],["由于map和set包含不重复的关键字",{"2":{"20":1}}],["由于不能拷贝io对象",{"2":{"3":1}}],["返回容器中元素的数目",{"2":{"316":1}}],["返回值是一个指向c风格字符串的异常说明",{"2":{"295":1}}],["返回值0表明成功",{"2":{"107":1}}],["返回引用的函数是左值的",{"2":{"246":1}}],["返回",{"0":{"246":1},"2":{"246":1,"327":1}}],["返回type",{"2":{"178":1}}],["返回trans类型对象中成员的数量",{"2":{"153":1}}],["返回true",{"2":{"91":1,"96":1,"227":1}}],["返回序列中一个元素的拷贝",{"2":{"174":1}}],["返回序列中一个元素的引用",{"2":{"174":2}}],["返回false",{"2":{"156":1}}],["返回1",{"2":{"156":1}}],["返回32",{"2":{"156":1}}],["返回3",{"2":{"153":1}}],["返回item的第二个成员",{"2":{"153":1}}],["返回item的第一个成员",{"2":{"153":1}}],["返回is",{"2":{"91":2,"162":3}}],["返回的是对象本身而非对象的副本",{"2":{"246":1}}],["返回的形式是一个值而非引用",{"2":{"143":1}}],["返回的值由函数的返回类型决定",{"2":{"39":1}}],["返回的值用于初始化调用点的一个临时量",{"2":{"39":1}}],["返回某个给定流的引用",{"2":{"138":1}}],["返回const",{"2":{"98":1}}],["返回迭代器所指对象的引用",{"2":{"98":1}}],["返回v中第n个位置上元素的引用",{"2":{"96":1}}],["返回v中的元素个数",{"2":{"96":1}}],["返回void的函数不要求非得有return语句",{"2":{"38":1}}],["返回s1和s2连接后的结果",{"2":{"91":1}}],["返回s中第n个字符的引用",{"2":{"91":1}}],["返回s中的字符数",{"2":{"91":1}}],["返回os",{"2":{"91":1,"162":1}}],["返回指向分配空间的指针或者返回0以表示分配失败",{"2":{"222":1}}],["返回指向此对象的shared",{"2":{"52":1}}],["返回指针",{"2":{"59":1}}],["返回较短的那个引用",{"2":{"41":1}}],["返回一个",{"2":{"325":2}}],["返回一个大于或等于该容器所能容纳的最大元素数的值",{"2":{"316":1}}],["返回一个bool值",{"2":{"227":1,"231":1}}],["返回一个c风格字符串",{"2":{"227":1}}],["返回一个指向该对象的指针",{"2":{"222":1}}],["返回一个指针",{"2":{"40":2}}],["返回一个常量表达式",{"2":{"180":1}}],["返回一个输入流中",{"2":{"163":1}}],["返回一个int的可调用对象",{"2":{"148":1}}],["返回一个值的方式和初始化一个变量或形参的方式完全一样",{"2":{"39":1}}],["返回数组的指针",{"0":{"40":1}}],["返回类型也必须与基类函数匹配",{"2":{"301":1}}],["返回类型是一个指向左值引用类型的右值引用",{"2":{"178":1}}],["返回类型就是decltype",{"2":{"174":1}}],["返回类型之前",{"2":{"166":1}}],["返回类型不同的函数",{"2":{"41":1}}],["返回类型和return语句",{"0":{"37":1},"1":{"38":1,"39":1,"40":1}}],["返回类型",{"2":{"26":1,"28":1}}],["返回实际删除的元素的数量",{"2":{"21":1}}],["在",{"2":{"326":1}}],["在运行时可以动态添加或删除元素来改变容器大小",{"2":{"319":1}}],["在运行时比较两个对象的类型",{"2":{"226":1}}],["在deque的两端添加或删除元素都是很快的",{"2":{"311":1}}],["在deque的中间位置插入或删除元素的代价",{"2":{"311":1}}],["在bulk",{"2":{"309":1}}],["在blob中声明友元所需要的",{"2":{"167":1}}],["在析构函数体执行完成后",{"2":{"308":1}}],["在析构函数中释放动态内存",{"2":{"123":1}}],["在构造函数和析构函数中调用虚函数无法完成动态绑定",{"2":{"301":1}}],["在它之前有一个标示符以及一个冒号",{"2":{"291":1}}],["在范围for语句中",{"2":{"286":1}}],["在switch内部定义变量",{"2":{"282":1}}],["在循环外部无法访问",{"2":{"279":1}}],["在早期版本的c++语言中",{"2":{"276":1}}],["在赋值语句中",{"2":{"273":1}}],["在赋值运算符中使用swap",{"2":{"129":1}}],["在条件中",{"2":{"273":1}}],["在下面这些情况下",{"2":{"273":1}}],["在下列情况下也会发生",{"2":{"120":1}}],["在左侧插入符号位的副本或值为0的二进制位",{"2":{"270":1}}],["在左侧插入值为0的二进制位",{"2":{"270":1}}],["在右侧插入值为0的二进制位",{"2":{"270":1}}],["在表达式求值之前",{"2":{"264":1}}],["在表达式的其他地方不要再使用这个运算对象",{"2":{"263":1}}],["在声明前加static关键字",{"2":{"258":1}}],["在类的外围作用域中查找",{"2":{"250":1}}],["在类内查找",{"2":{"250":1}}],["在类模板的定义中",{"2":{"167":1}}],["在块内查找声明",{"2":{"250":1}}],["在块作用域内定义的指针如果没有被初始化",{"2":{"73":1}}],["在没有定义前是一个不完全类型",{"2":{"247":1}}],["在成员函数内部",{"2":{"238":1}}],["在成员函数和指针之间不存在自动转换规则",{"2":{"230":1}}],["在成员函数和指向该成员的指针之间不存在自动转换规则",{"2":{"230":1}}],["在第二章自定义的sales",{"2":{"237":1}}],["在实际编程中",{"2":{"234":1}}],["在实践中",{"2":{"150":1}}],["在外层类之外定义一个嵌套类",{"2":{"232":1}}],["在外层类作用域之外不可见",{"2":{"232":1}}],["在可能的情况下",{"2":{"224":1}}],["在虚派生中",{"2":{"219":1}}],["在派生类中都只包含唯一一个共享的虚基类子对象",{"2":{"218":1}}],["在派生类的派生列表中可以包含多个基类",{"2":{"215":1}}],["在默认情况下",{"2":{"218":1}}],["在只有一个基类的情况下",{"2":{"216":1,"217":1}}],["在合成的拷贝控制成员中",{"2":{"215":1}}],["在我们的例子中",{"2":{"215":1}}],["在我的gcc",{"2":{"67":1}}],["在panda对象中含有一个bear部分",{"2":{"215":1}}],["在多重继承的情况下",{"2":{"217":1}}],["在多重继承关系中",{"2":{"215":1}}],["在多个文件中实例化相同模板的额外开销可能非常严重",{"2":{"170":1}}],["在执行了某些校正操作之后",{"2":{"207":1}}],["在搜寻catch语句的过程中",{"2":{"207":1}}],["在独立开发的子系统之间协同处理错误的能力",{"2":{"204":1}}],["在it指定的当前位置插入值t",{"2":{"196":1}}],["在if中",{"2":{"57":1}}],["在函数参数列表中",{"2":{"180":1}}],["在函数的参数列表后接=delete来通知编译器",{"2":{"125":1}}],["在函数的很多次调用中它们都被赋予一个相同的值",{"2":{"44":1}}],["在调用中使用std",{"2":{"178":1}}],["在返回类型和类型转换中也要用到typename",{"2":{"177":1}}],["在每个调用中",{"2":{"176":1}}],["在编译时进行名字查找",{"2":{"304":1}}],["在编译时就能得到计算",{"2":{"79":1}}],["在编译器遇到函数的参数列表之前",{"2":{"174":1}}],["在某些情况下",{"2":{"173":1,"183":1,"301":1}}],["在其他类型转换中",{"2":{"172":1}}],["在其中间添加或删除元素就会非常耗时",{"2":{"311":1}}],["在其中一个或多个模板参数被指定为特定的类型",{"2":{"183":1}}],["在其中名字有其特定的含义",{"2":{"70":1}}],["在其中指明要分配的对象的数目",{"2":{"59":1}}],["在创建时就必须指定好",{"2":{"170":1}}],["在大多数用到数组的表达式中",{"2":{"275":1}}],["在大多数表达式中",{"2":{"273":1}}],["在大多数情况下",{"2":{"263":1}}],["在大多数系统中",{"2":{"163":1}}],["在大系统中",{"2":{"170":1}}],["在模版内不能重用模版参数名",{"2":{"168":1}}],["在模板实参推断过程中",{"2":{"171":1}}],["在模板参数列表中",{"2":{"166":1}}],["在模板定义中",{"2":{"166":1}}],["在将模板的一个特定实例声明为友元时要用到",{"2":{"167":1}}],["在case分支后面定义并初始化一个变量很可能是不合法的",{"2":{"282":1}}],["在case分支下",{"2":{"282":1}}],["在compare中",{"2":{"166":1}}],["在c++11新标准中我们可以使用override关键字来说明派生类中的虚函数",{"2":{"301":1}}],["在c++11新标准中",{"2":{"208":1,"215":1,"309":1}}],["在c++中",{"2":{"109":1,"116":1}}],["在c++语言中我们通过虚继承",{"2":{"218":1}}],["在c++语言中",{"2":{"27":1,"31":1,"206":1,"292":1,"298":1}}],["在263页中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换",{"2":{"149":1}}],["在算法中使用标准库函数对象",{"2":{"147":1}}],["在算术表达式中不要使用char或bool",{"2":{"63":1}}],["在lambda表达式产生的类中含有一个重载的函数调用运算符",{"2":{"146":1}}],["在迭代器类及智能指针类中常常用到解引用运算符和箭头运算符",{"2":{"144":1}}],["在迭代器类中通常会实现递增运算符++和递减运算符",{"2":{"143":1}}],["在参数列表后放置一个引用限定符",{"2":{"133":1}}],["在移动操作之后",{"2":{"132":1}}],["在很多情况下",{"2":{"130":1}}],["在很多用到数组名字的地方",{"2":{"103":1}}],["在新标准中",{"2":{"170":1}}],["在新标准出现之前",{"2":{"158":1}}],["在新标准发布之前",{"2":{"125":1}}],["在新标准下",{"2":{"125":1}}],["在一条语句中混用解引用和递增运算符",{"2":{"267":1}}],["在一些情况下",{"2":{"174":1}}],["在一个模板参数列表中",{"2":{"180":1}}],["在一个输入流或输出流中",{"2":{"163":1}}],["在一个输入流或输出流中奖标记重定位到给定的绝对地址",{"2":{"163":1}}],["在一个析构函数中",{"2":{"122":1}}],["在一个构造函数中",{"2":{"122":1}}],["在一起",{"2":{"72":1}}],["在任何要求使用语句的地方都可以使用语句块",{"2":{"112":1}}],["在书本p82有cctype头文件中的函数说明",{"2":{"92":1}}],["在此过程中",{"2":{"83":1,"211":1}}],["在此情况下",{"2":{"60":1,"178":2}}],["在同一条定义语句中",{"2":{"74":1}}],["在花括号内定义的变量拥有块作用域",{"2":{"70":1}}],["在gcc上测试",{"2":{"63":1}}],["在不同机器上有所差别",{"2":{"63":1}}],["在内的基本数据类型",{"2":{"62":1}}],["在指针前加上一个空方括号对",{"2":{"59":1}}],["在退出以前释放内存",{"2":{"55":1}}],["在动态内存使用完毕后",{"2":{"53":1}}],["在动态内存中为对象分配空间并返回一个指向该对象的指针",{"2":{"51":1}}],["在自由空间分配的内存是无名的",{"2":{"53":1}}],["在程序中某些实体只能定义一次",{"2":{"210":1}}],["在程序中某个位置必须有其显式的实例化定义",{"2":{"170":1}}],["在程序结束时销毁",{"2":{"50":1}}],["在程序的执行路径第一次经过对象定义语句时初始化",{"2":{"27":1}}],["在这个作用域内我们定义类的成员",{"2":{"304":1}}],["在这个过程中我们把函数调用与一组重载函数中的某一个关联起来",{"2":{"41":1}}],["在这种机制下",{"2":{"218":1}}],["在这种拷贝并非必要的情况下",{"2":{"132":1}}],["在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中",{"2":{"213":1}}],["在这些类型上调用insert总会插入一个元素",{"2":{"20":1}}],["在这一过程中",{"2":{"47":1}}],["在递归函数中",{"2":{"39":1}}],["在源文件中定义",{"2":{"28":1}}],["在头文件中进行函数声明",{"2":{"28":1}}],["在所有函数体之外定义的对象存在于程序的整个执行过程中",{"2":{"27":1}}],["在关键字类型的元素没有明显的序关系的情况下",{"2":{"24":1}}],["而基类的成员访问说明符限制了基类用户的访问权限",{"2":{"303":1}}],["而后续的其他类可以覆盖该接口",{"2":{"302":1}}],["而每个派生类定义各自特有的成员",{"2":{"297":1}}],["而每个变量都拥有自己的类型",{"2":{"107":1}}],["而以统一的方式使用它们的对象",{"2":{"297":1}}],["而以一个新值替代",{"2":{"67":1}}],["而信号的发出方无须知道故障将在何处得到解决",{"2":{"292":1}}],["而另一个分支却访问了此变量",{"2":{"282":1}}],["而另一个版本有一个const左值引用",{"2":{"133":1}}],["而前置版本避免了这个工作",{"2":{"267":1}}],["而与具体对象无关的特殊成员",{"2":{"258":1}}],["而与派生类构造函数初始值列表中基类的顺序无关",{"2":{"215":1}}],["而无须调整用户级别的代码",{"2":{"243":1}}],["而无法遍历一个指针",{"2":{"105":1}}],["而实现细节",{"2":{"242":1}}],["而此类有可能没有默认构造函数",{"2":{"240":1}}],["而对于不限定作用域的枚举类型",{"2":{"228":1}}],["而对于unique",{"2":{"170":1}}],["而当运算对象是定义了至少一个虚函数的类的左值时",{"2":{"226":1}}],["而将继承链最顶端的类",{"2":{"207":1}}],["而该指针实际指向的是派生类对象",{"2":{"206":1}}],["而从不改变元素",{"2":{"187":1}}],["而使用引用参数",{"2":{"178":1}}],["而非其在初始值列表中的顺序",{"2":{"252":1}}],["而非常量版本的接口负责调用它",{"2":{"246":1}}],["而非重载它",{"2":{"183":1}}],["而非int",{"2":{"176":1}}],["而非double",{"2":{"168":1}}],["而非用户的输入",{"2":{"35":1}}],["而普通函数和类的成员函数的定义放在源文件中",{"2":{"166":1}}],["而t表示的实际类型则在编译时根据compare的使用情况来确定",{"2":{"166":1}}],["而p版本表示我们正在写入数据",{"2":{"163":1}}],["而应使用default",{"2":{"158":1}}],["而程序员为了解决这些问题而试图转换rand生成的随机数的范围",{"2":{"158":1}}],["而输出运算符不需要",{"2":{"138":1}}],["而类型转换运算符将smallint对象转换成int",{"2":{"150":1}}],["而类则需要自定义适合其对象的新版本以支持io操作",{"2":{"136":1}}],["而类类型将使用默认构造函数进行初始化",{"2":{"53":1}}],["而拷贝成员必须拷贝此资源",{"2":{"132":1}}],["而右值要么是字面常量",{"2":{"131":1}}],["而it2只能读",{"2":{"98":1}}],["而引用不是对象",{"2":{"93":1}}],["而库类型string",{"2":{"84":1}}],["而decltype",{"2":{"83":1}}],["而不管basep实际指向的对象到底是什么",{"2":{"301":1}}],["而不是定义",{"2":{"166":1}}],["而不是真的要在实现后置版本时参与运算",{"2":{"143":1}}],["而不是分配多一个副本",{"2":{"129":1}}],["而不是拷贝指针",{"2":{"127":1}}],["而不是将初始值拷贝给引用",{"2":{"72":1}}],["而不能与字面值或某个表达式的计算结果绑定在一起",{"2":{"72":1}}],["而定义负责创建与名字关联的实体",{"2":{"68":1}}],["而赋值的含义是把对象当前值擦除",{"2":{"67":1}}],["而必须调用lock",{"2":{"57":1}}],["而具体的讨论见书本p416",{"2":{"55":1}}],["而是强迫执行虚函数的某个特定版本",{"2":{"301":1}}],["而是先根据类型转换规则设法将运算对象的类型统一后再求值",{"2":{"273":1}}],["而是将当前的异常对象沿着调用链向上传递",{"2":{"207":1}}],["而是移动它们",{"2":{"195":1}}],["而是遍历由两个迭代器指定的一个元素范围来进行操作",{"2":{"185":1}}],["而是定义了一组泛型算法",{"2":{"184":1}}],["而是生成一个新的模板实例",{"2":{"172":1}}],["而是拷贝给定对象的数据成员",{"2":{"128":1}}],["而是使用当调用发生时f的返回值的类型作为sum的类型",{"2":{"83":1}}],["而是使用一个哈希函数和关键字类型的==运算符",{"2":{"24":1}}],["而是得到一个数组元素类型的指针",{"2":{"59":1}}],["而是返回一个指向该对象的指针",{"2":{"53":1}}],["而让那些经常使用默认值的形参出现在后面",{"2":{"44":1}}],["而函数重载可以在一定程度上减轻程序员起名字",{"2":{"41":1}}],["而且也能将基类的指针或引用绑定到派生类对象的基类部分上",{"2":{"299":1}}],["而且也应该在bulk",{"2":{"213":1}}],["而且值可以重复",{"2":{"228":1}}],["而且不会对其实参求值",{"2":{"180":1}}],["而且不会带来什么好处",{"2":{"174":1}}],["而且不要显示初始化变量",{"2":{"68":1}}],["而且分布类型不定义成static的",{"2":{"159":1}}],["而且必须严格小于结果的位数",{"2":{"270":1}}],["而且必须定义成类的成员函数",{"2":{"150":1}}],["而且必须用常量表达式初始化",{"2":{"79":1}}],["而且类所在头文件的名字应与类的名字一样",{"2":{"86":1}}],["而且一旦我们想改变函数的接口",{"2":{"28":1}}],["而且",{"2":{"25":1,"60":1,"168":1,"311":1}}],["而其他一些工作是处理行内的单个单词时",{"2":{"10":1}}],["可参阅p142",{"2":{"274":1}}],["可使用容器管理必要的存储空间",{"2":{"241":1}}],["可递增递减",{"2":{"199":1}}],["可读写",{"2":{"199":3}}],["可变lambda",{"2":{"193":1}}],["可变参数版本会无限递归",{"2":{"181":1}}],["可变参数函数通常是递归的",{"2":{"181":1}}],["可变参数函数是很有用的",{"2":{"181":1}}],["可变参数模板",{"0":{"180":1},"1":{"181":1,"182":1}}],["可变数目的参数被称为参数包",{"2":{"180":1}}],["可行函数按类型转换来排序",{"2":{"179":1}}],["可行函数也有两个特征",{"2":{"47":1}}],["可调用对象也有类型",{"2":{"148":1}}],["可调用对象与function",{"0":{"148":1}}],["可执行int加法的函数对象",{"2":{"147":1}}],["可析构的状态",{"2":{"132":1}}],["可由内而外理解",{"2":{"105":1}}],["可用于存放任意对象的地址",{"2":{"73":1}}],["可供程序操作的存储空间",{"2":{"66":1}}],["可能",{"2":{"311":1}}],["可能抛出一个异常的代码",{"2":{"294":1}}],["可能抛出异常",{"2":{"208":1}}],["可能还进行了提升",{"2":{"270":1}}],["可能有多个",{"2":{"240":1}}],["可能有多个extern声明",{"2":{"170":1}}],["可能出现在c++头文件",{"2":{"236":1}}],["可能包含独立开发的库",{"2":{"204":1}}],["可能最常用的方法是调用系统函数time",{"2":{"159":1}}],["可能为空",{"2":{"117":1}}],["可能崩溃",{"2":{"64":1}}],["可能使用find还是count没什么区别",{"2":{"23":1}}],["可选的",{"2":{"35":1}}],["可以给函数一个搜索的起始位置",{"2":{"327":1}}],["可以给类数据成员一个类内初始值",{"2":{"245":1}}],["可以再一次使用virtual关键字指出该函数的性质",{"2":{"301":1}}],["可以再将其转换回普通的const",{"2":{"41":1}}],["可以作为goto的目标",{"2":{"291":1}}],["可以作为unique",{"2":{"170":1}}],["可以暂时声明类而不定义它",{"2":{"247":1}}],["可以在一定程度上忽略相似类型的区别",{"2":{"297":1}}],["可以在if",{"2":{"279":1}}],["可以在类的内部定义一个类型",{"2":{"245":1}}],["可以在未初始化内存中创建对象",{"2":{"60":1}}],["可以省略this来访问成员",{"2":{"238":1}}],["可以来遍历所关联的io流",{"2":{"195":1}}],["可以让编译器根据lambda体中的代码来推断要使用哪些变量",{"2":{"193":1}}],["可以忽略返回类型",{"2":{"192":1}}],["可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义",{"2":{"300":1}}],["可以将其理解为一个未命名的内联函数",{"2":{"192":1}}],["可以将一个非const对象的引用",{"2":{"172":1}}],["可以比较任意两个类型",{"2":{"183":1}}],["可以接受一个右值",{"2":{"176":1}}],["可以传递给它任何类型的实参",{"2":{"176":1}}],["可以传递一个名为initializer",{"2":{"36":1}}],["可以包含本身是模板的成员函数",{"2":{"169":1}}],["可以包含该实参",{"2":{"44":1}}],["可以重写compare",{"2":{"168":1}}],["可以把这些函数放到类的头文件中声明",{"2":{"239":1}}],["可以把函数模板声明成inline或constexpr的",{"2":{"166":1}}],["可以把它定义成const的",{"2":{"77":1}}],["可以通过rbegin",{"2":{"198":1}}],["可以通过提供一个种子",{"2":{"159":1}}],["可以通过两个辅助类模板来查询tuple成员的数量和类型",{"2":{"153":1}}],["可以通过将拷贝构造函数和拷贝赋值运算符定义为",{"2":{"125":1}}],["可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本",{"2":{"124":1}}],["可以直接交换指针",{"2":{"129":1}}],["可以定义相似的类型并对其相似关系建模",{"2":{"297":1}}],["可以定义类或函数模板的一个特例化版本",{"2":{"183":1}}],["可以定义拷贝操作",{"2":{"126":1}}],["可以定义一个文件流对象",{"2":{"7":1}}],["可以这样定义一个数组类型",{"2":{"105":1}}],["可以这样给把函数地址赋值给指针",{"2":{"49":1}}],["可以操作c风格字符串",{"2":{"104":1}}],["可以获取数组首元素的指针和尾后指针",{"2":{"103":1}}],["可以使用resize来增大或缩小容器",{"2":{"322":1}}],["可以使用remove",{"2":{"174":1}}],["可以使用at成员函数",{"2":{"320":1}}],["可以使用后置的递增运算符来控制循环输出一个vector对象内容",{"2":{"267":1}}],["可以使用花括号括起来的成员初始值列表来初始化聚合类对象",{"2":{"256":1}}],["可以使用如下语句返回this对象",{"2":{"238":1}}],["可以使用一个新的名为bind的标准库函数",{"2":{"194":1}}],["可以使用sizeof",{"2":{"180":1}}],["可以使用tuple的默认构造函数",{"2":{"153":1}}],["可以使用引用计数",{"2":{"128":1}}],["可以使用范围for语句来遍历数组",{"2":{"102":1}}],["可以使用直接初始化方式来初始化一个动态分配的对象",{"2":{"53":1}}],["可以为静态成员提供const整数类型的类内初始值",{"2":{"258":1}}],["可以为数据成员提供一个类内初始值",{"2":{"85":1}}],["可以为常量引用绑定字面值",{"2":{"82":1}}],["可以改变整型",{"2":{"65":1}}],["可以分配string的allocator对象",{"2":{"60":1}}],["可以分配并初始化一个对象数组",{"2":{"58":1}}],["可以对数组中的元素进行值初始化",{"2":{"59":1}}],["可以指向一个double的unique",{"2":{"56":1}}],["可以指向string",{"2":{"52":1}}],["可以提供自己的操作来替代delete",{"2":{"54":1}}],["可以简化这种返回类型",{"2":{"40":1}}],["可以用来向容器插入元素",{"2":{"195":1}}],["可以用来表示成功与失败",{"2":{"39":1}}],["可以用于不同类型的元素和多种容器类型",{"2":{"184":1}}],["可以用于函数模板调用的类型转换是非常有限的",{"2":{"179":1}}],["可以用字符串字面值对此类数组进行初始化",{"2":{"101":1}}],["可以用关键字const对变量的类型加以限定",{"2":{"75":1}}],["可以用它传递可变数量的实参",{"2":{"36":1}}],["可以用一个set迭代器来读取元素的值",{"2":{"19":1}}],["可以看出来",{"2":{"34":1}}],["可以帮助我们访问和操纵流的条件状态",{"2":{"4":1}}],["会将新元素添加到容器后部",{"2":{"322":1}}],["会将其参数的成员逐个拷贝到正在创建的对象中",{"2":{"120":1}}],["会执行析构",{"2":{"241":1}}],["会发生对象的赋值操作",{"2":{"241":1}}],["会发生拷贝",{"2":{"241":1}}],["会在输出结果中显示进制",{"2":{"161":1}}],["会影响流的状态",{"2":{"161":1}}],["会使用其拷贝构造函数来拷贝",{"2":{"120":1}}],["会自动销毁其指向的对象",{"2":{"59":1}}],["会产生一个结果",{"2":{"25":1}}],["会得到一个value",{"2":{"22":1}}],["会获得一个mapped",{"2":{"22":1}}],["会为它创建一个元素并插入到map中",{"2":{"22":1}}],["因为元素本身并未交换",{"2":{"315":1}}],["因为此时派生类处于",{"2":{"301":1}}],["因为此分支可能被跳过",{"2":{"282":1}}],["因为一旦某个函数被声明成虚函数",{"2":{"301":1}}],["因为一条声明语句只能有一个基本数据类型",{"2":{"82":1}}],["因为statement无法访问它",{"2":{"287":1}}],["因为它本质上依赖于机器",{"2":{"276":1}}],["因为书中已经有了明晰的介绍",{"2":{"274":1}}],["因为解引用运算符的优先级低于点运算符",{"2":{"268":1}}],["因为本质上",{"2":{"245":1}}],["因为局部类的成员必须完整定义在类的内部",{"2":{"234":1}}],["因为数据成员一般情况下是私有的",{"2":{"229":1}}],["因为数组不能被拷贝",{"2":{"40":1}}],["因为数组是以指针的形式传递给函数的",{"2":{"34":1}}],["因为他们是程序整个处理过程中至关重要的一部分",{"2":{"222":1}}],["因为raccoon和bear继承zooanimal的方式都是虚继承",{"2":{"218":1}}],["因为所有名字都是可见的",{"2":{"211":1}}],["因为保证空间是足够的",{"2":{"201":1}}],["因为模板实参推断会排除任何不可行的模板",{"2":{"179":1}}],["因为在它看来转换到任意一种基类都一样好",{"2":{"216":1}}],["因为在引用类型中的const是底层的",{"2":{"178":1}}],["因为在这类函数的最后一句后面会隐式地执行return",{"2":{"38":1}}],["因为第一位已复位",{"2":{"156":1}}],["因为只有1位置位了",{"2":{"156":1}}],["因为有1位置位了",{"2":{"156":1}}],["因为有1位置位",{"2":{"156":1}}],["因为bool是一种算术类型",{"2":{"150":1}}],["因为可以调用这种对象",{"2":{"145":1}}],["因为这需要移动插入或删除位置之后的所有元素",{"2":{"311":1}}],["因为这种操作对它们没有意义",{"2":{"163":1}}],["因为这样的类同时也能存储状态",{"2":{"145":1}}],["因为这些运算符一般不需要改变运算对象的状态",{"2":{"139":1}}],["因为这些容器中可能有多个值与一个关键字相关联",{"2":{"22":1}}],["因为我们将先读入数据到price",{"2":{"138":1}}],["因为我觉得使用上述别名定义已经能满足这种需求了",{"2":{"49":1}}],["因为若不是引用",{"2":{"105":1}}],["因为const对象一旦创建后其值就不能再改变",{"2":{"75":1}}],["因为char在不同机器上的表现方式不一样",{"2":{"63":1}}],["因为无法令引用重新绑定到另外一个对象",{"2":{"72":1}}],["因为double精度更高",{"2":{"63":1}}],["因为智能指针默认使用delete释放它所关联的对象",{"2":{"54":1}}],["因为顶层const被忽略了",{"2":{"33":1}}],["因为指针使我们可以间接地访问它所指的对象",{"2":{"31":1}}],["因此成员函数体中可以使用类中定义的任何位置的名字",{"2":{"250":1}}],["因此如果函数不修改成员变量",{"2":{"238":1}}],["因此不能通过范围for语句增加vector对象的元素",{"2":{"286":1}}],["因此不能用于list",{"2":{"203":1}}],["因此不是一个抽象数据类型",{"2":{"237":1}}],["因此该调用语句的候选函数不仅应该在调用语句所在的作用域中查找",{"2":{"213":1}}],["因此可以为它定义一个模板特例化",{"2":{"183":1}}],["因此operator",{"2":{"150":1}}],["因此通常不会抛出异常",{"2":{"132":1}}],["因此通常在返回后再把它拷贝到另一个地方",{"2":{"104":1}}],["因此销毁内置类型成员什么也不需要做",{"2":{"122":1}}],["因此它不能被重载",{"2":{"122":1}}],["因此注释对程序的行为和性能不会有任何影响",{"2":{"110":1}}],["因此被称为标准错误",{"2":{"109":1}}],["因此既然vector对象能高效地增长",{"2":{"95":1}}],["因此更常见的情况是",{"2":{"95":1}}],["因此b是一个int",{"2":{"83":1}}],["因此要换一种方法定义常量表达式",{"2":{"79":1}}],["因此引用必须初始化",{"2":{"72":1}}],["因此unique",{"2":{"56":1}}],["因此内存会被释放掉",{"2":{"55":1}}],["因此必须使用直接初始化形式来初始化一个智能指针",{"2":{"54":1}}],["因此new无法为其分配的对象命名",{"2":{"53":1}}],["因此无法找到外层的重载版本",{"2":{"42":1}}],["因此",{"2":{"39":1,"41":1,"65":1,"109":1,"110":1,"114":1,"121":1,"130":1,"131":2,"132":2,"135":1,"146":2,"150":1,"155":1,"166":2,"167":1,"168":1,"176":1,"178":2,"183":1,"203":1,"231":1,"233":1,"267":1,"291":1,"308":1}}],["因此插入一个已存在的元素对容器没有任何影响",{"2":{"20":1}}],["因此这种情况",{"2":{"4":1}}],["因此传递和返回的引用不能是const的",{"2":{"3":1}}],["因此也不能将形参或返回类型设置为流类型",{"2":{"3":1}}],["删除deque中除首尾之外的任何元素都会使所有迭代器",{"2":{"321":1}}],["删除",{"2":{"286":1}}],["删除的函数是这样一种函数",{"2":{"125":1}}],["删除的函数",{"2":{"125":1}}],["删除所有匹配给定关键字的元素",{"2":{"21":1}}],["删除元素之前",{"2":{"321":1}}],["删除元素",{"0":{"21":1,"321":1}}],["添加及删除",{"2":{"318":1}}],["添加const关键字",{"2":{"238":1}}],["添加第二个元素",{"2":{"20":1}}],["添加元素可能导致分配额外的存储空间",{"2":{"311":1}}],["添加元素",{"0":{"20":1}}],["正则表达式库需要高级的gcc版本支持",{"2":{"157":1}}],["正则表达式",{"0":{"157":1},"2":{"157":1}}],["正确",{"2":{"20":1,"34":1,"54":1,"73":1,"76":2,"77":1,"82":2,"83":2,"96":1,"131":3,"150":2,"173":1,"177":2,"276":3,"282":1,"303":1}}],["正常类型转换应用于显式指定的实参",{"2":{"173":1}}],["正常",{"2":{"13":1}}],["遍历关联容器",{"2":{"19":1}}],["必须运行该类型的析构函数",{"2":{"233":1}}],["必须运行该类型的构造函数",{"2":{"233":1}}],["必须清楚地知道当前存储在union中的值到底是什么类型",{"2":{"233":1}}],["必须清楚的一点是",{"2":{"229":1}}],["必须将函数中用于表示执行对象的隐式形参转换成显式的",{"2":{"231":1}}],["必须将其归还给系统",{"2":{"53":1}}],["必须首先",{"2":{"231":1}}],["必须首先利用",{"2":{"231":1}}],["必须显式地使用取地址运算符",{"2":{"230":1}}],["必须自定义一个接受string的构造函数",{"2":{"215":1}}],["必须保证在lambda执行时变量是存在的",{"2":{"193":1}}],["必须注意确保序列原大小至少不小于我们要求算法写入元素数目",{"2":{"188":1}}],["必须注意关于顶层const的讨论",{"2":{"33":1}}],["必须为原模板中的每个模板参数都提供实参",{"2":{"183":1}}],["必须用typename",{"2":{"174":1}}],["必须是成员",{"2":{"135":1}}],["必须是无符号的",{"2":{"103":1}}],["必须确保移后源对象进入一个可析构的状态",{"2":{"132":1}}],["必须先确定类对象的拷贝语义",{"2":{"126":1}}],["必须定义为成员函数",{"2":{"121":1}}],["必须大于0",{"2":{"101":1}}],["必须使用直接初始化语法",{"2":{"153":1}}],["必须使用直接初始化形式",{"2":{"54":1}}],["必须使用完整的名字",{"2":{"88":1}}],["必须初始化",{"2":{"83":2}}],["必须认识到",{"2":{"76":1}}],["必须在使用",{"2":{"226":1}}],["必须在最后的位置",{"2":{"207":1}}],["必须在参数列表后加上关键字mutable",{"2":{"193":1}}],["必须在变量的定义之前添加extern关键字",{"2":{"75":1}}],["必须在定义关联容器类型时提供此操作的类型",{"2":{"16":1}}],["必须对每个构造的元素调用destroy来销毁它们",{"2":{"60":1}}],["必须提供指向的类型",{"2":{"52":1}}],["必须记住元素类型是pair",{"2":{"20":1}}],["必须记住",{"2":{"19":1}}],["对基类成员的访问权限只与基类中的访问说明符有关",{"2":{"303":1}}],["对虚函数的调用可能在运行时才被解析",{"2":{"301":1}}],["对析构函数进行动态绑定",{"2":{"298":1}}],["对string对象或vector执行sizeof运算只返回该类型固定部分的大小",{"2":{"271":1}}],["对sp所指的对象或者arr所指的数组中的元素执行对应的析构函数",{"2":{"222":1}}],["对数组执行sizeof运算得到整个数组所占空间大小",{"2":{"271":1}}],["对数组执行下标运算其实是对指向数组元素的指针执行下标运算",{"2":{"103":1}}],["对解引用指针执行sizeof运算得到指针指向对象所占空间的大小",{"2":{"271":1}}],["对指针执行sizeof运算得到指针本身所占空间的大小",{"2":{"271":1}}],["对引用类型执行sizeof运算得到被引用对象所占空间大小",{"2":{"271":1}}],["对引用的对象本身是不是一个常量未作限定",{"2":{"76":1}}],["对char或者类型为char的表达式执行sizeof运算",{"2":{"271":1}}],["对表达式求值将得到一个结果",{"2":{"259":1}}],["对成员执行默认初始化",{"2":{"240":1}}],["对成员运算符函数的等价调用",{"2":{"135":1}}],["对命名空间内部名字的查找遵循常规的查找规则",{"2":{"212":1}}],["对比较复杂的应用概念建模的能力",{"2":{"204":1}}],["对应给定的callable参数",{"2":{"194":1}}],["对应位置的元素也相等",{"2":{"96":1}}],["对args的扩展中",{"2":{"182":1}}],["对每个元素应用模式",{"2":{"182":1}}],["对每个实例化声明",{"2":{"170":1}}],["对",{"2":{"178":1}}],["对f1的调用使用实参所引用的类型作为模板参数类型",{"2":{"176":1}}],["对ostream使用p版本",{"2":{"163":1}}],["对这些流调用seek和tell会导致运行时出错",{"2":{"163":1}}],["对其运行析构函数是安全的",{"2":{"132":1}}],["对类类型的成员",{"2":{"120":1}}],["对尾后迭代器或者无效迭代器解引用的结果是ub",{"2":{"98":1}}],["对常量对象取地址是一种底层const",{"2":{"82":1}}],["对变量的改动不会影响初始值",{"2":{"31":1}}],["对象不包含与静态数据成员有关的数据",{"2":{"258":1}}],["对象被分配了空间并构造完成",{"2":{"222":1}}],["对象被赋予默认状态",{"2":{"138":1}}],["对象",{"2":{"216":1}}],["对象拷贝后就立即销毁了",{"2":{"130":1}}],["对象移动",{"0":{"130":1},"1":{"131":1,"132":1}}],["对象是指一块能存储数据并具有某种类型的内存空间",{"2":{"67":1}}],["对象的基类部分也是隐式销毁的",{"2":{"308":1}}],["对象的成员会被隐式销毁",{"2":{"308":1}}],["对象的销毁顺序与构造函数正好相反",{"2":{"219":1}}],["对象的引用",{"2":{"138":1}}],["对象的类型定义了对象能包含的数据和能参与的运算",{"2":{"64":1}}],["对象的生命周期是程序执行过程中该对象存在的一段时间",{"2":{"27":1}}],["对象还是会被释放",{"2":{"57":1}}],["对象就会被释放",{"2":{"57":1}}],["对象就会进行值初始化",{"2":{"52":1}}],["对象有生命周期",{"2":{"27":1}}],["对一个map进行insert操作时",{"2":{"20":1}}],["对map而言",{"2":{"19":1}}],["对于list和forward",{"2":{"323":2}}],["对于基类的每个构造函数",{"2":{"309":1}}],["对于派生类的析构函数来说",{"2":{"307":1}}],["对于派生类能够继承的基类个数",{"2":{"215":1}}],["对于代码中的某个给定节点来说",{"2":{"303":1}}],["对于引用也是一样",{"2":{"275":1}}],["对于引用的操作实际上是作用于引用所引的对象上",{"2":{"32":1}}],["对于那些没有指定执行顺序的运算符来说",{"2":{"263":1}}],["对于那种只在一两个地方使用的简单操作",{"2":{"194":1}}],["对于公共代码使用私有功能函数",{"2":{"246":1}}],["对于const对象",{"2":{"240":1}}],["对于其他语言编写的函数来说",{"2":{"236":1}}],["对于普通函数指针和指向成员函数的指针来说",{"2":{"230":1}}],["对于普通局部变量对应的对象来说",{"2":{"27":1}}],["对于指向静态成员的指针和普通的指针没有什么区别",{"2":{"229":1}}],["对于operator",{"2":{"223":1}}],["对于ostream也是如此",{"2":{"2":1}}],["对于接受类类型实参的函数来说",{"2":{"213":1}}],["对于用户及编译器来说",{"2":{"208":1}}],["对于通用版本的",{"2":{"203":1}}],["对于反向迭代器",{"2":{"198":1}}],["对于操作右值引用的代码来说",{"2":{"177":1}}],["对于模板类型参数已经显式指定了的函数实参",{"2":{"173":1}}],["对于函数模板",{"2":{"171":1}}],["对于函数而言也是如此",{"2":{"42":1}}],["对于string和vector",{"2":{"323":1}}],["对于shared",{"2":{"170":1}}],["对于set",{"2":{"18":1}}],["对于类类型来说",{"2":{"266":1}}],["对于类型成员的访问",{"2":{"249":1}}],["对于类来说",{"2":{"150":1}}],["对于类管理的资源",{"2":{"127":1}}],["对于内置类型来说",{"2":{"143":1}}],["对于某些类来说",{"2":{"125":1}}],["对于一个派生类来说",{"2":{"217":1}}],["对于一个值拷贝的变量",{"2":{"193":1}}],["对于一个对象或一个表达式",{"2":{"192":1}}],["对于一个参数包",{"2":{"182":1}}],["对于一个可变参数模板",{"2":{"180":1}}],["对于一个调用",{"2":{"179":1}}],["对于一个给定的实例化版本",{"2":{"170":1}}],["对于一个给定的关键字",{"2":{"15":1}}],["对于一个模板参数",{"2":{"168":1}}],["对于一个删除了析构函数的类型",{"2":{"125":1}}],["对于临时对象",{"2":{"122":1}}],["对于动态分配的对象",{"2":{"122":1}}],["对于数组类型的成员",{"2":{"121":1}}],["对于二元运算符来说",{"2":{"135":1}}],["对于二元运算符",{"2":{"121":1}}],["对于二维数组",{"2":{"105":1}}],["对于输出",{"2":{"109":1}}],["对于decltype所用的表达式来说",{"2":{"83":1}}],["对于栈对象",{"2":{"50":1}}],["对于局部变量对应的自动对象来说",{"2":{"27":1}}],["对于允许重复关键字的容器",{"2":{"23":1}}],["对于不允许重复关键字的容器",{"2":{"23":1}}],["对于保存不重复关键字的容器",{"2":{"21":1}}],["对于map",{"2":{"18":1}}],["对于有序容器",{"2":{"16":1}}],["为基类部分赋值",{"2":{"308":1}}],["为防止名字冲突提供了更加可控的机制",{"2":{"209":1}}],["为print生成函数参数列表",{"2":{"182":1}}],["为pair",{"2":{"18":1}}],["为0",{"2":{"109":1}}],["为对象起了另外一个名字",{"2":{"72":1}}],["为另一种相关类型",{"2":{"64":1}}],["为了访问一个元素",{"2":{"311":1}}],["为了解释本节的概念",{"2":{"229":1}}],["为了解决这个问题",{"2":{"194":1}}],["为了实现这一目的",{"2":{"221":1,"299":1}}],["为了实现类值的行为",{"2":{"127":1}}],["为了一次性捕获所有异常",{"2":{"207":1}}],["为了指示编译器推断捕获列表",{"2":{"193":1}}],["为了指出我们正在实例化一个模板",{"2":{"183":1}}],["为了指定使用自定义的操作",{"2":{"16":1}}],["为了终止递归",{"2":{"181":1}}],["为了获得元素类型",{"2":{"174":1}}],["为了处理模板",{"2":{"168":1}}],["为了处理输入",{"2":{"109":1}}],["为了引用",{"2":{"167":1}}],["为了使用模板参数的成员",{"2":{"174":1}}],["为了使用类模板",{"2":{"167":1}}],["为了使返回值与机器无关",{"2":{"39":1}}],["为了生成一个实例化版本",{"2":{"166":1}}],["为了取消格式的改变",{"2":{"161":1}}],["为了得到一个指定范围内的数",{"2":{"159":1}}],["为了防止上述异常情况的发生",{"2":{"150":1}}],["为了防止内存耗尽",{"2":{"53":1}}],["为了与内置版本保持一致",{"2":{"143":1}}],["为了与下标的原始定义兼容",{"2":{"142":1}}],["为了与其他输出运算符保持一致",{"2":{"137":1}}],["为了定义这些成员",{"2":{"126":1}}],["为了定义一个allocator对象",{"2":{"60":1}}],["为了阻止友元和成员函数访问私有成员",{"2":{"125":1}}],["为了专门得到const",{"2":{"98":1}}],["为了确保各个文件中类的定义一致",{"2":{"86":1}}],["为了确定最佳匹配",{"2":{"48":1}}],["为了满足这一要求",{"2":{"75":1}}],["为了支持低层编程",{"2":{"235":1}}],["为了支持随机访问",{"2":{"163":1}}],["为了支持移动操作",{"2":{"131":1}}],["为了支持这一用法",{"2":{"75":1}}],["为了支持分离式编译",{"2":{"68":1}}],["为了支持不同种类的io处理操作",{"2":{"2":1}}],["为了允许把程序拆分成多个逻辑部分来编写",{"2":{"68":1}}],["为了释放动态数组",{"2":{"59":1}}],["为了让new分配一个对象数组",{"2":{"59":1}}],["为了更容易",{"2":{"51":1}}],["为了表示函数真正的返回类型跟在形参列表之后",{"2":{"40":1}}],["为了编写能处理不同数量实参的函数",{"2":{"36":1}}],["只修改了异常对象的局部副本",{"2":{"207":1}}],["只写",{"2":{"199":1}}],["只读",{"2":{"199":1}}],["只读算法",{"0":{"187":1}}],["只是返回给操作系统一个值",{"2":{"107":1}}],["只有该派生类对象中的基类部分会被拷贝",{"2":{"300":1}}],["只有被定义",{"2":{"247":1}}],["只有基类部分被抛出",{"2":{"206":1}}],["只有两个tuple具有相同数量的成员时并且成员也支持比较操作时",{"2":{"153":1}}],["只有一种例外",{"2":{"95":1}}],["只有当元素类型定义了相应的比较运算符时",{"2":{"317":1}}],["只有当d公有地继承b时",{"2":{"303":1}}],["只有当解引用成员指针时我们才提供对象的信息",{"2":{"229":1}}],["只有当类型含有虚函数时",{"2":{"226":1}}],["只有当派生类使用的是合成版本的拷贝",{"2":{"215":1}}],["只有当它右侧的所有参数都有默认实参时",{"2":{"168":1}}],["只有当我们实例化出模板的一个特定版本时",{"2":{"166":1}}],["只有当bitset的大小小于等于对应的大小时",{"2":{"156":1}}],["只有当一个类没有定义任何自己版本的拷贝控制成员",{"2":{"132":1}}],["只有当size是一个constexpr函数时",{"2":{"79":1}}],["只有当函数确实要改变元素值的时候",{"2":{"34":1}}],["只不过对于初学者并不需要",{"2":{"291":1}}],["只不过在使用这个名字时必须明确指出它的版本",{"2":{"217":1}}],["只不过前者是c++的命名规范",{"2":{"92":1}}],["只不过这些方式之间必须有所区别",{"2":{"90":1}}],["只能遍历整个容器",{"2":{"311":1}}],["只能递增",{"2":{"199":3}}],["只能传递给它一个左值",{"2":{"176":1}}],["只能生成元素的引用",{"2":{"174":1}}],["只能向可修改的左值赋值",{"2":{"133":1}}],["只能绑定到类型x的可修改的右值",{"2":{"133":1}}],["只能对确已存在的元素执行下标操作",{"2":{"96":1}}],["只能使用指向常量的指针",{"2":{"77":1}}],["只能在for语句之内访问",{"2":{"70":1}}],["只能有一个元素的关键字等于它",{"2":{"15":1}}],["只需要将函数名替换成指针即可",{"2":{"49":1}}],["只需改变一条声明即可",{"2":{"28":1}}],["只要condition的求值结果为真就一直执行statement",{"2":{"284":1}}],["只要不包含底层const",{"2":{"276":1}}],["只要参数的数量or类型有区别",{"2":{"245":1}}],["只要该类型能作为函数的返回类型",{"2":{"150":1}}],["只要该表达式的结果能转换成引用的类型即可",{"2":{"76":1}}],["只要在调用函数的时候省略该实参就可以了",{"2":{"44":1}}],["只要函数名相同而形参有明显的不同",{"2":{"41":1}}],["只要函数的返回类型不是void",{"2":{"39":1}}],["只适用于map",{"2":{"18":1}}],["中的异常声明",{"2":{"207":1}}],["中的",{"2":{"109":1}}],["中的内容刷到设备中",{"2":{"109":1}}],["中",{"2":{"94":1}}],["中列出的类型",{"2":{"18":1}}],["中介绍的普通容器操作",{"2":{"14":1}}],["299页",{"2":{"312":1}}],["295页",{"2":{"312":1}}],["2为第二个参数",{"2":{"194":1}}],["255",{"2":{"150":1}}],["20是常量表达式",{"2":{"79":1}}],["20",{"2":{"65":1,"79":1,"147":1,"153":1,"161":8}}],["24",{"2":{"44":2}}],["2",{"2":{"18":1,"35":1,"40":2,"53":1,"59":1,"76":2,"101":2,"103":5,"104":1,"105":3,"148":3,"155":1,"161":1,"206":1,"301":1,"312":1}}],["2节和14",{"2":{"150":1}}],["2节",{"2":{"14":1,"195":1}}],["创建一个抽象基类的对象",{"2":{"302":1}}],["创建一个使用insert的迭代器",{"2":{"196":1}}],["创建一个使用push",{"2":{"196":2}}],["创建一个空vector",{"2":{"95":1}}],["创建变量val",{"2":{"113":1}}],["创建对象时",{"2":{"85":1}}],["创建pair对象的函数",{"2":{"17":1}}],["创建文件流对象时",{"2":{"7":1}}],["virtaul",{"2":{"218":2}}],["virtual说明符表明了一种愿望",{"2":{"218":1}}],["virtual",{"2":{"218":2,"297":1}}],["viable",{"2":{"47":1}}],["vec",{"2":{"104":1}}],["vector对象才能被比较",{"2":{"96":1}}],["vector对象能高效增长",{"2":{"95":1}}],["vector的对象能高效地增长",{"2":{"95":1}}],["vector模板控制着初始化向量的方法",{"2":{"94":1}}],["vector是模板而非类型",{"2":{"93":1}}],["vector是一个类模板",{"2":{"93":1}}],["vector是对象的集合",{"2":{"93":1}}],["vector",{"2":{"17":2,"52":1,"53":2,"94":8,"96":1,"98":1,"104":1,"200":1,"311":1,"313":1,"320":1}}],["v5里包含了用a",{"2":{"94":1}}],["v5",{"2":{"94":3}}],["v4包含了n个执行了值初始化的对象",{"2":{"94":1}}],["v4",{"2":{"94":1}}],["v3包含了n个重复的元素",{"2":{"94":1}}],["v3",{"2":{"94":1}}],["v2是左值",{"2":{"132":1}}],["v2中的元素将拷贝替换v1的",{"2":{"96":1}}],["v2中包含v1所有元素的副本",{"2":{"94":1}}],["v2",{"2":{"94":2,"96":3,"109":6,"129":4,"132":3,"168":3}}],["v1是一个空的vector",{"2":{"94":1}}],["v1",{"2":{"94":4,"96":4,"109":6,"129":4,"132":2,"168":3,"193":3}}],["void",{"2":{"33":1,"34":6,"36":1,"41":2,"44":1,"47":3,"62":1,"73":1,"133":1,"168":1,"176":8,"178":3,"180":3,"208":1,"216":3,"222":15,"223":1,"276":1,"303":4}}],["variadic",{"2":{"180":1}}],["variable",{"2":{"27":1,"83":2,"109":1}}],["val3",{"2":{"173":1}}],["val",{"2":{"94":1,"113":3,"145":4,"150":4,"168":2,"202":1}}],["val2",{"2":{"82":1}}],["val1",{"2":{"82":1}}],["value",{"2":{"5":1,"18":1,"19":1,"20":1,"30":2,"67":1,"90":4,"94":1,"114":1,"150":1,"153":1,"168":1,"222":1,"223":1,"275":1}}],["v",{"2":{"17":4,"93":1,"96":3,"98":5,"141":2,"168":2,"267":2}}],["保证下标合法是程序员的责任",{"2":{"320":1}}],["保证传递给模板的实参支持模板所要求的操作",{"2":{"166":1}}],["保存在string中搜索的结果",{"2":{"157":1}}],["保存到一个临时的string对象中",{"2":{"156":1}}],["保存了与bitset对象相同的位模式",{"2":{"156":1}}],["保存程序的名字",{"2":{"35":1}}],["保存string和vector",{"2":{"17":1}}],["保存两个string",{"2":{"17":1}}],["保留文件内容",{"2":{"8":1}}],["pc",{"2":{"276":3}}],["pci",{"2":{"53":1}}],["p730",{"2":{"276":1}}],["p747",{"2":{"232":1}}],["pbeg++等价于",{"2":{"267":1}}],["pbeg++",{"2":{"267":2}}],["pbeg",{"2":{"267":2}}],["pt",{"2":{"233":2}}],["ptr在运行时绑定删除器",{"2":{"170":1}}],["ptr在编译时绑定了删除器",{"2":{"170":1}}],["ptr举例说明",{"2":{"170":1}}],["ptr和unique",{"2":{"170":1}}],["ptr和new结合使用",{"0":{"54":1}}],["ptr这样的类",{"2":{"130":1}}],["ptr来管理类中的资源",{"2":{"128":1}}],["ptr来初始化它",{"2":{"57":1}}],["ptr销毁时",{"2":{"59":1}}],["ptr版本",{"2":{"59":1}}],["ptr直接访问对象",{"2":{"57":1}}],["ptr被销毁",{"2":{"57":1}}],["ptr被销毁时",{"2":{"52":1,"56":1}}],["ptr绑定到一个shared",{"2":{"57":1}}],["ptr管理的对象",{"2":{"57":1}}],["ptr是一种不控制所指对象生存期的智能指针",{"2":{"57":1}}],["ptr操作的讨论见p418",{"2":{"56":1}}],["ptr不会改变shared",{"2":{"57":1}}],["ptr不支持普通的拷贝或赋值操作",{"2":{"56":1}}],["ptr不同",{"2":{"56":2}}],["ptr拥有它指向的对象",{"2":{"56":1}}],["ptr时",{"2":{"56":1,"57":1}}],["ptr指向对象",{"2":{"57":1}}],["ptr指向一个给定对象",{"2":{"56":1}}],["ptr指向相同的对象",{"2":{"52":2}}],["ptr自动释放内存",{"2":{"55":1}}],["ptr赋予一个新值或是shared",{"2":{"52":1}}],["ptr都有一个关联的计数器",{"2":{"52":1}}],["ptr都会记录有多少个其他shared",{"2":{"52":1}}],["ptr的成员",{"2":{"170":1}}],["ptr的引用计数",{"2":{"57":1}}],["ptr的计数器变为0",{"2":{"52":1}}],["ptr的拷贝和赋值",{"2":{"52":1}}],["ptr的伴随类",{"2":{"51":1}}],["ptr",{"0":{"56":1,"57":1},"2":{"52":6,"54":3,"55":2,"56":4,"57":4,"59":2,"101":1,"170":2,"268":1}}],["ptr类负责释放资源",{"2":{"128":1}}],["ptr类自己会记录有多少用户共享它所指向的对象",{"2":{"128":1}}],["ptr类",{"0":{"52":1}}],["ptr所管理的对象",{"2":{"51":1}}],["ptr则",{"2":{"51":1}}],["ptr允许多个指针指向同一个对象",{"2":{"51":1}}],["pmf2",{"2":{"230":2}}],["pmf",{"2":{"230":4}}],["p480页",{"2":{"195":1}}],["p492讨论了如何选择重载运算符",{"2":{"135":1}}],["p491列出了可以重载的运算符",{"2":{"135":1}}],["pollution",{"2":{"209":1}}],["pos默认为0",{"2":{"325":1}}],["pos2",{"2":{"325":6}}],["pos通常是前一个tell返回的值",{"2":{"163":1}}],["pos",{"2":{"163":2,"229":1,"230":4,"325":3,"327":3}}],["pointer",{"2":{"51":1,"73":2,"77":2,"229":1}}],["peek",{"2":{"162":1}}],["place",{"2":{"223":4}}],["placement",{"2":{"223":1}}],["placeholders",{"2":{"194":1}}],["plus",{"2":{"147":1}}],["plus类定义了一个函数调用运算符用于对一对运算对象执行+操作",{"2":{"147":1}}],["please",{"2":{"5":1}}],["pscreen",{"2":{"229":2,"230":2}}],["ps",{"2":{"126":1,"129":4,"231":1}}],["putback",{"2":{"162":1}}],["put",{"2":{"162":2}}],["public成员定义类的接口",{"2":{"242":1}}],["public说明符之后的成员对外可见",{"2":{"242":1}}],["public",{"2":{"120":1,"121":1,"122":1,"126":1,"133":1,"141":1,"142":1,"143":2,"144":1,"150":2,"167":1,"168":1,"213":1,"215":5,"218":5,"229":2,"297":3,"298":1,"299":2,"303":3,"306":1,"308":4,"309":2}}],["push",{"2":{"95":1,"133":2}}],["p指向bulk的quote部分",{"2":{"299":1}}],["p指向quote对象",{"2":{"299":1}}],["p指向ia的首元素",{"2":{"103":1}}],["p指向的对象只有p一个引用者",{"2":{"52":1}}],["p是整型指针",{"2":{"82":1}}],["p是常量指针",{"2":{"79":1}}],["p是一个指向常量的指针",{"2":{"79":1}}],["p是一个指向int型的指针",{"2":{"74":1}}],["pdata",{"2":{"229":6}}],["pd",{"2":{"73":2}}],["p存放变量ival的地址",{"2":{"73":1}}],["p必须指向一个动态分配的对象或为空",{"2":{"59":1}}],["p必须指向一个动态分配的对象或是一个空指针",{"2":{"53":1}}],["p的引用计数未改变",{"2":{"57":1}}],["p299",{"2":{"314":1}}],["p208",{"2":{"276":1}}],["p2是一个常量指针",{"2":{"79":1}}],["p2是一个底层const",{"2":{"78":1}}],["p2指向一个值为42的int",{"2":{"54":1,"56":1}}],["p2",{"2":{"53":1,"54":2,"56":1,"73":2,"78":2,"79":1,"183":2}}],["p217",{"2":{"47":1}}],["pvec",{"2":{"231":3}}],["pv",{"2":{"53":1}}],["pia3",{"2":{"59":1}}],["pia2",{"2":{"59":1}}],["pia指向第一个int",{"2":{"59":1}}],["pia",{"2":{"59":2}}],["pi指向一个动态分配的",{"2":{"53":1}}],["pi",{"2":{"53":2,"73":1,"77":2,"82":1}}],["p和q指向相同的对象",{"2":{"52":1}}],["p",{"2":{"52":2,"53":1,"55":4,"57":2,"59":1,"60":4,"73":3,"74":1,"77":2,"79":2,"82":1,"83":2,"103":4,"105":1,"176":2,"226":1,"275":1,"276":3,"299":4}}],["p311页",{"2":{"321":1}}],["p310",{"2":{"320":1}}],["p305",{"2":{"319":1}}],["p352",{"2":{"193":1}}],["p3",{"2":{"52":1,"73":1,"78":1}}],["pf1",{"2":{"175":1}}],["pf1指向实例int",{"2":{"175":1}}],["pf指向名为lengthcompare的函数",{"2":{"49":1}}],["pf",{"2":{"49":4}}],["p514",{"2":{"48":1}}],["p57",{"2":{"33":1}}],["p199页",{"2":{"288":1}}],["p192",{"2":{"33":1}}],["p124页列出的算术运算符满足左结合律",{"2":{"264":1}}],["p109列举了c语言标准库提供的一组函数",{"2":{"104":1}}],["p1是常量指针",{"2":{"79":1}}],["p1是一个顶层const",{"2":{"78":1}}],["p1和p2都是指向int型对象的指针",{"2":{"73":1}}],["p1",{"2":{"52":3,"53":1,"54":1,"56":1,"73":3,"78":1,"79":1,"183":2}}],["p147页罗列出了全部的运算符和其优先级",{"2":{"262":1}}],["p142",{"2":{"48":2}}],["p143",{"2":{"48":1}}],["phone",{"2":{"41":2}}],["p641页列出了初始化一个bitset的方法",{"2":{"155":1}}],["p6",{"2":{"52":1}}],["p6指向一个动态分配的空vector",{"2":{"52":1}}],["p60",{"2":{"40":1}}],["p618",{"2":{"36":1}}],["pred",{"2":{"202":1}}],["predicate",{"2":{"191":1}}],["preprocessor",{"2":{"46":1,"86":1}}],["primer",{"2":{"210":1,"211":4}}],["price函数",{"2":{"301":1}}],["price这样的与类型相关的操作时",{"2":{"298":1}}],["price",{"2":{"137":1,"138":3,"297":2,"298":6,"299":1,"300":1,"301":1,"302":2,"309":3}}],["private说明符之后的成员对内可见",{"2":{"242":1}}],["private",{"2":{"126":1,"142":1,"150":1,"167":1,"168":1,"229":1,"298":1,"299":1,"303":1}}],["private拷贝控制",{"2":{"125":1}}],["print",{"2":{"34":6,"41":3,"46":1,"172":1,"181":3,"182":2,"216":4}}],["prot",{"2":{"303":5}}],["protected还有一条重要的性质",{"2":{"303":1}}],["protected说明符可以看做是public和private中和后的产物",{"2":{"303":1}}],["protected",{"2":{"298":1,"303":3}}],["prototype",{"2":{"28":1}}],["promotion",{"2":{"274":1}}],["programming",{"2":{"297":1}}],["program",{"2":{"294":1}}],["prog",{"2":{"35":1}}],["process",{"2":{"17":1}}],["pass",{"2":{"269":1}}],["passed",{"2":{"30":2}}],["panda的构造函数也可以初始化zooanimal",{"2":{"219":1}}],["panda",{"2":{"215":6,"216":1,"218":1,"219":2}}],["pattern",{"2":{"182":1}}],["packet",{"2":{"180":1}}],["pal2的所有实例都是c的友元",{"2":{"167":1}}],["pal2",{"2":{"167":1}}],["pal",{"2":{"167":2}}],["parm",{"2":{"167":1}}],["param",{"2":{"36":1,"40":1}}],["parameter",{"2":{"26":1,"166":2,"180":1,"192":1}}],["pa必须指向一个动态分配的数组或为空",{"2":{"59":1}}],["pa",{"2":{"59":1}}],["pair",{"2":{"17":2,"20":2,"153":1}}],["pair是一个用来生成特定类型的模板",{"2":{"17":1}}],["pair类型定义在头文件utility中",{"2":{"17":1}}],["pair类型",{"0":{"17":1}}],["break语句负责终止离它最近的while",{"2":{"289":1}}],["break语句",{"0":{"289":1}}],["break",{"2":{"282":1,"288":1,"294":1}}],["braced",{"2":{"223":1}}],["brace",{"2":{"107":1}}],["bp指向一个base对象",{"2":{"225":1}}],["bp",{"2":{"225":1,"226":5}}],["body",{"2":{"192":1}}],["book1",{"2":{"213":2}}],["book",{"2":{"153":1,"298":2,"299":2,"309":2}}],["bookno",{"2":{"85":1,"86":1,"138":1,"298":3}}],["bookstore",{"2":{"16":1}}],["boolalpha",{"2":{"161":1}}],["bool值打印为1或0",{"2":{"161":1}}],["bool一般定义成explicit的",{"2":{"150":1}}],["bool",{"2":{"41":1,"49":9,"63":1,"140":1,"156":3,"167":2,"215":1,"219":1,"231":2}}],["b>",{"2":{"168":1}}],["blobptr",{"2":{"167":2}}],["blob",{"2":{"167":8,"168":1,"170":2}}],["block",{"2":{"107":1,"112":1,"278":1,"292":1}}],["binary",{"2":{"261":1}}],["bind生成的可调用对象的第一个实参可以是对象",{"2":{"231":1}}],["bind创建的对象以及重载了函数调用运算符的类",{"2":{"148":1}}],["bind",{"2":{"72":1,"194":1,"231":1}}],["bits",{"2":{"156":4}}],["bitset操作定义了多种检测或设置一个或多个二进制位的方法",{"2":{"156":1}}],["bitset操作",{"0":{"156":1}}],["bitset中的二进制位将是此模式的一个副本",{"2":{"155":1}}],["bitset类是一个类模板",{"2":{"155":1}}],["bitset类定义在头文件bitset中",{"2":{"154":1}}],["bitset类型",{"0":{"154":1},"1":{"155":1,"156":1}}],["bitvec3",{"2":{"156":1}}],["bitvec4",{"2":{"155":1}}],["bitvec包含编号从0到31的32个二进制位",{"2":{"155":1}}],["bitvec",{"2":{"155":1,"156":16}}],["b是一个int",{"2":{"82":1}}],["b",{"2":{"82":1,"83":1,"94":4,"96":1,"98":1,"141":1,"168":4,"178":1,"225":2,"247":1,"303":2}}],["bulk",{"2":{"213":1,"297":1,"299":4,"309":1}}],["buffer",{"2":{"109":1}}],["bufsize",{"2":{"75":2}}],["built",{"2":{"107":1}}],["but",{"2":{"15":1}}],["b3",{"2":{"49":1}}],["b2",{"2":{"49":1}}],["b1",{"2":{"49":1}}],["before所采用的顺序关系是依赖于编译器的",{"2":{"227":1}}],["before",{"2":{"227":1}}],["bear",{"2":{"215":2,"216":2,"218":2}}],["behavior",{"2":{"92":1}}],["best",{"2":{"41":1}}],["beg和end表述输入范围",{"2":{"201":1}}],["beg2",{"2":{"201":2}}],["beg都是不存在的",{"2":{"174":1}}],["begin和end返回的具体类型由对象是否是常量决定",{"2":{"98":1}}],["begin和end运算符",{"2":{"98":1}}],["begin和end都返回尾后迭代器",{"2":{"98":1}}],["begin",{"2":{"98":2,"103":1,"104":1,"147":1,"193":1,"231":4,"267":1,"291":2,"313":1}}],["beg",{"2":{"41":1,"103":1,"163":1,"174":9,"201":4,"202":6}}],["bye",{"2":{"177":1}}],["by",{"2":{"30":4}}],["basep",{"2":{"301":1}}],["base2",{"2":{"215":5}}],["base1",{"2":{"215":5}}],["base",{"2":{"74":1,"218":1,"225":1,"226":1,"297":1,"299":1,"303":8,"308":8}}],["baderr",{"2":{"207":1}}],["bad",{"2":{"53":1,"150":1,"222":1,"225":1}}],["barth",{"2":{"20":2}}],["back的迭代器",{"2":{"196":1}}],["back向其中添加元素",{"2":{"95":1}}],["back函数把一个元素压入vector对象的尾端",{"2":{"95":1}}],["backrnd",{"2":{"44":1}}],["back",{"2":{"17":2,"98":1,"133":2,"196":1}}],[">quote",{"2":{"301":1}}],[">ival",{"2":{"233":1}}],[">~string",{"2":{"223":1}}],[">=",{"2":{"193":1}}],[">表示我们希望使用默认类型",{"2":{"168":1}}],[">operator",{"2":{"144":1}}],[">",{"2":{"16":1,"40":1,"41":3,"59":1,"144":1,"148":4,"150":3,"166":1,"168":1,"174":3,"176":2,"177":1,"183":1,"192":1,"225":5,"229":1,"230":1,"231":3,"276":3}}],[">>",{"2":{"4":2,"88":1,"109":4,"114":1,"138":3,"156":1,"275":1,"278":1,"294":3}}],["rtti",{"2":{"224":1}}],["runtime",{"2":{"293":1,"294":1}}],["run",{"2":{"224":1}}],["raise",{"2":{"292":1}}],["raised",{"2":{"206":1}}],["raccoon",{"2":{"218":2}}],["random",{"2":{"158":3,"159":5}}],["rand函数有一些问题",{"2":{"158":1}}],["range异常",{"2":{"320":1}}],["range",{"2":{"92":1,"150":1,"286":1,"329":1}}],["roster2",{"2":{"187":1}}],["roster2中的元素数目应该至少与roster1一样多",{"2":{"187":1}}],["roster1",{"2":{"187":2}}],["row绑定到a的第二个数组上",{"2":{"105":1}}],["row",{"2":{"105":1}}],["rowsize",{"2":{"34":2}}],["rr3",{"2":{"131":1}}],["rr2",{"2":{"131":1}}],["rr1",{"2":{"131":2}}],["rr",{"2":{"131":1}}],["r引用i",{"2":{"131":1}}],["rvalue",{"2":{"131":1,"261":1}}],["r4是一个普通的非常量引用",{"2":{"76":1}}],["r4",{"2":{"76":1}}],["r3是一个常量引用",{"2":{"76":1}}],["r3",{"2":{"76":1}}],["r2",{"2":{"76":1,"131":1}}],["r1是一个常量引用",{"2":{"76":1}}],["r1",{"2":{"76":3}}],["r是一个int型的引用",{"2":{"74":1}}],["r",{"2":{"41":2,"74":1,"76":1,"78":1,"82":2,"83":2,"131":1}}],["reinterpret",{"2":{"276":4}}],["revval",{"2":{"261":1}}],["reverse",{"2":{"202":2}}],["revenue",{"2":{"85":1,"86":1,"137":1,"138":1,"140":2,"141":1}}],["red",{"2":{"228":1}}],["rend",{"2":{"198":1}}],["resize接受一个可选的元素指参数",{"2":{"322":1}}],["result",{"2":{"259":1}}],["rest",{"2":{"180":1,"181":2,"182":3}}],["rest表示零个或多个函数参数",{"2":{"180":1}}],["rest是一个函数参数包",{"2":{"180":1}}],["reset",{"2":{"156":2}}],["remove",{"2":{"174":1,"177":2,"203":2}}],["retval",{"2":{"261":1}}],["rethrowing",{"2":{"207":1}}],["ret",{"2":{"167":1,"300":1}}],["return在第六章介绍",{"2":{"288":1}}],["return语句结束函数的执行",{"2":{"107":1}}],["return语句返回值的类型必须与函数的返回类型相同",{"2":{"39":1}}],["return语句有两种形式",{"2":{"37":1}}],["return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方",{"2":{"37":1}}],["return",{"2":{"16":1,"17":2,"26":1,"27":1,"37":1,"39":2,"40":2,"41":2,"45":1,"88":1,"107":1,"109":1,"129":1,"132":1,"142":2,"148":1,"150":2,"166":3,"167":1,"168":3,"172":1,"174":3,"177":1,"181":2,"182":1,"183":1,"192":2,"193":2,"229":1,"291":1,"298":2,"303":1}}],["replace",{"2":{"157":1,"326":2}}],["regex",{"2":{"157":4}}],["regular",{"2":{"157":1}}],["re库",{"2":{"157":1}}],["refer",{"2":{"293":1}}],["reference来获得元素的类型",{"2":{"174":1}}],["reference",{"2":{"30":2,"52":1,"72":1,"76":1,"128":1,"131":1,"133":1,"174":1,"177":2}}],["ref",{"2":{"101":1}}],["refval指向ival",{"2":{"72":1}}],["refval",{"2":{"72":1}}],["release方法据p418介绍",{"2":{"59":1}}],["release",{"2":{"59":2}}],["recoup",{"2":{"208":1}}],["record",{"2":{"41":2}}],["recursive",{"2":{"39":1}}],["rhs",{"2":{"16":2,"129":2,"132":8,"139":2,"140":6,"141":3,"308":2}}],["lvalue",{"2":{"261":1}}],["labeled",{"2":{"291":1}}],["lable",{"2":{"291":1}}],["last",{"2":{"233":1}}],["lambda不会改变其值",{"2":{"193":1}}],["lambda的数据成员也在lambda对象创建时被初始化",{"2":{"193":1}}],["lambda捕获和返回",{"0":{"193":1}}],["lambda可以定义在函数内部",{"2":{"192":1}}],["lambda",{"2":{"148":1}}],["lambda有它自己唯一的未命名的类类型",{"2":{"148":1}}],["lambda表达式是最有用的",{"2":{"194":1}}],["lambda表达式",{"0":{"192":1},"2":{"148":1}}],["lambda是函数对象",{"0":{"146":1}}],["lng",{"2":{"172":2,"173":4}}],["ll",{"2":{"168":1}}],["len2",{"2":{"325":4}}],["length",{"2":{"91":1}}],["lengthcompare",{"2":{"49":4}}],["least",{"2":{"207":1}}],["less",{"2":{"168":1}}],["level",{"2":{"78":2}}],["low",{"2":{"78":1,"155":1}}],["long>",{"2":{"168":1,"173":2}}],["long的位数",{"2":{"155":1}}],["long类型并被当作位模式来处理",{"2":{"155":1}}],["long中尺寸最小者",{"2":{"65":1}}],["long中尺寸最小的那个",{"2":{"65":1}}],["long和unsigned",{"2":{"65":1}}],["long和long",{"2":{"65":1}}],["long",{"2":{"63":1,"65":4,"155":2,"156":1,"168":1,"172":1,"173":6}}],["lock",{"2":{"57":1}}],["lock返回一个指向共享对象的shared",{"2":{"57":1}}],["local",{"2":{"27":2,"234":1}}],["lookup",{"2":{"41":6}}],["lost",{"2":{"20":1}}],["linkage",{"2":{"236":1}}],["linux下",{"2":{"114":1}}],["line",{"2":{"17":1,"46":1}}],["library",{"2":{"109":1}}],["limit",{"2":{"79":1}}],["literal",{"0":{"257":1},"2":{"65":1,"79":1,"109":1}}],["list不支持",{"2":{"316":1}}],["list两个容器添加和删除操作都很快速",{"2":{"311":1}}],["list和forward",{"2":{"311":1}}],["list中的参数可能包含形如",{"2":{"194":1}}],["list中的参数",{"2":{"194":1}}],["list是一个逗号分隔的参数列表",{"2":{"194":1}}],["list是一个lambda所在函数中定义的局部变量的列表",{"2":{"192":1}}],["list是一种标准库类型",{"2":{"36":1}}],["list来定义一个可接受可变数目实参的函数",{"2":{"181":1}}],["list",{"2":{"36":1,"40":1,"67":1,"141":1,"166":1,"167":1,"192":2,"194":1,"223":1,"240":1,"297":1,"311":2,"323":2}}],["list对象中元素的值",{"2":{"36":1}}],["list对象中的元素永远是常量值",{"2":{"36":1}}],["list类型定义在同名的头文件中",{"2":{"36":1}}],["list形参",{"2":{"36":1}}],["list的标准库类型",{"2":{"36":1}}],["lifetime",{"2":{"27":1}}],["lhs",{"2":{"16":2,"139":2,"140":6}}],["lt",{"0":{"137":2},"2":{"16":1,"18":1,"91":4,"94":9,"96":2,"99":2,"109":5,"136":2,"137":2,"147":2,"153":1,"167":1,"178":3,"189":1,"190":1,"202":1,"270":8,"317":2}}],["x的类型是const",{"2":{"83":1}}],["x",{"2":{"83":3,"133":2,"153":1,"176":4}}],["x26",{"2":{"16":2,"17":1,"33":3,"34":1,"40":2,"41":14,"49":5,"72":1,"73":3,"74":2,"76":6,"77":3,"78":3,"79":2,"82":8,"83":6,"92":1,"101":2,"103":1,"105":1,"120":1,"121":2,"125":3,"129":1,"131":11,"132":7,"133":6,"137":3,"138":3,"139":2,"140":8,"141":3,"142":2,"143":2,"144":2,"166":4,"167":4,"168":7,"172":3,"174":1,"175":6,"176":25,"177":6,"178":16,"180":7,"181":7,"182":4,"183":4,"193":1,"207":1,"213":1,"215":4,"216":10,"222":4,"225":6,"229":4,"230":5,"231":6,"261":1,"275":1,"276":1,"278":2,"298":1,"299":3,"303":4,"308":6,"309":1}}],["x3c",{"2":{"5":6,"15":3,"16":2,"17":8,"20":3,"34":4,"41":4,"46":8,"52":7,"53":2,"54":3,"55":8,"56":2,"57":3,"59":1,"60":1,"73":3,"88":3,"93":1,"96":1,"98":2,"102":6,"104":1,"109":23,"113":1,"137":16,"141":2,"145":1,"147":2,"148":16,"150":2,"153":7,"155":2,"156":14,"159":9,"161":82,"166":7,"167":19,"168":11,"170":2,"172":3,"173":3,"174":4,"175":1,"176":8,"177":4,"178":15,"180":10,"181":8,"182":5,"183":2,"216":6,"225":5,"231":3,"236":1,"263":8,"267":2,"269":1,"276":4,"278":2,"279":4,"291":1,"294":6}}],["d的成员和友元都能使用派生类向基类的转换",{"2":{"303":1}}],["d的形式",{"2":{"73":1}}],["d的形式来定义引用类型",{"2":{"72":1}}],["dp",{"2":{"225":1,"226":4,"276":1}}],["dynamic",{"0":{"225":1},"2":{"224":1,"225":7,"276":2}}],["dynamically",{"2":{"50":1}}],["d1",{"2":{"215":2}}],["do",{"0":{"287":1},"2":{"92":2,"283":1,"287":3,"289":1}}],["doubleprec",{"2":{"228":1}}],["double以2个字",{"2":{"63":1}}],["double>",{"2":{"56":1,"276":1}}],["double",{"2":{"47":4,"73":2,"77":3,"81":1,"85":1,"86":1,"153":1,"168":2,"180":1,"276":3,"297":1,"298":2,"299":2,"309":2}}],["d是int",{"2":{"83":1}}],["d是一个int",{"2":{"82":1}}],["dval",{"2":{"73":2,"77":2,"233":2}}],["deque和array",{"2":{"313":1,"320":1}}],["deque和array相比",{"2":{"311":1}}],["deque支持快速随机访问",{"2":{"311":1}}],["deque",{"2":{"311":1}}],["deque的迭代器除了这些操作",{"2":{"200":1}}],["deriveation",{"2":{"297":1}}],["derived",{"2":{"207":2,"225":4,"226":2,"297":1,"299":1,"303":1}}],["delegating",{"2":{"253":1}}],["delete的一种简单方式",{"2":{"222":1}}],["delete的8个重载版本",{"2":{"222":1}}],["delete接口",{"2":{"222":1}}],["delete函数的目的在于改变内存分配方式",{"2":{"222":1}}],["delete函数释放对象所占的空间",{"2":{"222":1}}],["delete函数后",{"2":{"222":1}}],["delete函数",{"2":{"222":2}}],["deleted",{"2":{"125":1}}],["delete将对象析构和内存释放组合在了一起",{"2":{"60":1}}],["deleter",{"2":{"55":2}}],["delete运算符释放new分配的内存",{"2":{"53":1}}],["delete",{"2":{"51":1,"53":1,"55":2,"59":1,"125":2,"222":8}}],["dest参数是一个表示算法可以写入目的位置的迭代器",{"2":{"201":1}}],["dest",{"2":{"201":1,"202":1}}],["destructor",{"2":{"118":1}}],["destroy",{"2":{"60":1,"301":1}}],["deduction",{"2":{"171":1}}],["dec",{"2":{"161":2}}],["decimal",{"2":{"161":2}}],["dec将其改为十六进制",{"2":{"161":1}}],["declaration定义一个变量",{"2":{"286":1}}],["declaration部分的变量会被初始化为expression部分的下一个元素值",{"2":{"92":1}}],["declaration部分负责定义一个变量",{"2":{"92":1}}],["declaration",{"2":{"68":1,"81":1,"88":1,"92":1,"170":2,"207":1,"211":1,"247":1,"286":1,"294":1}}],["decltype的表达式如果是加上了括号的变量",{"2":{"83":1}}],["decltype的结果可以是引用类型",{"2":{"83":1}}],["decltype类型指示符",{"0":{"83":1}}],["decltype并不负责把数组类型转换成对应的指针",{"2":{"40":1}}],["decltype",{"2":{"16":1,"40":1,"49":2,"83":8,"103":2,"153":1,"174":2}}],["device引擎为另一个引擎创建一个种子也是一种方法",{"2":{"159":1}}],["device引擎",{"2":{"159":1}}],["deallocate",{"2":{"60":1}}],["define",{"2":{"46":1,"86":1}}],["define语句定义ndebug",{"2":{"46":1}}],["default",{"2":{"44":1,"67":1,"159":2,"161":2,"168":1,"240":2,"298":2,"299":1,"306":1}}],["discount",{"2":{"299":2}}],["disc",{"2":{"299":2,"309":5}}],["display",{"2":{"213":1}}],["distribution",{"2":{"158":1,"159":1}}],["divide",{"2":{"148":1}}],["difference",{"2":{"99":1}}],["directive",{"2":{"211":1,"236":1}}],["direct",{"2":{"90":1}}],["dimension表示数组的大小",{"2":{"40":1}}],["dimension",{"2":{"40":1}}],["dickens",{"2":{"15":1}}],["d",{"2":{"35":2,"46":1,"82":1,"83":1,"180":1,"225":1,"276":1,"301":1,"308":10}}],["data类由于没有实现封装",{"2":{"237":1}}],["data类型",{"0":{"85":1}}],["data1",{"2":{"135":3}}],["data2",{"2":{"135":4}}],["data的拷贝赋值运算符",{"2":{"121":1}}],["data初步定义如下",{"2":{"85":1}}],["data0",{"2":{"35":2}}],["data",{"2":{"16":3,"46":1,"55":1,"85":2,"86":3,"121":1,"137":1,"138":2,"139":4,"140":4,"141":3,"210":1,"229":2,"237":2,"293":1}}],["这么做的好处是编译器可以为我们发现上述错误",{"2":{"301":1}}],["这么做给函数的调用者一种误导",{"2":{"33":1}}],["这往往是一种失误",{"2":{"301":1}}],["这仍然是合法的行为",{"2":{"301":1}}],["这就是我们想在循环结束后访问循环控制变量",{"2":{"284":1}}],["这就是静态成员",{"2":{"258":1}}],["这将在第6章介绍",{"2":{"276":1}}],["这叫前置声明",{"2":{"247":1}}],["这与调用其它成员函数没什么区别",{"2":{"223":1}}],["这两个容器的额外内存开销也很大",{"2":{"311":1}}],["这两个运算符特别适用于以下情况",{"2":{"224":1}}],["这两个函数必须是正确的",{"2":{"222":1}}],["这两种运算符必须作用于左值运算对象",{"2":{"267":1}}],["这两种运算符的运算对象和求值结果都是右值",{"2":{"265":1}}],["这两种运算符使得类可以在元素的序列中前后移动",{"2":{"143":1}}],["这两种情况最常出现",{"2":{"173":1}}],["这有可能造成二义性调用等重载问题",{"2":{"213":1}}],["这条规则对于如何确定候选函数集也有影响",{"2":{"213":1}}],["这条语句中的表达式使用了输出运算符",{"2":{"109":1}}],["这三种c++语言特性正好能满足上述要求",{"2":{"204":1}}],["这时",{"2":{"301":1}}],["这时会自动推断返回类型",{"2":{"192":1}}],["这时候可以使用预处理器宏",{"2":{"236":1}}],["这时候必须使用尾置返回类型",{"2":{"174":1}}],["这时候传递给这些形参的实参必须具有相同的类型",{"2":{"172":1}}],["这类算法使用元素类型的",{"2":{"190":1}}],["这组操作允许我们将一个流当作一个无解释的字节序列来处理",{"2":{"162":1}}],["这不是期望的",{"2":{"150":1}}],["这一例外对于传递类的引用或指针的调用同样有效",{"2":{"212":1}}],["这一部分的讨论见p626",{"2":{"183":1}}],["这一主题已经超出本书的范围",{"2":{"174":1}}],["这一特性意味着",{"2":{"170":1}}],["这一个特性影响到了我们如何组织代码以及错误何时被检测到",{"2":{"166":1}}],["这一过程看起来非常像调用函数的过程",{"2":{"145":1}}],["这一点对任何数据类型都适用",{"2":{"78":1}}],["这依赖于操作系统和编译器",{"2":{"108":1}}],["这和标准库类型的下标不一样",{"2":{"103":1}}],["这套操作使得我们能访问容器的元素",{"2":{"98":1}}],["这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内",{"2":{"300":1}}],["这意味着我们可以分配大块内存",{"2":{"60":1}}],["这意味着在函数块内定义的执行默认初始化的含内置类型元素的数组",{"2":{"101":1}}],["这意味着内置类型或组合类型的对象的值将是未定义的",{"2":{"53":1}}],["这是字符串比较函数",{"2":{"328":1}}],["这是一种隐式转换",{"2":{"299":1}}],["这是一种被广泛使用的",{"2":{"267":1}}],["这是一种机器相关的无符号类型",{"2":{"102":1}}],["这是一个很大的值",{"2":{"316":1}}],["这是一个我们无法自定义的operator",{"2":{"223":1}}],["这是一个无符号的整数",{"2":{"91":1}}],["这是很重要的",{"2":{"59":1}}],["这是因为后置版本将原始值存储下来以便于返回",{"2":{"267":1}}],["这是因为编译器需要知道类的存储空间大小",{"2":{"247":1}}],["这是因为编译器分两步处理类",{"2":{"238":1}}],["这是因为异常抛出时将调用对象的析构函数",{"2":{"206":1}}],["这是因为有这样的传递路径",{"2":{"178":1}}],["这是因为头文件会被其它文件引用",{"2":{"88":1}}],["这是因为带符号数会自动地转换成无符号数",{"2":{"64":1}}],["这是因为内联函数和constexpr函数可以多次定义",{"2":{"45":1}}],["这是因为调用函数包含一些额外的工作",{"2":{"45":1}}],["这是因为如果把函数声明放在头文件中",{"2":{"28":1}}],["这里讲解的语法自己已经很熟悉了",{"2":{"281":1}}],["这里给出一个案例print函数来说明如何编写一个可变参数函数",{"2":{"181":1}}],["这里给一个简单的定义删除器的例子",{"2":{"55":1}}],["这里的用户也包括了派生类",{"2":{"303":1}}],["这里的概念很细",{"2":{"274":1}}],["这里的操作将引发并抛出一个异常",{"2":{"207":1}}],["这里的类型即调用运算符的形参类型",{"2":{"147":1}}],["这里的维度表示我们期望数组含有多少元素",{"2":{"34":1}}],["这里似乎有错误",{"2":{"59":1}}],["这段代码抛出一个异常",{"2":{"55":2}}],["这部分内存被称作自由空间或堆",{"2":{"50":1}}],["这部分内容我比较熟悉了",{"2":{"29":1}}],["这些不同之处直接关系到了元素如何存储",{"2":{"318":1}}],["这些运算只能应用于string",{"2":{"313":1}}],["这些运算符逐对比较左侧tuple和右侧tuple的成员",{"2":{"153":1}}],["这些运算符指定了运算对象的求值顺序",{"2":{"135":1}}],["这些运算符使用了一种名为",{"2":{"129":1}}],["这些容器在以下方面都有不同的性能折中",{"2":{"311":1}}],["这些继承得到的类称为派生类",{"2":{"297":1}}],["这些异常类见书本p176",{"2":{"295":1}}],["这些异常类也可以用在用户编写的程序中",{"2":{"295":1}}],["这些行为超出了函数正常功能的范围",{"2":{"292":1}}],["这些函数有",{"2":{"329":1}}],["这些函数都拥有许多重载的版本",{"2":{"326":1}}],["这些函数叫构造函数",{"2":{"240":1}}],["这些函数也可以看成是类的接口",{"2":{"239":1}}],["这些版本承诺不会抛出异常",{"2":{"222":1}}],["这些版本可能抛出异常",{"2":{"222":1}}],["这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造",{"2":{"219":1}}],["这些链表版本的算法的性能比对应的通用版本好得多",{"2":{"203":1}}],["这些算法见p369",{"2":{"203":1}}],["这些算法需要交换输入序列中的元素",{"2":{"203":1}}],["这些算法还提供另一个版本",{"2":{"202":1}}],["这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器",{"2":{"198":1}}],["这些迭代器将它们对应的流当作一个特定类型的元素序列来处理",{"2":{"197":1}}],["这些迭代器向后而不是向前移动",{"2":{"195":1}}],["这些迭代器被绑定到输入或输出流上",{"2":{"195":1}}],["这些迭代器被绑定到一个容器上",{"2":{"195":1}}],["这些参数是",{"2":{"194":1}}],["这些模板定义在头文件type",{"2":{"174":1}}],["这些额外信息是显式模板实参",{"2":{"167":1}}],["这些值必须是常量表达式",{"2":{"166":1}}],["这些操作包括创建",{"2":{"305":1}}],["这些操作如果不显示定义",{"2":{"241":1}}],["这些操作要求我们自己分配并管理用来保存和提取数据的字符数组",{"2":{"162":1}}],["这些操作是很重要的",{"2":{"162":1}}],["这些操作称为拷贝控制操作",{"2":{"118":1}}],["这些类型的共同特点是拥有能返回迭代器的begin和end成员",{"2":{"286":1}}],["这些类型定义在memory头文件中",{"2":{"51":1}}],["这些类都被定义成模板的形式",{"2":{"147":1}}],["这些类都包含不能被共享的资源",{"2":{"130":1}}],["这些类一般会定义下标运算符operator",{"2":{"142":1}}],["这些类通常拥有一个资源",{"2":{"132":1}}],["这些类的对象不能拷贝但可以移动",{"2":{"130":1}}],["这些对象是匿名的",{"2":{"100":1}}],["这些都是常量表达式",{"2":{"79":1}}],["这些名字不能被用作标识符",{"2":{"69":1}}],["这些前缀和后缀见书本p37",{"2":{"65":1}}],["这些情况下需要用到转义序列",{"2":{"65":1}}],["这些新选出的函数称为可行函数",{"2":{"47":1}}],["这些元素会相邻存储",{"2":{"15":1}}],["这种语句可以遍历容器或其他序列的所有元素",{"2":{"286":1}}],["这种语句遍历序列中的每个元素并对序列中的每个值执行某种操作",{"2":{"92":1}}],["这种额外的工作消耗巨大",{"2":{"267":1}}],["这种类型只能在有限的情况下使用",{"2":{"247":1}}],["这种类型",{"2":{"247":1}}],["这种类需要通过析构函数来释放对象所分配的资源",{"2":{"126":1}}],["这种函数实参不进行特殊处理",{"2":{"172":1}}],["这种成员被称为成员模板",{"2":{"169":1}}],["这种构造函数将实参类型的对象转换成类类型",{"2":{"149":1}}],["这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员",{"2":{"146":1}}],["这种技术自动处理了自赋值的情况且天然就是异常安全的",{"2":{"129":1}}],["这种情况无须前置声明",{"2":{"167":1}}],["这种情况下",{"2":{"128":2,"130":1,"238":1,"240":1,"311":1}}],["这种情况会报warning",{"2":{"67":1}}],["这种复杂性体现在两个方面",{"2":{"80":1}}],["这种初始化形式有一个重要特点",{"2":{"67":1}}],["这种初始化的形式被称为列表初始化",{"2":{"67":1}}],["这种方法用到两项预处理功能",{"2":{"46":1}}],["这种功能一般只用于与c函数交互的接口程序",{"2":{"36":1}}],["这显然是安全的",{"2":{"41":1}}],["这个范围被称为左闭合区间",{"2":{"313":1}}],["这个新的函数也被终止",{"2":{"294":1}}],["这个参数必须是一个指向给定容器的迭代器",{"2":{"196":1}}],["这个命名空间本身定义在std命名空间中",{"2":{"194":1}}],["这个版本的flip2虽然能接受一个左值引用了",{"2":{"178":1}}],["这个头文件中的类通常用于所谓的模板元程序设计",{"2":{"174":1}}],["这个形参的唯一作用就是区分前置版本和后置版本的函数",{"2":{"143":1}}],["这个类型也有访问限制",{"2":{"245":1}}],["这个类型必须是完全类型",{"2":{"207":1}}],["这个类管理并控制与union的类类型成员有关的状态转换",{"2":{"233":1}}],["这个类还需要定义拷贝赋值运算符来避免将序号赋予目的对象",{"2":{"123":1}}],["这个类就需要一个拷贝构造函数为每个新创建的对象生成一个新的",{"2":{"123":1}}],["这个拷贝构造函数从给定对象拷贝所有其他数据成员",{"2":{"123":1}}],["这个对象被称为标准输出",{"2":{"109":1}}],["这个对象被称为标准输入",{"2":{"109":1}}],["这个引用事实上绑定在一个非常量实参上",{"2":{"41":1}}],["这个值仍然有效",{"2":{"27":1}}],["这样做可能很耗时",{"2":{"319":1}}],["这样做的好处是下标可以出现在赋值运算符的任意一端",{"2":{"142":1}}],["这样我们就能动态分配继承体系中的对象了",{"2":{"306":1}}],["这样",{"2":{"176":1}}],["这样才能保证共享引用计数",{"2":{"128":1}}],["这样就可以正确进行自赋值操作",{"2":{"127":1}}],["这样可以获取数组尾元素的下一个位置的指针",{"2":{"103":1}}],["这样可以带来很大的性能提升",{"2":{"5":1}}],["这样的纯虚函数一个实现",{"2":{"302":1}}],["这样的类可以含有constexpr函数成员",{"2":{"257":1}}],["这样的指针不支持函数调用运算符",{"2":{"231":1}}],["这样的形式",{"2":{"210":1}}],["这样的处理代码称为捕获所有异常",{"2":{"207":1}}],["这样的算法比如fill",{"2":{"188":1}}],["这样的前置声明是合法的",{"2":{"167":1}}],["这样的操作是非法的",{"2":{"101":1}}],["这样的值一望便知",{"2":{"65":1}}],["这样一种形参",{"2":{"44":1}}],["这样编译器将隐式地插入一条返回0的return语句",{"2":{"39":1}}],["m",{"2":{"264":5}}],["m导致溢出的特殊情况",{"2":{"264":1}}],["modes",{"2":{"228":1}}],["most",{"2":{"207":1}}],["move是如何定义的",{"2":{"177":1}}],["move",{"0":{"177":1},"2":{"118":2,"131":1,"177":3,"308":1}}],["must",{"2":{"293":1}}],["mutable",{"2":{"193":1}}],["multimap进行下标操作",{"2":{"22":1}}],["multimap",{"2":{"19":1}}],["multimap和multiset没有此限制",{"2":{"15":1}}],["multiset",{"2":{"16":1}}],["min",{"2":{"166":1,"299":2}}],["mem等价于",{"2":{"268":1}}],["mem等价于iter",{"2":{"98":1}}],["mem这样的代码时",{"2":{"168":1}}],["mem",{"2":{"98":3,"222":4,"231":4,"268":1,"303":5}}],["member",{"2":{"85":1,"117":1,"167":1,"169":1,"210":1,"211":1,"229":1}}],["memory",{"2":{"59":1}}],["mf",{"2":{"79":3}}],["myscreen",{"2":{"229":4,"230":3}}],["my",{"2":{"29":1,"34":1,"40":1,"41":2,"42":1,"47":2,"48":1,"49":1,"59":1,"67":1,"70":1,"153":1,"157":1,"159":2,"178":2,"207":1,"226":1,"242":1,"246":1,"253":1,"263":1,"265":1,"266":1,"268":1,"270":1,"271":1,"274":1,"276":1,"279":1,"281":1,"282":2,"285":1,"287":1,"291":1,"292":1,"293":1,"294":1,"303":1}}],["max",{"2":{"316":1}}],["malloc",{"2":{"222":1}}],["malloc函数接受一个表示待分配字节数的size",{"2":{"222":1}}],["malloc函数与free函数",{"2":{"222":1}}],["malloc和free定义在cstdlib头文件中",{"2":{"222":1}}],["manip",{"2":{"207":1}}],["manipulator",{"2":{"109":1}}],["macro",{"2":{"46":1}}],["match返回true",{"2":{"157":1}}],["match和regex",{"2":{"157":1}}],["match",{"2":{"41":2,"157":2}}],["matching",{"2":{"41":1}}],["matrix",{"2":{"34":2}}],["matrix指向数组的首元素",{"2":{"34":1}}],["main的返回值被用来指示状态",{"2":{"107":1}}],["main函数不能重载",{"2":{"41":1}}],["main函数不能调用它自己",{"2":{"39":1}}],["main",{"0":{"35":1},"2":{"35":1,"39":1,"46":1,"88":1,"107":1,"109":1,"213":1}}],["make",{"2":{"20":1,"52":5,"57":1,"153":1}}],["map的下标运算符返回的类型与解引用map迭代器得到的类型不同",{"2":{"22":1}}],["map的下标操作",{"0":{"22":1}}],["map下标运算符接受一个索引获取与此关键字相关联的值",{"2":{"22":1}}],["map容器提供了下标运算符和一个对应的at函数",{"2":{"22":1}}],["map和unordered",{"2":{"22":1}}],["map和set类型都支持begin和end操作",{"2":{"19":1}}],["mapped",{"2":{"18":2}}],["map是关键字",{"2":{"13":1}}],["map",{"2":{"12":1,"15":1,"19":2,"20":1}}],["即拷贝从",{"2":{"325":1}}],["即基类",{"2":{"304":1}}],["即派生类",{"2":{"304":1}}],["即定义了一个隐式转换机制",{"2":{"255":1}}],["即先执行受委托的构造函数内容",{"2":{"253":1}}],["即声明和定义在同一个文件中",{"2":{"245":1}}],["即在声明语句的分号",{"2":{"302":1}}],["即在类名后跟一个关键字final",{"2":{"299":1}}],["即在函数或类前面加friend关键字",{"2":{"243":1}}],["即在后续的派生类当中共享虚基类的同一份实例",{"2":{"218":1}}],["即隐藏了实现细节",{"2":{"242":1}}],["即empty是一个接受string参数并返回bool值的函数",{"2":{"231":1}}],["即形参列表完全相同",{"2":{"215":1}}],["即由内向外依次查找每个外层作用域",{"2":{"212":1}}],["即使静态类型与动态类型可能不一致",{"2":{"304":1}}],["即使实际运行的是派生类中的函数版本也是如此",{"2":{"301":1}}],["即使用下标的版本",{"2":{"326":1}}],["即使用基类中定义的默认实参",{"2":{"301":1}}],["即使用谓词",{"2":{"185":1}}],["即使该函数不执行任何实际操作也是如此",{"2":{"298":1}}],["即使其内容完全一样",{"2":{"247":1}}],["即使zooanimal不是panda的直接基类",{"2":{"219":1}}],["即使生成的数看起来是随机的",{"2":{"159":1}}],["即使不是大多数",{"2":{"158":1}}],["即使有weak",{"2":{"57":1}}],["即可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值",{"2":{"132":1}}],["即语言自身定义的类型",{"2":{"107":1}}],["即从数组的名字开始按照由内向外的顺序阅读",{"2":{"101":1}}],["即为0",{"2":{"101":1}}],["即列表初始化",{"2":{"101":1}}],["即其值在编译期间已知",{"2":{"101":1}}],["即字典顺序",{"2":{"96":1}}],["即当所有元素的值都一样",{"2":{"95":1}}],["即当形参有顶层const时",{"2":{"33":1}}],["即地址",{"2":{"73":1}}],["即返回类型和形参列表都要一样",{"2":{"49":1}}],["即确实不应该发生的事情",{"2":{"46":1}}],["即非0",{"2":{"46":1}}],["即0",{"2":{"46":1}}],["即获得一个数组类型",{"2":{"40":1}}],["即省略符",{"2":{"36":1}}],["即函数可以修改它的实参的值",{"2":{"33":1}}],["即",{"2":{"15":1,"59":1,"98":3,"105":1,"133":1,"166":1,"178":1,"194":1,"298":1}}],["j默认是private",{"2":{"303":1}}],["j为43",{"2":{"193":1}}],["j",{"2":{"68":1,"79":2,"82":1,"148":2,"178":3,"193":1,"276":1,"303":2}}],["john",{"2":{"20":2}}],["joyce",{"2":{"15":1,"17":1}}],["jane",{"2":{"15":1}}],["james",{"2":{"15":1,"17":1}}],["t是int",{"2":{"176":1}}],["t的类型推断的结果不会是一个const类型",{"2":{"176":1}}],["t3",{"2":{"173":1}}],["t3>",{"2":{"173":1}}],["tmp的类型为模版参数a的类型",{"2":{"168":1}}],["tmp",{"2":{"168":1}}],["t为int",{"2":{"166":1}}],["t2>",{"2":{"178":4}}],["t2和t3是从函数实参类型推断而来的",{"2":{"173":1}}],["t2",{"2":{"166":3,"173":2,"178":9,"227":3}}],["t1>",{"2":{"178":1}}],["t1是显式指定的",{"2":{"173":1}}],["t1",{"2":{"166":3,"173":2,"178":12,"227":2}}],["tuple函数使用初始值的类型来推断tuple类型",{"2":{"153":1}}],["tuple函数",{"2":{"153":1}}],["tuple的关系和相等运算符的行为类似容器的对应操作",{"2":{"153":1}}],["tuple的成员都是未命名的",{"2":{"153":1}}],["tuple的构造函数是explicit的",{"2":{"153":1}}],["tuple的一个常见用途是从一个函数返回多个值",{"2":{"152":1}}],["tuple",{"2":{"153":4}}],["tuple是非常有用的",{"2":{"152":1}}],["tuple是类似pair的模板",{"2":{"152":1}}],["tuple类型",{"0":{"152":1},"1":{"153":1}}],["throw表达式",{"0":{"293":1}}],["throw",{"2":{"207":1,"292":2}}],["throwing",{"2":{"206":1}}],["threed",{"2":{"153":1}}],["this的成员函数",{"0":{"246":1}}],["this是一个常量指针",{"2":{"238":1}}],["this指向了此对象的地址",{"2":{"238":1}}],["this",{"2":{"129":2,"132":2,"141":1,"144":1,"238":1,"245":1,"246":2}}],["the",{"2":{"15":1,"20":1,"98":1,"109":1}}],["tellp",{"2":{"163":2}}],["tellg",{"2":{"163":2}}],["tell",{"2":{"163":1}}],["test",{"2":{"156":1}}],["tempalte",{"2":{"170":1}}],["template",{"2":{"166":4,"167":9,"168":5,"169":1,"170":3,"171":1,"172":1,"173":2,"174":2,"176":1,"177":1,"178":1,"180":2,"181":2,"183":3}}],["temp",{"2":{"129":4}}],["terminated",{"2":{"104":1}}],["two",{"2":{"109":3}}],["t类型的常量表达式",{"2":{"271":1}}],["t类型",{"2":{"102":1}}],["token",{"2":{"233":7}}],["token类型的对象只有一个成员",{"2":{"233":1}}],["top",{"2":{"78":1,"168":1}}],["to",{"2":{"76":1,"77":1,"156":2,"229":1,"293":1,"299":1,"329":1}}],["tip",{"2":{"67":1,"303":1,"311":1}}],["time",{"2":{"46":1,"159":1,"224":1}}],["try",{"2":{"292":1,"294":1}}],["try语句块内声明的变量在catch子句内无法访问",{"2":{"294":1}}],["try语句块的通用语法形式是",{"2":{"294":1}}],["try语句块中代码抛出的异常通常会被某个catch子句处理",{"2":{"292":1}}],["try语句块以关键字try开始",{"2":{"292":1}}],["try语句块",{"0":{"294":1},"2":{"292":1}}],["try语句块和异常处理",{"0":{"292":1},"1":{"293":1,"294":1,"295":1}}],["true",{"2":{"156":1,"161":2,"282":1}}],["true和false是布尔类型的字面值",{"2":{"65":1}}],["traits中",{"2":{"174":1}}],["trailing",{"2":{"40":1}}],["transformation",{"2":{"174":1}}],["trans>",{"2":{"153":2}}],["trans是itme的类型",{"2":{"153":1}}],["trans",{"2":{"121":2,"153":1}}],["t",{"2":{"27":2,"41":1,"46":1,"94":9,"142":2,"150":1,"153":3,"156":2,"166":5,"167":3,"168":10,"172":1,"175":2,"176":10,"177":3,"178":2,"180":3,"181":7,"182":4,"183":2,"193":1,"196":1,"222":10,"223":1,"227":2,"236":1,"258":1,"297":2,"298":1,"299":3,"302":1,"303":2,"309":2}}],["type是转换的目标类型而expression是要转换的值",{"2":{"276":1}}],["type是一个带符号的整数",{"2":{"99":1}}],["type是一个pair",{"2":{"19":1}}],["type是一个pair类型",{"2":{"19":1}}],["typeinfo",{"2":{"226":1}}],["typeid的异常",{"2":{"226":1}}],["typeid的结果直到运行时才会求得",{"2":{"226":1}}],["typeid",{"2":{"226":5}}],["typeid操作的结果是一个常量对象的引用",{"2":{"226":1}}],["typeid表达式的形式是typeid",{"2":{"226":1}}],["typeid运算符指示的是运算对象的静态类型",{"2":{"226":1}}],["typeid运算符可以用作于任意类型的表达式",{"2":{"226":1}}],["typeid运算符允许程序向表达式提问",{"2":{"226":1}}],["typeid运算符",{"0":{"226":1},"2":{"224":1}}],["type必须是一个类类型",{"2":{"225":1}}],["type本身是一个左值引用类型",{"2":{"178":1}}],["type>",{"2":{"178":2}}],["typename>",{"2":{"167":2}}],["typename",{"2":{"166":2,"167":7,"168":9,"172":1,"173":3,"174":4,"175":1,"176":6,"177":3,"178":10,"180":3,"181":3,"182":2,"183":1}}],["type类型的值",{"2":{"91":1}}],["type类型",{"2":{"91":1,"96":1}}],["typedef",{"2":{"49":2,"81":1,"105":1}}],["type表示元素的类型",{"2":{"40":1}}],["type对象",{"2":{"22":2}}],["type参数",{"2":{"21":1}}],["type的值的引用",{"2":{"19":1}}],["type相同",{"2":{"18":1}}],["type",{"0":{"227":1},"2":{"18":5,"20":1,"26":1,"33":2,"40":1,"44":1,"62":1,"67":1,"71":1,"74":1,"79":1,"81":1,"96":2,"99":1,"107":1,"149":1,"150":1,"153":1,"167":1,"174":2,"177":2,"178":3,"192":1,"207":2,"223":4,"224":1,"225":3,"226":1,"227":1,"229":1,"232":1,"237":1,"247":1,"271":1,"276":2,"327":1}}],["t>>",{"2":{"168":1}}],["t>",{"2":{"15":1,"20":2,"153":1,"166":2,"167":15,"168":3,"172":1,"175":1,"176":6,"177":3,"181":1,"183":1}}],["=default",{"2":{"240":1}}],["=则表示采用值捕获方式",{"2":{"193":1}}],["=运算",{"2":{"99":1}}],["==和",{"2":{"317":1}}],["==",{"2":{"91":1,"96":1,"98":2,"117":1,"140":4,"226":2,"227":1,"294":1,"313":1}}],["==测试代码==",{"2":{"64":1}}],["=",{"2":{"15":2,"19":2,"27":1,"35":6,"40":3,"41":2,"44":7,"45":1,"47":1,"49":7,"52":4,"53":6,"54":1,"55":2,"57":2,"59":4,"60":3,"67":4,"72":2,"73":10,"74":3,"75":2,"76":7,"77":6,"78":6,"79":9,"81":1,"82":18,"83":8,"85":2,"86":2,"90":4,"91":6,"94":2,"96":5,"98":3,"99":2,"101":8,"103":10,"104":2,"105":6,"109":4,"113":2,"121":1,"125":2,"129":6,"131":7,"132":12,"135":1,"138":2,"139":1,"140":1,"141":1,"145":2,"147":1,"148":3,"150":3,"153":5,"156":9,"167":1,"168":5,"173":1,"175":1,"177":2,"192":1,"193":6,"194":1,"196":1,"207":2,"211":2,"222":3,"223":1,"225":2,"226":2,"227":1,"228":2,"229":7,"230":9,"231":4,"233":6,"240":1,"258":1,"263":2,"266":2,"267":2,"269":1,"273":1,"275":2,"276":5,"278":1,"279":2,"282":1,"291":4,"298":3,"299":5,"300":1,"301":1,"302":1,"303":3,"306":1,"317":3,"327":1}}],["e的类型是type的公有基类或者e的类型就是type",{"2":{"225":1}}],["e必须是一个有效的指针",{"2":{"225":1}}],["eobj",{"2":{"207":2}}],["equal",{"2":{"187":1}}],["equal算法",{"2":{"187":1}}],["e2",{"2":{"159":1}}],["e1",{"2":{"159":2}}],["err",{"2":{"294":2}}],["errcodes",{"2":{"207":2}}],["error的对象",{"2":{"293":1}}],["error异常",{"2":{"156":1}}],["error",{"2":{"109":1,"207":2,"293":1,"294":1}}],["erase",{"2":{"203":1,"326":3}}],["erase的返回值总是0或1",{"2":{"21":1}}],["e是一个int",{"2":{"83":1}}],["e是一个const",{"2":{"82":1}}],["e",{"2":{"82":1,"83":1,"98":1,"159":5,"225":3,"226":1}}],["escape",{"2":{"65":1}}],["even",{"2":{"40":2}}],["exception",{"2":{"205":1,"206":1,"207":1,"292":1,"294":1}}],["exclude",{"2":{"15":1}}],["expand",{"2":{"182":1}}],["explicit只能放到类内声明构造函数里",{"2":{"255":1}}],["explicit",{"2":{"150":1,"167":1,"170":1,"173":1}}],["expr2",{"2":{"269":1,"270":5}}],["expr1",{"2":{"269":1,"270":5}}],["expr",{"2":{"46":1,"271":1,"276":2}}],["expression必须是一个序列",{"2":{"286":1}}],["expression部分是一个对象",{"2":{"92":1}}],["expression",{"2":{"37":1,"53":1,"79":1,"92":1,"109":1,"113":1,"157":1,"262":1,"276":1,"278":1,"285":1,"286":1,"292":1}}],["extern",{"0":{"236":1},"2":{"68":1,"236":4}}],["exit",{"2":{"39":2}}],["element",{"2":{"153":1}}],["elements",{"2":{"132":6,"142":3}}],["elem",{"2":{"34":2}}],["else逻辑嵌入到单个表达式当中",{"2":{"269":1}}],["else",{"2":{"17":1,"39":1,"115":1,"225":1}}],["empty",{"2":{"17":1,"91":1,"96":1,"231":6,"316":1}}],["encapsulation",{"2":{"237":1}}],["enum",{"2":{"228":2}}],["enumeration",{"2":{"228":1}}],["engine",{"2":{"159":5}}],["engine类和恰当的分布类对象",{"2":{"158":1}}],["engines",{"2":{"158":1}}],["end函数的值就可能变得无效了",{"2":{"286":1}}],["endangered",{"2":{"215":3,"216":2,"218":1,"219":1}}],["end2",{"2":{"201":1}}],["end成员负责返回指向容器",{"2":{"98":1}}],["endif",{"2":{"46":1,"86":1,"236":1}}],["end",{"2":{"41":1,"98":3,"103":3,"104":1,"114":1,"147":1,"163":1,"174":3,"193":1,"201":4,"202":6,"231":4,"267":1,"291":2,"313":2}}],["endl是一个被称为操纵符",{"2":{"109":1}}],["endl",{"2":{"34":1,"46":1,"55":1,"102":1,"109":3,"148":3,"156":2,"159":2,"161":10,"166":1,"178":1,"180":2,"216":1,"263":1,"279":1,"294":1}}],["ends",{"2":{"5":1}}],["enter",{"2":{"5":1,"109":3,"294":1}}],["都可以使用static",{"2":{"276":1}}],["都可以执行下标运算",{"2":{"103":1}}],["都等于",{"2":{"264":1}}],["都必须完整定义在类的内部",{"2":{"234":1}}],["都是无符号值",{"2":{"325":1}}],["都是由该运算符定义的",{"2":{"261":1}}],["都是左值表达式",{"2":{"178":1}}],["都是默认初始化的",{"2":{"59":1}}],["都会被忽略",{"2":{"172":1}}],["都会使该vector对象的迭代器失效",{"2":{"98":1}}],["都会导致cout的缓冲区被刷新",{"2":{"5":1}}],["都称该函数为递归函数",{"2":{"39":1}}],["都支持9",{"2":{"14":1}}],["有意义的表达式语句",{"2":{"278":1}}],["有效的写法",{"2":{"267":1}}],["有效的迭代器指向某个元素",{"2":{"97":1}}],["有4种运算符明确规定了运算对象的求值顺序",{"2":{"263":1}}],["有默认实参的构造函数",{"2":{"252":1}}],["有些函数也提供了操作类对象的方法",{"2":{"239":1}}],["有可能会把这些函数声明称友元",{"2":{"239":1}}],["有可能出现派生类从两个或更多基类中继承了同名成员的情况",{"2":{"217":1}}],["有可能造成命名冲突",{"2":{"88":1}}],["有例子",{"2":{"176":1}}],["有这样的例子",{"2":{"173":1}}],["有这样的检测条件",{"2":{"117":1}}],["有几个未格式化操作每次一个字节地处理流",{"2":{"162":1}}],["有",{"2":{"99":1}}],["有迭代器的类型同时拥有返回迭代器的成员",{"2":{"98":1}}],["有如下形式",{"2":{"88":1}}],["有一种情况需要特别注意",{"2":{"83":1}}],["有助于程序员清楚地知道使用该类型的真实目的",{"2":{"81":1}}],["有时候我们需要改变派生类继承的某个名字的访问级别",{"2":{"303":1}}],["有时候我们需要给main函数传递实参",{"2":{"35":1}}],["有时候我们会定义这样一种类",{"2":{"299":1}}],["有时候类需要一些只与类相关",{"2":{"258":1}}],["有时候",{"2":{"240":1}}],["有时候可能使用c编译器或c++编译器编译同一个源文件",{"2":{"236":1}}],["有时",{"2":{"207":1}}],["有时我们无法直接获得所需要的类型",{"2":{"174":1}}],["有时我们希望定义这样一种变量",{"2":{"75":1}}],["有两类字符程序员不能直接使用",{"2":{"65":1}}],["有两个主要的关联容器",{"2":{"12":1}}],["有多于一个函数可以匹配",{"2":{"41":1}}],["有返回值函数",{"0":{"39":1}}],["有序的和无序的",{"2":{"14":1}}],["不应该在类内初始化静态数据成员",{"2":{"258":1}}],["不应该被重载",{"2":{"135":1}}],["不使用初始值定义一个局部静态变量时",{"2":{"254":1}}],["不使用初始值定义一个非静态变量或者数组时",{"2":{"254":1}}],["不唯一",{"2":{"228":1}}],["不限定作用域的枚举类型",{"2":{"228":2}}],["不论以什么方式继承b",{"2":{"303":1}}],["不论虚基类在继承体系中出现了多少次",{"2":{"218":1}}],["不论是在程序的什么位置",{"2":{"70":1}}],["不加前缀限定符直接使用该名字将引发二义性",{"2":{"217":1}}],["不会被自动调用",{"2":{"308":1}}],["不会计算对象中的元素占用了多少空间",{"2":{"271":1}}],["不会明确求值的顺序",{"2":{"263":1}}],["不会抛出异常",{"2":{"208":1}}],["不会删除容器的元素",{"2":{"203":1}}],["不会消耗掉缓冲区的内容",{"2":{"4":1}}],["不是有构造函数初始化的",{"2":{"258":1}}],["不是重载的",{"2":{"202":1}}],["不是顶层的",{"2":{"176":1}}],["不读",{"2":{"199":1}}],["不写",{"2":{"199":1}}],["不拷贝其中的元素",{"2":{"195":1}}],["不被使用的",{"2":{"143":1}}],["不需要初始化",{"2":{"138":1}}],["不存在像构造函数中初始化列表的东西控制成员如何销毁",{"2":{"122":1}}],["不允许后续的其他类覆盖",{"2":{"301":1}}],["不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置",{"2":{"282":1}}],["不允许拷贝和赋值",{"2":{"101":1}}],["不允许用auto关键字由初始值的列表推断类型",{"2":{"101":1}}],["不允许两个函数除了返回类型以外其他所有的要素都相同",{"2":{"41":1}}],["不包括最后的空字符",{"2":{"90":1}}],["不指向任何对象",{"2":{"73":1}}],["不管",{"2":{"325":1}}],["不管条件的值如何",{"2":{"287":1}}],["不管写入多少个元素都是安全的",{"2":{"201":1}}],["不管是单个分配的还是数组中的",{"2":{"59":1}}],["不管这种调用是直接的还是间接的",{"2":{"39":1}}],["不过我们也能为一个或几个枚举成员指定专门的值",{"2":{"228":1}}],["不过理解数组的复杂声明时",{"2":{"101":1}}],["不过",{"2":{"40":1,"227":1,"258":1}}],["不过前提是不同函数的形参列表有明显的区别",{"2":{"33":1}}],["不要返回局部对象的引用或指针",{"2":{"39":1}}],["不良设计",{"2":{"33":1}}],["不能转换成一个数值",{"2":{"329":1}}],["不能访问base",{"2":{"303":1}}],["不能访问私有成员",{"2":{"298":1}}],["不能出现在外部",{"2":{"258":1}}],["不能是const的",{"2":{"240":1}}],["不能修改成员变量的内容",{"2":{"238":1}}],["不能够修改其值",{"2":{"238":1}}],["不能从一个左值实例化int",{"2":{"178":1}}],["不能实例化compare",{"2":{"172":1}}],["不能将一个右值引用绑定到一个左值上",{"2":{"131":1}}],["不能为非常量引用绑定到字面值",{"2":{"82":1}}],["不能改变ci的值",{"2":{"78":1}}],["不能改变p1的值",{"2":{"78":1}}],["不能改变其所指对象的值",{"2":{"77":1}}],["不能直接操作void",{"2":{"73":1}}],["不能定义函数类型的形参",{"2":{"49":1}}],["不能发生",{"2":{"46":1}}],["不能省略",{"2":{"34":1}}],["不能用一个常量初始化一个非底层const",{"2":{"33":1}}],["不能对一个multimap或一个unordered",{"2":{"22":1}}],["不同之处在于其下标不必是整数",{"2":{"13":1}}],["值为0的运算对象表示假",{"2":{"265":1}}],["值捕获方式",{"2":{"193":1}}],["值捕获是变量的拷贝",{"2":{"193":1}}],["值初始化在以下情况下发生",{"2":{"254":1}}],["值初始化",{"2":{"94":2}}],["值也显而易见的类型",{"2":{"79":1}}],["值是如何被返回的",{"2":{"39":1}}],["值则表示与之相关的数据",{"2":{"12":1}}],["值对的集合",{"2":{"13":1}}],["值对",{"2":{"12":1}}],["关于这个概念可以参考==测试代码==",{"2":{"303":1}}],["关于异常安全的概念见书本p175",{"2":{"292":1}}],["关于正负号的运算",{"2":{"264":1}}],["关于包扩展和其理解的更多详细的讨论见p621",{"2":{"182":1}}],["关于效率与灵活性的详细讨论见p599",{"2":{"170":1}}],["关于使用直接声明的方法",{"2":{"49":1}}],["关系运算符左右两边的运算对象必须是相同类型的容器",{"2":{"317":1}}],["关系运算符",{"0":{"317":1}}],["关系运算符作用于算术类型或指针类型",{"2":{"265":1}}],["关系运算符和逻辑运算符的类",{"2":{"147":1}}],["关系和算术运算",{"2":{"200":1}}],["关系和位运算等",{"2":{"135":1}}],["关键概念",{"2":{"95":1,"243":1,"319":1}}],["关键是智能指针类能记录有多少个shared",{"2":{"52":1}}],["关键字public和virtual的顺序随意",{"2":{"218":1}}],["关键字类型必须定义元素比较的方法",{"2":{"16":1}}],["关键字类型的要求",{"0":{"16":1}}],["关键字起到索引作用",{"2":{"12":1}}],["关联值将进行值初始化",{"2":{"22":1}}],["关联数组与",{"2":{"13":1}}],["关联容器定义了三个版本的erase",{"2":{"21":1}}],["关联容器的insert成员向容器中添加一个元素或一个元素范围",{"2":{"20":1}}],["关联容器的迭代器都是双向的",{"2":{"14":1}}],["关联容器和算法",{"2":{"19":1}}],["关联容器迭代器",{"0":{"19":1}}],["关联容器还定义了这些类型",{"2":{"18":1}}],["关联容器还支持一些顺序容器不支持的操作",{"2":{"14":1}}],["关联容器操作",{"0":{"18":1},"1":{"19":1,"20":1,"21":1,"22":1,"23":1}}],["关联容器不支持顺序容器的位置相关的操作",{"2":{"14":1}}],["关联容器概述",{"0":{"14":1},"1":{"15":1,"16":1,"17":1}}],["关联容器支持高效的关键字查找和访问",{"2":{"12":1}}],["关联容器中的元素是按关键字来保存和访问的",{"2":{"12":1}}],["关联容器与顺序容器有着根本的不同",{"2":{"12":1}}],["关联容器",{"0":{"12":1},"1":{"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1},"2":{"0":1,"14":1,"312":1}}],["其值为",{"2":{"327":1}}],["其值未定义",{"2":{"240":1}}],["其所得的值是一个size",{"2":{"271":1}}],["其包括运算对象的类型和返回值的类型",{"2":{"261":1}}],["其结果就是字面值和变量的值",{"2":{"259":1}}],["其结果是未定义的",{"2":{"123":1}}],["其隐式参数this的类型改变了",{"2":{"245":1}}],["其区别仅仅在于默认的访问权限",{"2":{"242":1}}],["其原因可能是",{"2":{"240":1}}],["其定义时",{"2":{"238":1}}],["其名字查找将在实参类所属的命名空间中进行",{"2":{"213":1}}],["其名字是由operator关键字后接运算符符号组成",{"2":{"121":1}}],["其形式是",{"2":{"297":1}}],["其形式是关键字noexcept紧跟在函数的参数列表后面",{"2":{"208":1}}],["其形参数量与本次调用提供的实参数量相等",{"2":{"47":1}}],["其调用结果是一个能用作条件的值",{"2":{"191":1}}],["其候选函数包括所有模板实参推断成功的函数模板实例",{"2":{"179":1}}],["其他容器的默认构造函数都会创建一个指定类型的空容器",{"2":{"314":1}}],["其他类直接或间接地从基类继承而来",{"2":{"297":1}}],["其他类型转换都不能应用于函数模板",{"2":{"172":1}}],["其他隐式转换",{"0":{"275":1}}],["其他时候",{"2":{"264":1}}],["其他语言中的函数名字也必须在c++中进行声明",{"2":{"236":1}}],["其他版本与之类似",{"2":{"222":1}}],["其他一些情况下",{"2":{"173":1}}],["其他位为0",{"2":{"155":1}}],["其他所有循环控制变量都应该是引用类型",{"2":{"105":1}}],["其一般形式如下",{"2":{"150":1}}],["其规则是",{"2":{"125":1}}],["其成员被销毁",{"2":{"122":1}}],["其右侧运算对象作为显式参数传递",{"2":{"121":1}}],["其左侧运算对象就绑定到隐式的this参数",{"2":{"121":1}}],["其左侧运算对象必须是一个类类型的对象",{"2":{"117":1}}],["其效果是检测流的状态",{"2":{"114":1}}],["其元素被销毁",{"2":{"122":1}}],["其元素的值未定义",{"2":{"101":1}}],["其元素是一些关键字",{"2":{"12":1}}],["其声明形如a",{"2":{"101":1}}],["其声明在调用点可见",{"2":{"47":1}}],["其它情况都属于无效",{"2":{"97":1}}],["其它vector操作",{"0":{"96":1}}],["其它整型可以划分为带符号的",{"2":{"63":1}}],["其语法格式是",{"2":{"92":1}}],["其顶层const被忽略",{"2":{"82":1}}],["其作用是把等号左侧的名字规定成等号右侧类型的别名",{"2":{"81":1}}],["其后紧跟别名和等号",{"2":{"81":1}}],["其实等同于在不同文件中分别定义了独立的变量",{"2":{"75":1}}],["其实后者不过是声明符的一部分罢了",{"2":{"74":1}}],["其指数部分用e或e标识",{"2":{"65":1}}],["其中每个基类前面可以有访问说明符",{"2":{"297":1}}],["其中每个命名空间是一个作用域",{"2":{"209":1}}],["其中",{"2":{"226":1,"268":1,"270":1,"276":1}}],["其中e可以是任意表达式或类型的名字",{"2":{"226":1}}],["其中又含有一个zooanimal部分",{"2":{"215":1}}],["其中catch执行当前局部能完成的工作",{"2":{"207":1}}],["其中begin成员负责返回指向第一个元素的迭代器",{"2":{"98":1}}],["其中类体部分可为空",{"2":{"85":1}}],["其中d是变量名",{"2":{"73":1}}],["其中d是声明的变量名",{"2":{"72":1}}],["其中必须以字母或下画线开头",{"2":{"69":1}}],["其中变量名以逗号分割",{"2":{"67":1}}],["其中一个至关重要的区别是链表版本的会修改底层的容器",{"2":{"203":1}}],["其中一个必须命名为main",{"2":{"107":1}}],["其中一种运算被大多数类型支持",{"2":{"64":1}}],["其中一项任务是合理设置形参的顺序",{"2":{"44":1}}],["其中算术类型包含了字符",{"2":{"62":1}}],["其行为是未定义的",{"2":{"53":1}}],["其细节将在16",{"2":{"36":1}}],["其解释见书本p185",{"2":{"27":1}}],["其上后续的io操作都会失败",{"2":{"4":1}}],["希望最后一期打印时",{"2":{"11":1}}],["s是",{"2":{"325":2}}],["s是cp指向的数组中前n个字符的拷贝",{"2":{"325":1}}],["sneaky",{"2":{"303":3}}],["same",{"2":{"293":1}}],["sales",{"2":{"16":3,"81":1,"85":2,"86":3,"137":1,"138":2,"139":2,"140":4,"141":3,"210":1,"298":2}}],["switch语句我已经很熟悉了",{"2":{"282":1}}],["switch语句提供了一条便利的途径使得我们能够在若干固定选项中做出选择",{"2":{"282":1}}],["switch语句",{"0":{"282":1}}],["switch",{"2":{"279":1}}],["swap只是交换了两个容器的内部数据结构",{"2":{"315":1}}],["swap",{"2":{"129":2}}],["slope",{"2":{"276":1}}],["sqrt",{"2":{"161":1}}],["ssub",{"2":{"157":1}}],["sstream增加了一些成员来管理与流相关联的string",{"2":{"9":1}}],["sstream头文件定义了三个类型来支持内存io",{"2":{"9":1}}],["sstream",{"2":{"2":1}}],["sregex",{"2":{"157":1}}],["smatch",{"2":{"157":1}}],["smallint的构造函数不是显式的",{"2":{"150":1}}],["smallint",{"2":{"150":4}}],["smart",{"2":{"51":1}}],["svec",{"2":{"147":2,"231":6}}],["synthesized",{"2":{"120":1}}],["s7",{"2":{"90":1}}],["s6",{"2":{"90":1}}],["s5",{"2":{"90":1}}],["s4",{"2":{"90":1}}],["s3是字面值",{"2":{"90":1}}],["s3",{"2":{"90":2}}],["scope",{"2":{"70":4}}],["screen",{"2":{"44":2,"229":9,"230":11}}],["substr",{"2":{"325":3}}],["sum的类型就是函数f的返回类型",{"2":{"83":1}}],["sum",{"2":{"67":1,"83":1,"109":1,"113":1,"139":2,"147":1,"173":3}}],["success",{"2":{"39":1}}],["signature",{"2":{"148":1}}],["signed",{"2":{"63":2}}],["si是sales",{"2":{"81":1}}],["si",{"2":{"81":1,"150":7}}],["sizeof返回的是表达式结果类型的大小",{"2":{"271":1}}],["sizeof运算符的结果部分地依赖于其作用的类型",{"2":{"271":1}}],["sizeof运算符满足右结合律",{"2":{"271":1}}],["sizeof运算符返回一条表达式或一个类型名字所占的字节数",{"2":{"271":1}}],["sizeof运算符",{"0":{"271":1}}],["sizeof",{"2":{"180":3,"271":2}}],["size返回的类型由vector定义的size",{"2":{"96":1}}],["size函数返回的是一个string",{"2":{"91":1}}],["size确定分配多少个int",{"2":{"59":1}}],["size",{"2":{"15":1,"17":1,"20":2,"27":2,"33":2,"41":4,"44":1,"46":4,"59":1,"79":1,"91":3,"92":1,"96":3,"142":2,"150":1,"153":5,"156":3,"167":3,"193":2,"222":7,"223":3,"229":1,"236":1,"291":1,"297":2,"298":1,"299":3,"302":1,"303":4,"309":2,"316":1,"325":2,"327":1}}],["specification",{"2":{"208":1}}],["specifiers",{"2":{"242":1}}],["specifier",{"2":{"67":1}}],["specialization",{"2":{"183":1}}],["sp是指向这块内存的唯一指针",{"2":{"55":1}}],["sp",{"2":{"55":1,"222":2,"223":2}}],["showbase",{"2":{"161":1}}],["shorterstring",{"2":{"41":3}}],["shared的标准库函数返回一个unique",{"2":{"56":1}}],["shared用其参数来构造给定类型的对象",{"2":{"52":1}}],["shared函数",{"2":{"52":1}}],["shared",{"0":{"52":1,"54":1},"2":{"51":1,"52":7,"54":1,"55":2,"57":2,"128":2,"170":1}}],["sz为隐式捕获",{"2":{"193":1}}],["sz和pi的类型不一致",{"2":{"82":1}}],["sz",{"2":{"44":3,"45":2,"79":1,"82":1,"153":1,"156":1,"193":1,"291":2}}],["s2是s1的副本",{"2":{"90":1}}],["s2",{"2":{"41":5,"90":2,"91":5,"177":3,"325":5}}],["s1的值是不确定的",{"2":{"177":1}}],["s1是一个空串",{"2":{"90":1}}],["s1",{"2":{"41":5,"90":4,"91":7,"177":1}}],["sought",{"2":{"278":1}}],["source",{"2":{"108":1}}],["sort接受第三个参数",{"2":{"191":1}}],["sort",{"2":{"147":1}}],["sold",{"2":{"67":4,"85":1,"86":1,"137":1,"138":2,"140":2,"141":2}}],["sold的int变量并初始化为0",{"2":{"67":1}}],["someval",{"2":{"153":1}}],["something",{"2":{"92":2}}],["some",{"2":{"39":1}}],["sot",{"2":{"20":1}}],["s",{"2":{"33":1,"91":6,"92":1,"101":1,"104":3,"132":7,"177":1,"180":1,"193":2,"215":3,"229":3,"231":1,"275":1,"278":2,"303":3,"325":5,"327":1}}],["stof等",{"2":{"329":1}}],["stoul",{"2":{"329":1}}],["stol",{"2":{"329":1}}],["stoi",{"2":{"329":1}}],["standard",{"2":{"109":4}}],["status",{"2":{"207":2}}],["statement一次都不执行",{"2":{"284":1}}],["statement可以是语句块",{"2":{"112":1}}],["statements",{"2":{"107":1,"115":2,"294":2}}],["statement",{"2":{"92":1,"112":1,"113":1,"114":1,"278":3,"284":1,"285":2,"286":2,"287":1,"291":2}}],["static只能出现在类的内部",{"2":{"258":1}}],["static对象在使用之前分配",{"2":{"50":1}}],["static",{"2":{"27":2,"150":1,"167":2,"177":1,"276":6}}],["strcat",{"2":{"236":1}}],["strcmp",{"2":{"183":1,"236":1,"328":1}}],["strlen",{"2":{"236":2}}],["strblob",{"2":{"167":1}}],["strblobptr",{"2":{"143":2,"144":1}}],["strvec",{"2":{"132":5,"141":1,"142":1}}],["str函数返回其c风格的字符串",{"2":{"104":1}}],["str函数",{"2":{"104":1}}],["str",{"2":{"92":2,"104":1,"236":1}}],["struct默认是public",{"2":{"242":1}}],["struct",{"2":{"85":1,"86":1,"215":2,"247":1}}],["string或vector中的任何位置都是合法的",{"2":{"319":1}}],["string或vector插入元素会使所有指向容器的迭代器",{"2":{"319":1}}],["string中匹配的子表达式的结果",{"2":{"157":1}}],["string中下标最大的字符",{"2":{"155":1}}],["string的下标编号习惯于bitset恰好相反",{"2":{"155":1}}],["string的引用",{"2":{"41":1}}],["string可使用c",{"2":{"104":1}}],["string和vector将元素保存在连续的内存空间中",{"2":{"311":1}}],["string和vector的迭代器支持的运算",{"2":{"103":1}}],["string和vector的迭代器提供了额外的运算符",{"2":{"99":1}}],["string和vector都定义了这个类型",{"2":{"99":1}}],["string类和大多数标准库类型都定义了几种配套类型",{"2":{"91":1}}],["string对象上的操作",{"0":{"91":1}}],["string表示可变长的字符序列",{"2":{"89":1}}],["string>>",{"2":{"52":1}}],["string>",{"2":{"15":2,"17":3,"20":1,"52":2,"60":1,"141":2,"147":1,"167":1,"170":2}}],["string",{"0":{"324":1,"325":1,"326":1,"327":1},"1":{"325":1,"326":1,"327":1,"328":1,"329":1},"2":{"15":2,"17":5,"20":3,"33":4,"41":9,"44":2,"49":6,"85":1,"86":1,"90":7,"91":2,"109":1,"126":1,"142":3,"144":2,"147":1,"153":1,"167":1,"177":1,"180":1,"193":1,"200":1,"215":5,"219":1,"222":3,"223":1,"229":5,"231":9,"269":1,"275":1,"282":1,"297":1,"298":3,"299":1,"309":1,"311":1,"320":1,"324":1,"325":9,"326":2,"327":3,"329":2}}],["stringstream既可以从string读数据",{"2":{"9":1}}],["string流",{"0":{"9":1},"1":{"10":1,"11":1}}],["std",{"2":{"55":2,"85":1,"86":1,"88":1,"109":6,"114":1,"126":1,"131":1,"141":2,"142":3,"150":1,"167":2,"177":3,"178":3,"194":1,"203":1,"215":4,"219":1,"229":3,"297":2,"298":2,"299":3,"302":1,"308":1,"309":3}}],["stcreen",{"2":{"44":1}}],["servererr",{"2":{"207":1}}],["seekp",{"2":{"163":2}}],["seekg",{"2":{"163":2}}],["seek和tell函数",{"2":{"163":1}}],["seek",{"2":{"163":1}}],["seed",{"2":{"159":2}}],["search返回true",{"2":{"157":1}}],["search确定一个给定字符序列与一个给定regex是否匹配",{"2":{"157":1}}],["search来遍历一个string中所有匹配的子串",{"2":{"157":1}}],["search",{"2":{"157":1}}],["sequence",{"2":{"65":1}}],["separate",{"2":{"29":1,"68":1}}],["second",{"2":{"17":1}}],["setprecision",{"2":{"161":1}}],["setprecision操纵符接受一个参数",{"2":{"161":1}}],["set类型不支持下标操作",{"2":{"22":1}}],["set或multiset时",{"2":{"19":1}}],["set的迭代器是const的",{"2":{"19":1}}],["set就是关键字的简单集合",{"2":{"13":1}}],["set",{"2":{"12":1,"15":1,"156":5}}],["与vector",{"2":{"311":1}}],["与vector与string不同",{"2":{"22":1}}],["与之类似",{"2":{"303":1}}],["与之相反",{"2":{"222":1}}],["与命名的强制类型转换相比",{"2":{"276":1}}],["与实现",{"2":{"237":1}}],["与实参相关的查找与重载",{"2":{"213":1}}],["与外层类基本没什么关系",{"2":{"232":1}}],["与allocator不同的是",{"2":{"223":1}}],["与它们在继承体系中的次序和位置无关",{"2":{"219":1}}],["与只有一个基类的继承一样",{"2":{"215":1}}],["与从一个基类进行的派生一样",{"2":{"215":1}}],["与其他几个catch语句一起出现",{"2":{"207":1}}],["与其他整型不同",{"2":{"63":1}}],["与仅需几个程序员就能开发完成的系统相比",{"2":{"204":1}}],["与往常一样",{"2":{"172":1}}],["与任何其他blob类型都没有关联",{"2":{"167":1}}],["与函数模板不同之处是",{"2":{"167":1}}],["与函数名无关",{"2":{"49":1}}],["与拷贝构造函数一样",{"2":{"132":1}}],["与string和vector一样",{"2":{"102":1}}],["与s",{"2":{"91":1}}],["与shared",{"2":{"56":2}}],["与指针所指的对象无关",{"2":{"79":1}}],["与被调用函数同名",{"2":{"47":1}}],["与上一个函数相比只有返回类型不同",{"2":{"41":1}}],["与顺序容器一样",{"2":{"21":1}}],["与不能改名map元素的关键字一样",{"2":{"19":1}}],["与key",{"2":{"18":1}}],["与fstream关联的文件默认以in和out模式打开",{"2":{"8":1}}],["与ofstream关联的文件默认以out模式打开",{"2":{"8":1}}],["与ifstream关联的文件默认以in模式打开",{"2":{"8":1}}],["文件被截断",{"2":{"8":1}}],["文件的内容会被丢弃",{"2":{"8":1}}],["文件模式",{"0":{"8":1}}],["文件输入输出",{"0":{"6":1},"1":{"7":1,"8":1}}],["当从容器中删除元素后",{"2":{"323":1}}],["当size为0时返回true",{"2":{"316":1}}],["当当作用于构造函数时",{"2":{"309":1}}],["当存在继承关系时",{"2":{"304":1}}],["当某个虚函数通过指针或引用调用时",{"2":{"301":1}}],["当异常被抛出时",{"2":{"294":1}}],["当程序的某部分检测到一个它无法处理的问题时",{"2":{"292":1}}],["当程序使用多维数组名字时",{"2":{"105":1}}],["当不确定到底要迭代多少次时",{"2":{"284":1}}],["当计算结果超出该类型所能表示的范围时就会产生溢出",{"2":{"264":1}}],["当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效",{"2":{"263":1}}],["当运算符作用于类类型的运算对象时",{"2":{"261":1}}],["当运算对象不属于类类型或者是一个不包含任何虚函数的类时",{"2":{"226":1}}],["当类满足如下条件时",{"2":{"256":1}}],["当类类型的成员没有在构造函数初始值列表中显式初始化时",{"2":{"254":1}}],["当类含有类类型的成员且使用合成的默认构造函数时",{"2":{"254":1}}],["当类的对象释放时",{"2":{"123":1}}],["当发生拷贝等操作时",{"2":{"241":1}}],["当初始化变量时以值传递或函数返回一个对象时",{"2":{"241":1}}],["当初始化一个成员指针时",{"2":{"229":1}}],["当初始化一个非引用类型的变量时",{"2":{"31":1}}],["当成员函数中调用另一个成员函数时",{"2":{"238":1}}],["当union包含的是内置类型的成员时",{"2":{"233":1}}],["当unique",{"2":{"56":1,"59":1}}],["当typeid作用于数组或函数时",{"2":{"226":1}}],["当t是int",{"2":{"176":2}}],["当只传入一个指针类型的实参时",{"2":{"223":1}}],["当自定义了全局的operator",{"2":{"222":1}}],["当前的catch可能会决定由调用链更上一层的函数接着处理异常",{"2":{"207":1}}],["当进入一个catch语句后",{"2":{"207":1}}],["当执行一个throw时",{"2":{"206":1}}],["当执行指针拷贝操作时",{"2":{"31":1}}],["当以引用方式捕获一个变量时",{"2":{"193":1}}],["当以编译时初始化的方式定义一个const对象时",{"2":{"75":1}}],["当向一个函数传递一个lambda时",{"2":{"193":1}}],["当向cout写入数据时",{"2":{"109":1}}],["当扩展一个包时",{"2":{"182":1}}],["当定义一个lambda时",{"2":{"193":1}}],["当定义一个类时",{"2":{"118":1}}],["当定义可变参数版本的print时",{"2":{"181":1}}],["当然",{"2":{"179":1}}],["当两个或多个独立编译的源文件使用了相同的模板",{"2":{"170":1}}],["当模板被使用时才会进行实例化",{"2":{"170":1}}],["当编译器发现一条new表达式或delete表达式后",{"2":{"222":1}}],["当编译器遇到类似t",{"2":{"168":1}}],["当编译器实例化一个模板时",{"2":{"166":1}}],["当操纵符改变流的格式状态时",{"2":{"161":1}}],["当没有用户使用对象时",{"2":{"128":1}}],["当拷贝完成后",{"2":{"127":1}}],["当拷贝一个对象时",{"2":{"126":1}}],["当要决定一个类是否要定义自己的拷贝控制成员时",{"2":{"123":1}}],["当创建panda对象时",{"2":{"219":1}}],["当创建一个具体的function类型时我们必须提供额外的信息",{"2":{"148":1}}],["当创建一个智能指针时",{"2":{"52":1}}],["当创建它的完整表达式结束时被销毁",{"2":{"122":1}}],["当遇到文件结束符",{"2":{"114":1}}],["当遇到一条return语句时函数结束执行过程",{"2":{"26":1}}],["当读取cin",{"2":{"109":1}}],["当数组或其他类似数据结构的下标越界并试图访问非法内存区域时",{"2":{"102":1}}],["当引用被用作初始值时",{"2":{"82":1}}],["当多个文件中出现了同名的const变量时",{"2":{"75":1}}],["当对象被用作左值的时候",{"2":{"261":1}}],["当对象被默认初始化或值初始化时",{"2":{"254":1}}],["当对象在创建时获得了一个特定的值",{"2":{"67":1}}],["当对流应用showbase操纵符时",{"2":{"161":1}}],["当对指向它的指针应用delete运算符时被销毁",{"2":{"122":1}}],["当对一个map进行下标操作时",{"2":{"22":1}}],["当带符号类型取值为负时会出现异常结果",{"2":{"64":1}}],["当把一个整数值赋给浮点类型时",{"2":{"64":1}}],["当把一个浮点数赋给整数类型时",{"2":{"64":1}}],["当把bool值赋给非bool类型时",{"2":{"64":1}}],["当把非bool的算术值赋给bool类型时",{"2":{"64":1}}],["当把函数名作为实参使用",{"2":{"49":1}}],["当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时",{"2":{"64":1}}],["当明确知晓数值不可能为负时",{"2":{"63":1}}],["当一个对象被用作右值的时候",{"2":{"261":1}}],["当一个对象被销毁时",{"2":{"122":1}}],["当一个构造函数委托给另一个构造函数时",{"2":{"253":1}}],["当一个变量不在存在时",{"2":{"241":1}}],["当一个类拥有多个基类时",{"2":{"217":1}}],["当一个类包含一个友元声明时",{"2":{"167":1}}],["当一个函数参数是一个右值引用时",{"2":{"176":1}}],["当一个函数参数是模板类型参数的一个普通",{"2":{"176":1}}],["当一个模板被实例化时",{"2":{"166":1}}],["当一个lambda表达式通过引用捕获变量时",{"2":{"146":1}}],["当一个allocator对象分配内存时",{"2":{"60":1}}],["当一个fstream对象被销毁时",{"2":{"7":1}}],["当分配一大块内存时",{"2":{"60":1}}],["当用一个指向模版参数类型的右值引用函数参数时",{"2":{"178":1}}],["当用作于一个常量对象时",{"2":{"142":1}}],["当用于内置类型的变量时",{"2":{"67":1}}],["当用new分配一个数组时",{"2":{"59":1}}],["当用实参初始化形参时会忽略形参的顶层const",{"2":{"33":1}}],["当动态对象不再使用时",{"2":{"50":1}}],["当应用程序编写完成准备发布时",{"2":{"46":1}}],["当设计含有默认实参的函数时",{"2":{"44":1}}],["当调用一个成员函数时",{"2":{"238":1}}],["当调用一个函数模板时",{"2":{"166":1}}],["当调用重载函数时有三种可能的结果",{"2":{"41":1}}],["当调用这些函数时",{"2":{"41":1}}],["当使用基类的引用或指针时会发生这种情况",{"2":{"304":1}}],["当使用基类的引用",{"2":{"300":1}}],["当使用了赋值运算符时",{"2":{"241":1}}],["当使用了重载函数时",{"2":{"49":1}}],["当使用auto定义一个用lambda初始化的变量时",{"2":{"193":1}}],["当使用argv中的实参时",{"2":{"35":1}}],["当使用模板时",{"2":{"164":1,"166":1}}],["当使用某些拷贝控制操作没有合理意义的情况下",{"2":{"125":1}}],["当使用一个类模板时",{"2":{"167":1}}],["当使用一个istream对象作为条件时",{"2":{"114":1}}],["当使用一个迭代器遍历一个map",{"2":{"19":1}}],["当实参传给main函数之后",{"2":{"35":1}}],["当实参的值被拷贝给形参时",{"2":{"30":1}}],["当将多维数组传递给函数时",{"2":{"34":1}}],["当函数参数本身是const时",{"2":{"176":1}}],["当函数返回类型与参数列表中任何类型都不同时",{"2":{"173":1}}],["当函数不需要对数组元素执行写操作的时候",{"2":{"34":1}}],["当函数的控制路径经过变量定义语句时创建该对象",{"2":{"27":1}}],["当形参是const时",{"2":{"33":1}}],["当形参是引用类型时",{"2":{"30":1}}],["当到达定义所在的块末尾时销毁它",{"2":{"27":1}}],["当解引用一个map迭代器时",{"2":{"22":1}}],["当解引用一个关联容器迭代器时",{"2":{"19":1}}],["当我们delete一个动态分配的对象的指针时",{"2":{"306":1}}],["当我们在派生类中覆盖了某个虚函数时",{"2":{"301":1}}],["当我们定义的函数类似于某个内置运算符时",{"2":{"238":1}}],["当我们定义一个bitset时",{"2":{"155":1}}],["当我们定义一个tuple时",{"2":{"153":1}}],["当我们定义一个unique",{"2":{"56":1}}],["当我们想要使用function为成员函数生成一个可调用对象时",{"2":{"231":1}}],["当我们初始化一个成员指针或为成员指针赋值时",{"2":{"229":1}}],["当我们将含有不可移植特性的程序从一台机器转移到另一台机器上时",{"2":{"235":1}}],["当我们将类类型成员的值改为一个其他值时",{"2":{"233":1}}],["当我们将union的值改为类类型成员对应的值时",{"2":{"233":1}}],["当我们将这两个运算符用于某种类型的指针或引用",{"2":{"224":1}}],["当我们将一个左值",{"2":{"176":1}}],["当我们创建一个panda对象时",{"2":{"219":1}}],["当我们创建一个weak",{"2":{"57":1}}],["当我们给union的某个成员赋值之后",{"2":{"233":1}}],["当我们给函数传递一个类类型的对象时",{"2":{"212":1}}],["当我们给shared",{"2":{"52":1}}],["当我们抛出一条表达式时",{"2":{"206":1}}],["当我们通过一个插入迭代器进行赋值时",{"2":{"196":1}}],["当我们通过一个插入迭代器赋值时",{"2":{"188":1}}],["当我们特例化一个函数模板时",{"2":{"183":1}}],["当我们不能",{"2":{"183":1}}],["当我们既不知道想要处理的实参的数目也不知道它们的类型时",{"2":{"181":1}}],["当我们传递一个右值时",{"2":{"176":1}}],["当我们传递一个非常量对象时",{"2":{"41":1}}],["当我们用一个对象来初始化容器时",{"2":{"319":1}}],["当我们用一个派生类对象为一个基类对象初始化或赋值时",{"2":{"300":1}}],["当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时",{"2":{"175":1}}],["当我们用完对象后",{"2":{"60":1}}],["当我们调用newcallable时",{"2":{"194":1}}],["当我们调用一个函数时",{"2":{"166":1}}],["当我们调用compare时",{"2":{"166":1}}],["当我们说随机数发生器时",{"2":{"159":1}}],["当我们使用指针或引用调用虚函数时",{"2":{"298":1}}],["当我们使用bind时",{"2":{"231":1}}],["当我们使用一条delete表达式删除一个动态分配的对象时",{"2":{"222":1}}],["当我们使用一条new表达式时",{"2":{"222":1}}],["当我们使用一个类类型的对象时",{"2":{"166":1}}],["当我们使用一个整型值来初始化bitset时",{"2":{"155":1}}],["当我们使用这类算法时",{"2":{"188":1}}],["当我们使用",{"2":{"166":1}}],["当我们使用字符串表示数时",{"2":{"155":1}}],["当我们希望将一些数据组合成单一对象",{"2":{"152":1}}],["当我们编写了一个lambda后",{"2":{"146":1}}],["当我们编写一个移动操作时",{"2":{"132":1}}],["当我们赋给带符号类型一个超出它表示范围的值时",{"2":{"64":1}}],["当我们赋给无符号类型一个超出它表示范围的值时",{"2":{"64":1}}],["当我们把函数名作为一个值使用的时候",{"2":{"49":1}}],["当我们为函数传递一个数组时",{"2":{"34":1}}],["当我们逐步构造输出",{"2":{"11":1}}],["当我们的某些工作是对整行文本进行处理",{"2":{"10":1}}],["当我们打开一个ofstream时",{"2":{"8":1}}],["当未指定文件模式时",{"2":{"8":1}}],["当想要读写一个文件时",{"2":{"7":1}}],["override",{"2":{"297":1,"298":1,"299":1}}],["overloaded",{"2":{"121":1,"261":1}}],["overload",{"2":{"41":1}}],["oop概述",{"0":{"297":1},"1":{"298":1,"299":1,"300":1}}],["oriented",{"2":{"297":1}}],["or",{"2":{"294":1}}],["or减1",{"2":{"267":2}}],["order",{"2":{"155":2}}],["operand",{"2":{"259":1}}],["operator>>",{"2":{"138":1}}],["operator++",{"2":{"143":2}}],["operator+=",{"2":{"135":1,"141":1}}],["operator+",{"2":{"135":1,"139":1}}],["operator==",{"2":{"140":1,"167":2}}],["operator=",{"2":{"121":1,"125":1,"129":1,"132":1,"133":1,"141":1,"308":3}}],["operator",{"2":{"26":1,"118":2,"121":1,"137":2,"140":1,"142":2,"143":2,"144":2,"145":2,"147":1,"150":3,"216":1,"222":11,"225":1,"259":1,"261":3,"272":1}}],["open",{"2":{"228":1}}],["onexhibit",{"2":{"215":2,"219":4}}],["onbits",{"2":{"156":1}}],["other",{"2":{"201":4,"207":1}}],["obj",{"2":{"172":2}}],["object",{"2":{"27":2,"145":1,"206":1,"297":1}}],["octal",{"2":{"161":2}}],["oct",{"2":{"161":3}}],["occurs",{"2":{"33":1}}],["os",{"2":{"91":1,"137":2,"162":2,"172":2,"181":5,"182":3}}],["ostream",{"2":{"137":1,"172":2,"181":4,"182":2,"197":1,"216":2}}],["ostream等也都是以类的形式定义的",{"2":{"84":1}}],["ostringstream是很有用的",{"2":{"11":1}}],["ostringstream向string写入数据",{"2":{"9":1}}],["odd",{"2":{"40":3}}],["of",{"2":{"107":1,"109":1,"114":1,"150":1,"320":1,"327":1,"329":1}}],["off",{"2":{"98":1,"163":2}}],["ofile",{"2":{"35":2}}],["ofstream",{"2":{"7":1,"8":2}}],["o",{"2":{"33":1,"35":2}}],["output",{"2":{"109":1,"228":1}}],["outer",{"2":{"70":1}}],["out",{"2":{"7":1,"8":1,"150":1,"329":1}}],["ok",{"2":{"4":1,"131":1}}],["并显式地调用它",{"2":{"302":1}}],["并把控制权转移给能处理该异常的代码",{"2":{"293":1}}],["并把运算对象看成是二进制位的集合",{"2":{"270":1}}],["并从这些语句之后的第一条语句开始执行",{"2":{"289":1}}],["并从右侧运算对象拷贝string",{"2":{"127":1}}],["并返回非常量引用",{"2":{"246":1}}],["并返回一个空指针",{"2":{"53":1}}],["并至少提供下面的操作",{"2":{"227":1}}],["并不会执行向指针的标准类型转换",{"2":{"226":1}}],["并不销毁原来指向的对象",{"2":{"59":1}}],["并为其传入初始值",{"2":{"222":1}}],["并在调用该函数的函数中继续寻找",{"2":{"294":1}}],["并在调用时加入到候选函数中",{"2":{"213":1}}],["并在以下几方面影响函数匹配规则",{"2":{"179":1}}],["并传递给它arg",{"2":{"194":1}}],["并提供了相同的模板参数时",{"2":{"170":1}}],["并且是一个左值",{"2":{"266":1}}],["并且该声明必须指定返回类型和形参列表",{"2":{"236":1}}],["并且该类型自定义了默认构造函数或拷贝控制成员",{"2":{"233":1}}],["并且该类型含有虚函数时",{"2":{"224":1}}],["并且可以从成员指针生成一个可调用对象",{"2":{"231":1}}],["并且通常情况下该类型应该含有虚函数",{"2":{"225":1}}],["并且能够处理超过最长整型类型大小的位集合",{"2":{"154":1}}],["并且为了处理这种可能性而做一些额外的工作",{"2":{"132":1}}],["并且直到程序终止才被销毁",{"2":{"27":1}}],["并销毁对象的非static数据成员",{"2":{"122":1}}],["并存入给定对象中",{"2":{"109":1}}],["并初始化",{"2":{"109":1}}],["并将其初始化成序列中的下一个值",{"2":{"286":1}}],["并将其映射到指定的分布",{"2":{"159":1}}],["并将它绑定到模板参数t",{"2":{"166":1}}],["并将与设备关联的缓冲区",{"2":{"109":1}}],["并将对象与文件关联起来",{"2":{"7":1}}],["并以一个或多个",{"2":{"292":1}}],["并以空字符结尾",{"2":{"104":1}}],["并以下述这组函数及其调用为例",{"2":{"47":1}}],["并获取其成员mem",{"2":{"98":1}}],["并能在恰当的时候自动释放对象",{"2":{"52":1}}],["并释放与之关联的内存",{"2":{"51":1}}],["并生成调用该函数的代码",{"2":{"41":1}}],["并视情况打开为读或写模式",{"2":{"7":1}}],["来访问",{"2":{"249":1}}],["来访问对象",{"2":{"73":1}}],["来执行默认初始化",{"2":{"240":1}}],["来执行函数",{"2":{"26":1}}],["来实现数据抽象和封装",{"2":{"237":1}}],["来条件引入",{"2":{"236":1}}],["来代替",{"2":{"202":1}}],["来触发扩展操作",{"2":{"182":1}}],["来避免这种开销",{"2":{"170":1}}],["来避免头文件重复包含",{"2":{"86":1}}],["来达到这一目的",{"2":{"159":1}}],["来阻止拷贝",{"2":{"125":1}}],["来调用一个函数",{"2":{"117":1}}],["来表达我们需要",{"2":{"117":1}}],["来表示",{"2":{"63":2}}],["来表示一个范围",{"2":{"34":1}}],["来保存输入",{"2":{"109":1}}],["来提供io机制",{"2":{"109":1}}],["来定位",{"2":{"163":1}}],["来定位给定的文件",{"2":{"7":1}}],["来定义自己的数据结构",{"2":{"116":1}}],["来定义类型的别名",{"2":{"81":1}}],["来将动态内存归还给系统",{"2":{"53":1}}],["来显式刷新缓冲区",{"2":{"5":1}}],["它默认值是0",{"2":{"327":1}}],["它还定义了额外的",{"2":{"326":1}}],["它还没有这个能力",{"2":{"206":1}}],["它除了销毁派生类自己的成员外",{"2":{"307":1}}],["它在do",{"2":{"287":1}}],["它重复执行操作直到满足某个条件才停下来",{"2":{"283":1}}],["它计算一个整型表达式的值",{"2":{"280":1}}],["它根据条件决定控制流",{"2":{"280":1}}],["它首先对左侧的表达式求值",{"2":{"272":1}}],["它有两种形式",{"2":{"271":1}}],["它对运算对象的数量没有限制",{"2":{"261":1}}],["它对应的实参的const属性和左值",{"2":{"178":1}}],["它并非函数声明",{"2":{"243":1}}],["它并不生成代码",{"2":{"166":1}}],["它用类内初始值初始化",{"2":{"240":1}}],["它才获得const属性",{"2":{"240":1}}],["它才可以有默认实参",{"2":{"168":1}}],["它才可以释放string",{"2":{"128":1}}],["它使得某个命名空间中所有的名字都可见",{"2":{"211":1}}],["它使得我们可以清楚地知道程序中所用的到底是哪个名字",{"2":{"211":1}}],["它使用实际的模板实参代替对应的模板参数来创建出模板的一个新",{"2":{"166":1}}],["它可以作为给默认的实现给派生类型调用",{"2":{"302":1}}],["它可以与任意类型的异常匹配",{"2":{"207":1}}],["它可以是左值引用",{"2":{"207":1}}],["它只有一个分号",{"2":{"278":1}}],["它只是简单地返回指针实参",{"2":{"223":1}}],["它只是为一个已经存在的对象所起的另外一个名字",{"2":{"72":1}}],["它只会迁移元素",{"2":{"203":1}}],["它接受一个容器",{"2":{"196":1}}],["它接受一个可调用对象",{"2":{"194":1}}],["它接受一个随机数引擎作为参数",{"2":{"159":1}}],["它利用元素类型的",{"2":{"189":1}}],["它假定第二个序列至少与第一个序列一样长",{"2":{"187":1}}],["它比较两个序列中的元素",{"2":{"187":1}}],["它",{"2":{"182":1}}],["它能保持原始实参的类型",{"2":{"178":1}}],["它未出现在函数参数列表中",{"2":{"173":1}}],["它不会影响派生类本身",{"2":{"218":1}}],["它不会在本文件中生成实例化代码",{"2":{"170":1}}],["它不会知道mem是一个类型成员还是一个static数据成员",{"2":{"168":1}}],["它返回从一个特定时刻到当前经过了多少秒",{"2":{"159":1}}],["它返回指定成员的引用",{"2":{"153":1}}],["它定义在头文件functional中",{"2":{"194":1}}],["它定义在头文件iomanip中",{"2":{"161":1}}],["它定义在头文件ctime中",{"2":{"159":1}}],["它定义在头文件regex中",{"2":{"157":1}}],["它包含多个组件",{"2":{"157":1}}],["它类似array类",{"2":{"155":1}}],["它负责为对象的成员变量赋初值",{"2":{"240":1}}],["它负责将一个类类型的值转换成其他类型",{"2":{"150":1}}],["它负责接受一个int类型的实参",{"2":{"145":1}}],["它就能执行某些特殊的优化操作",{"2":{"208":1}}],["它就应该定义所有五个操作",{"2":{"132":1}}],["它就会被初始化为一个空指针",{"2":{"54":1}}],["它就会自动释放自己所管理的对象",{"2":{"52":1}}],["它没有返回值",{"2":{"122":1}}],["它仅在循环内部存在",{"2":{"113":1}}],["它由三部分组成",{"2":{"113":1}}],["它由一个或多个运算对象和",{"2":{"109":1}}],["它从给定的istream读入数据",{"2":{"109":1}}],["它以一个后缀为结尾",{"2":{"108":1}}],["它什么都不做",{"2":{"107":1}}],["它指向容器的一个元素",{"2":{"99":2}}],["它指向一个shared",{"2":{"57":1}}],["它把解引用和成员访问两个操作结合在一起",{"2":{"98":1}}],["它和c的ctype",{"2":{"92":1}}],["它和其他大多数定义在函数体之外的名字一样拥有全局作用域",{"2":{"70":1}}],["它是调用",{"2":{"326":1}}],["它是原始",{"2":{"325":1}}],["它是变量声明时的类型或表达式生成的类型",{"2":{"300":1}}],["它是malloc返回的指针的副本",{"2":{"222":1}}],["它是我们想打印的类类型",{"2":{"137":1}}],["它是一个重要的例外",{"2":{"306":1}}],["它是一个const成员函数",{"2":{"146":1}}],["它是一对圆括号",{"2":{"117":1}}],["它是一种弱引用",{"2":{"51":1}}],["它是用一对双引号包围的字符序列",{"2":{"109":1}}],["它是某种类型的同义词",{"2":{"81":1}}],["它必须指向由allocate分配的内存",{"2":{"60":1}}],["它分配的内存是原始的",{"2":{"60":1}}],["它帮助我们将内存分配和对象构造分离开来",{"2":{"60":1}}],["它所嵌套着的所有作用域中都能访问该名字",{"2":{"70":1}}],["它所能表示的数据范围也不一样",{"2":{"63":1}}],["它所指向的对象也被销毁",{"2":{"56":1}}],["它所占用的存储空间也随之被释放掉",{"2":{"39":1}}],["它会先被提升为int",{"2":{"270":1}}],["它会对每个成员进行值初始化",{"2":{"153":1}}],["它会在赋值运算符结束时被自动销毁",{"2":{"129":1}}],["它会根据给定对象类型来确定恰当的内存大小和对齐位置",{"2":{"60":1}}],["它会抛出一个类型为bad",{"2":{"53":1}}],["它会自动转换成指针",{"2":{"49":1}}],["它后面的所有形参都必须有默认值",{"2":{"44":1}}],["它将执行默认初始化",{"2":{"240":1}}],["它将隐藏外层作用域中声明的同名实体",{"2":{"42":1}}],["它将绑定到对应的实参上",{"2":{"30":1}}],["它的派生类部分将被忽略掉",{"2":{"300":1}}],["它的动态类型则依赖于item绑定的实参",{"2":{"300":1}}],["它的目的是将ival初始化为6",{"2":{"273":1}}],["它的内存",{"2":{"223":1}}],["它的有效范围从using声明的地方开始",{"2":{"211":1}}],["它的删除器是类类型的一部分",{"2":{"170":1}}],["它的删除器需要间接保存",{"2":{"170":1}}],["它的作用是选择并返回操作数的数据类型",{"2":{"83":1}}],["它的值不能被改变",{"2":{"75":1}}],["它的值由定义的位置决定",{"2":{"67":1}}],["它的行为有点类似于内联函数",{"2":{"46":1}}],["它的形式无外乎以下两种",{"2":{"36":1}}],["它的元素是指向c风格字符串的指针",{"2":{"35":1}}],["它表示函数不返回任何类型",{"2":{"27":1}}],["它作用于一个表达式",{"2":{"26":1}}],["它们都返回一个",{"2":{"327":1}}],["它们都有4个重载版本",{"2":{"327":1}}],["它们都允许多个元素具有相同的关键字",{"2":{"15":1}}],["它们标记了容器中元素的一个范围",{"2":{"313":1}}],["它们不支持元素的随机访问",{"2":{"311":1}}],["它们对类本身的成员依次进行初始化",{"2":{"307":1}}],["它们被称作隐式转换",{"2":{"273":1}}],["它们被绑定到模版参数",{"2":{"167":1}}],["它们是隐式静态的",{"2":{"222":1}}],["它们实现了一些经典算法的公共接口",{"2":{"184":1}}],["它们正常转换为对应形参的类型",{"2":{"172":1}}],["它们会读取而不是忽略空白符",{"2":{"162":1}}],["它们定义了一个调用运算符",{"2":{"159":1}}],["它们定义在functional头文件中",{"2":{"147":1}}],["它们可以把类的一个对象赋值给类的另一个对象",{"2":{"141":1}}],["它们的名字由关键字operator和其后要定义的运算符号共同组成",{"2":{"135":1}}],["它们体现的是标准库与机器无关的特性",{"2":{"91":1}}],["它们仅在函数的作用域内可见",{"2":{"27":1}}],["它们分别定义在同名的头文件中",{"2":{"2":1}}],["它完成一些系统相关的操作",{"2":{"7":1}}],["what",{"2":{"294":1}}],["while循环的内部",{"2":{"290":1}}],["while循环的外面也无法访问",{"2":{"287":1}}],["while和do",{"2":{"290":1}}],["while和for语句在执行循环体之前检查条件",{"2":{"283":1}}],["while和for语句的控制结构内定义变量",{"2":{"279":1}}],["while的条件部分可以是一个表达式或者是一个带初始化的变量声明",{"2":{"284":1}}],["while的条件部分把cin转换成布尔值",{"2":{"275":1}}],["while语句的语法形式如下",{"2":{"287":1}}],["while语句的形式为",{"2":{"112":1}}],["while语句和while语句非常相似",{"2":{"287":1}}],["while语句先执行循环体后检查条件",{"2":{"287":1}}],["while语句先执行循环体",{"2":{"283":1}}],["while语句反复执行一段代码",{"2":{"112":1}}],["while语句",{"0":{"112":1,"284":1,"287":1}}],["while",{"2":{"19":1,"162":1,"267":1,"275":1,"284":1,"287":1,"289":1}}],["wc",{"2":{"193":1}}],["wages是double的同义词",{"2":{"81":1}}],["wages",{"2":{"81":1}}],["warning",{"2":{"5":1,"34":1,"35":1,"36":1,"64":1,"67":1,"73":1,"83":1,"102":1,"132":1,"161":1,"166":1,"170":1,"181":1,"193":1,"217":1,"222":1,"224":1,"264":1,"270":1,"276":1,"306":1,"319":1,"321":1}}],["w",{"2":{"59":1}}],["wp若共享p",{"2":{"57":1}}],["wp",{"2":{"57":2}}],["weak",{"0":{"57":1},"2":{"57":2}}],["weed",{"2":{"20":1}}],["window",{"2":{"44":3}}],["width",{"2":{"229":1}}],["wid",{"2":{"44":1}}],["world",{"2":{"33":1}}],["words",{"2":{"193":2}}],["word",{"2":{"4":1,"15":1,"19":2,"20":7}}],["向容器添加元素后",{"2":{"323":1}}],["向容器添加或从元素中删除元素的代价",{"2":{"311":1}}],["向一个deque",{"2":{"319":1}}],["向顺序容器添加元素",{"0":{"319":1}}],["向后跳过一个带初始化的变量定义是合法的",{"2":{"291":1}}],["向算法传递函数",{"0":{"191":1}}],["向bool的类型转换通常用在条件部分",{"2":{"150":1}}],["向流写入数据",{"2":{"109":1}}],["向vector中添加元素",{"0":{"95":1}}],["向实参添加顶层const或者从实参中删除顶层const",{"2":{"48":1}}],["向map添加元素",{"2":{"20":1}}],["向缓冲区插入一个空字符",{"2":{"5":1}}],["向量和数组",{"0":{"87":1},"1":{"88":1,"89":1,"90":1,"91":1,"92":1,"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1},"2":{"0":1}}],["但之后的迭代器会失效",{"2":{"323":1}}],["但这里基类的析构函数并不遵顼这个准则",{"2":{"306":1}}],["但这会遇到一个问题",{"2":{"150":1}}],["但该函数并没有覆盖已存在的虚函数",{"2":{"301":1}}],["但派生类并不能直接初始化这些成员",{"2":{"299":1}}],["但派生类的成员函数不一定有权访问从基类继承而来的成员",{"2":{"298":1}}],["但遇到像net",{"2":{"298":1}}],["但若是结合实际情况",{"2":{"268":1}}],["但他们不属于类的成员函数",{"2":{"239":1}}],["但并非所有特性都如此",{"2":{"233":1}}],["但并非必须",{"2":{"135":1}}],["但实际上派生类可以多次继承同一个类",{"2":{"218":1}}],["但代价太高",{"2":{"203":1}}],["但如果捕获列表不为空就不能直接代替了",{"2":{"194":1}}],["但与函数不同",{"2":{"192":1}}],["但依赖于元素类型的操作",{"2":{"185":1}}],["但它作为一个函数参数传递给g",{"2":{"178":1}}],["但它们的初始值却受到严格限制",{"2":{"79":1}}],["但却不能接受右值引用参数的函数",{"2":{"178":1}}],["但在赋值之后",{"2":{"177":1}}],["但模板参数t是int",{"2":{"176":1}}],["但",{"2":{"174":1}}],["但必须只有一个定义",{"2":{"170":1}}],["但成员函数的定义不必已经出现",{"2":{"166":1}}],["但看起来typename更加直观",{"2":{"166":1}}],["但对于一个给定的发生器",{"2":{"159":1}}],["但又不想麻烦地定义一个新数据结构来表示这些数据时",{"2":{"152":1}}],["但一个tuple可以有任意数量的成员",{"2":{"152":1}}],["但类的运算符是显式的",{"2":{"150":1}}],["但有一种例外",{"2":{"150":1}}],["但有时在移动操作完成后",{"2":{"132":1}}],["但我们可以用static",{"2":{"177":1}}],["但我们可以显式地将一个左值转换为对应的右值引用类型",{"2":{"131":1}}],["但我们希望像一个右值一样处理它",{"2":{"131":1}}],["但只有当最后一个指向string的hasptr对象销毁时",{"2":{"128":1}}],["但只在真正需要时才真正执行对象创建操作",{"2":{"60":1}}],["但程序设计语言提供了多种不同的控制语句",{"2":{"111":1}}],["但是没有使用作用域运算符",{"2":{"301":1}}],["但是没有说明运算对象按照什么顺序求值",{"2":{"263":1}}],["但是逻辑上需要多条语句",{"2":{"278":1}}],["但是通过p写值是未定义的行为",{"2":{"276":1}}],["但是求值结果是运算对象改变之前那个值的副本",{"2":{"267":1}}],["但是谁先调用无从得知",{"2":{"263":1}}],["但是运算对象的个数",{"2":{"261":1}}],["但是如此一来",{"2":{"246":1}}],["但是如果union含有类类型的成员",{"2":{"233":1}}],["但是如果从多个基类中继承了相同的构造函数",{"2":{"215":1}}],["但是生成的代码有所区别",{"2":{"236":1}}],["但是由于union既不能继承自其他类",{"2":{"233":1}}],["但是在任意时刻只有一个数据成员可以有值",{"2":{"233":1}}],["但是在某个给定的派生列表中",{"2":{"215":1}}],["但是可以定义在类的内部或者外部",{"2":{"232":1}}],["但是可以被多次声明",{"2":{"68":1}}],["但是不指定该成员所属的对象",{"2":{"229":1}}],["但是不会释放内存",{"2":{"223":1}}],["但是不管怎样",{"2":{"222":1}}],["但是不能定义在函数或类的内部",{"2":{"210":1}}],["但是不能通过cptr改变dval的值",{"2":{"77":1}}],["但是不能用它代替真正的运行时逻辑检查",{"2":{"46":1}}],["但是",{"2":{"167":1,"168":1,"174":1,"176":1,"181":1,"311":3}}],["但是我们能使用哪些成员仍然是由静态类型决定的",{"2":{"304":1}}],["但是我们可以把形参写成类似数组的形式",{"2":{"34":1}}],["但是我实验发现",{"2":{"159":1}}],["但是用户不能对其值进行任何假设",{"2":{"132":1}}],["但是移动操作对移后源对象中留下的值没有任何要求",{"2":{"132":1}}],["但是有时我们希望进行的操作需要更多的参数",{"2":{"192":1}}],["但是有时候我们希望直接管理资源",{"2":{"128":1}}],["但是有两个例外",{"2":{"76":1,"77":1}}],["但是声明符的形式却可以不同",{"2":{"74":1}}],["但是对大小写敏感",{"2":{"69":1}}],["但是形参可以是指向函数的指针",{"2":{"49":1}}],["但是这些操作通常应该看成一个整体",{"2":{"123":1}}],["但是这些代码只在开发程序时使用",{"2":{"46":1}}],["但是这种形式对于返回类型比较复杂的函数最有效",{"2":{"40":1}}],["但是每一个都不是明显的最佳选择",{"2":{"41":1}}],["但是执行的操作非常类似",{"2":{"41":1}}],["但是反过来不行",{"2":{"33":1}}],["但可以给",{"2":{"302":1}}],["但可以用move获得一个绑定到左值上的右值引用",{"2":{"177":1}}],["但可以声明多次",{"2":{"28":1}}],["但可以是指向数组或函数的指针",{"2":{"27":1}}],["但不是必须的",{"2":{"299":1}}],["但不会详细介绍编写异常处理的代码",{"2":{"292":1}}],["但不会把它存入字符串中",{"2":{"91":1}}],["但不完全相同",{"2":{"203":1}}],["但不从流中删除它",{"2":{"162":1}}],["但不必是常量",{"2":{"59":1}}],["但不能是右值引用",{"2":{"207":1}}],["但不能以任何方式使用它们",{"2":{"125":1}}],["但不能修改",{"2":{"19":1}}],["但不能改变关键字成员的值",{"2":{"19":1}}],["但不输出任何额外字符",{"2":{"5":1}}],["但也有可能被操作系统保存在缓冲区中",{"2":{"5":1}}],["刷新缓冲区",{"2":{"5":1}}],["刷新输出缓冲区",{"2":{"5":1}}],["fn生成一个可调用对象",{"2":{"231":1}}],["fp",{"2":{"231":2}}],["f可以改变它捕获的变量的值",{"2":{"193":1}}],["f只是改变了flip1的形参",{"2":{"178":1}}],["f的形参b",{"2":{"178":1}}],["f改变了实参i",{"2":{"178":1}}],["f所做的改变就不会影响实参",{"2":{"178":1}}],["f3",{"2":{"148":2,"176":4}}],["f2的函数参数都被推断为const",{"2":{"176":1}}],["f2中的参数是const",{"2":{"176":1}}],["f2",{"2":{"148":2,"176":4,"263":1}}],["f1",{"2":{"148":2,"176":4,"263":1}}],["friend",{"2":{"167":4,"243":1}}],["from可以是",{"2":{"163":1}}],["from",{"2":{"163":2}}],["front的迭代器",{"2":{"196":1}}],["front",{"2":{"14":1,"196":1}}],["free将相关内存返回给系统",{"2":{"222":1}}],["free函数接受一个void",{"2":{"222":1}}],["free",{"2":{"132":7,"222":1}}],["f是const",{"2":{"82":1}}],["floatprec",{"2":{"228":1}}],["float以1个字",{"2":{"63":1}}],["flag",{"2":{"219":1}}],["flip2中对g的调用将传递给g的右值引用参数一个左值",{"2":{"178":1}}],["flip2",{"2":{"178":1}}],["flip1的形参不会改变它的实参j",{"2":{"178":1}}],["flip1的形参t1",{"2":{"178":1}}],["flip1",{"2":{"178":2}}],["flip1是一个不完整的实现",{"2":{"178":1}}],["flip",{"2":{"156":2,"178":1}}],["flush",{"2":{"5":1}}],["f",{"2":{"44":1,"47":6,"55":2,"82":1,"83":1,"168":7,"176":3,"178":14,"193":2,"225":1,"231":3,"301":1}}],["fail",{"2":{"269":1}}],["failure",{"2":{"39":2}}],["false",{"2":{"156":2,"161":2,"219":1}}],["factor",{"2":{"20":1}}],["foo>",{"2":{"168":1}}],["foo",{"2":{"36":2,"45":1,"49":3,"120":4,"121":3,"122":1,"133":3,"167":2,"168":3,"180":4,"210":1,"261":2}}],["for或switch语句",{"2":{"289":1}}],["forward会保持实参类型的所有细节",{"2":{"178":1}}],["forward可以保持给定实参是左值",{"2":{"178":1}}],["forward",{"2":{"178":5,"247":1,"311":1,"316":1}}],["forward返回该显式实参类型的右值引用",{"2":{"178":1}}],["forward必须通过显式模板实参来调用",{"2":{"178":1}}],["forward定义在头文件utility中",{"2":{"178":1}}],["forward保持类型信息",{"2":{"178":1}}],["for语句的语法形式是",{"2":{"285":1}}],["for语句",{"0":{"113":1}}],["for语句内定义的名字",{"2":{"70":1}}],["for",{"2":{"34":1,"92":1,"285":1,"286":2}}],["final和override说明符",{"2":{"301":1}}],["final",{"2":{"299":1,"301":1}}],["finalgrade",{"2":{"269":1}}],["finalfcn",{"2":{"178":1}}],["find用元素类型的==运算符完成序列中的元素与给定值的比较",{"2":{"185":1}}],["find",{"2":{"33":2,"193":1,"202":2,"231":3,"327":1}}],["first",{"2":{"132":6,"233":1,"327":1}}],["file2",{"2":{"8":1}}],["file1",{"2":{"8":1}}],["file",{"2":{"7":1,"46":1,"108":1,"114":1,"282":2}}],["fcn类型的是",{"2":{"231":1}}],["fcn生成的可调用对象既可以通过对象调用",{"2":{"231":1}}],["fcn也定义在functional头文件中",{"2":{"231":1}}],["fcn来让编译器负责推断成员的类型",{"2":{"231":1}}],["fcn3",{"2":{"193":1}}],["fcn2",{"2":{"174":1}}],["fcn",{"2":{"33":2,"174":2,"231":5}}],["funcp是函数指针类型",{"2":{"49":1}}],["funcp",{"2":{"49":3}}],["func是函数类型",{"2":{"49":1}}],["func接受一个int类型的实参",{"2":{"40":1}}],["func返回一个指向含有10个整数的数组的指针",{"2":{"40":1}}],["func",{"2":{"40":7,"46":3,"49":3,"192":1}}],["function",{"2":{"26":3,"28":1,"39":1,"40":1,"41":1,"47":2,"107":1,"117":1,"125":1,"145":1,"148":2,"166":1,"192":1,"231":1,"297":1}}],["funhouse",{"2":{"20":1}}],["fstream中定义的类型还增加了一些新的成员来管理与流关联的文件",{"2":{"6":1}}],["fstream",{"2":{"2":1}}],["如上述例子的写法",{"2":{"279":1}}],["如何选择视具体环境而定",{"2":{"270":1}}],["如何初始化类的对象是由类本身决定的",{"2":{"90":1}}],["如string的接受一个const",{"2":{"255":1}}],["如std",{"2":{"88":1}}],["如下所示是编写operator",{"2":{"222":1}}],["如非内联函数",{"2":{"210":1}}],["如ostream",{"2":{"200":1}}],["如容器大小足够",{"2":{"188":1}}],["如查找元素",{"2":{"184":1}}],["如t",{"2":{"178":1}}],["如i",{"2":{"176":1}}],["如整型是几进制",{"2":{"161":1}}],["如递增",{"2":{"135":1}}],["如调用标准库容器的insert或push成员时",{"2":{"120":1}}],["如都一样",{"2":{"96":1}}],["如类",{"2":{"86":1}}],["如引号",{"2":{"65":1}}],["如退格或其他控制字符",{"2":{"65":1}}],["如可作为函数的返回值",{"2":{"62":1}}],["如",{"2":{"44":3,"45":1,"91":1,"92":1,"93":1,"96":1,"98":2,"101":2,"104":2,"105":2,"176":1,"193":1,"194":1,"203":1,"263":1}}],["如传递首元素和尾后元素的指针",{"2":{"34":1}}],["如c风格字符串",{"2":{"34":1}}],["如endl",{"2":{"5":1}}],["如果转换得到的数值无法用任何类型来表示",{"2":{"329":1}}],["如果转换目标是引用类型并且失败了",{"2":{"225":1}}],["如果",{"2":{"329":1}}],["如果搜索失败",{"2":{"327":1}}],["如果空间未重新分配",{"2":{"323":1}}],["如果未提供",{"2":{"322":1}}],["如果当前大小小于新大小",{"2":{"322":1}}],["如果当前大小大于所要求的大小",{"2":{"322":1}}],["如果下标越界",{"2":{"320":1}}],["如果容器是vector或string",{"2":{"323":1}}],["如果容器中没有元素",{"2":{"320":1}}],["如果容器为空",{"2":{"98":1}}],["如果begin与end不等",{"2":{"313":1}}],["如果begin与end相等",{"2":{"313":1}}],["如果bitset的大小大于unsigned",{"2":{"155":1}}],["如果d继承b的方式是私有的",{"2":{"303":1}}],["如果d继承b的方式是公有的或者受保护的",{"2":{"303":1}}],["如果d继承b的方式是受保护的或者私有的",{"2":{"303":1}}],["如果decltype使用的表达式不是一个变量",{"2":{"83":1}}],["如果decltype使用的表达式是一个变量",{"2":{"83":1}}],["如果虚函数使用默认实参",{"2":{"301":1}}],["如果虚函数函数定义成了final",{"2":{"301":1}}],["如果派生类没有直接定义这些构造函数",{"2":{"309":1}}],["如果派生类没有覆盖其基类中的某个虚函数",{"2":{"299":1}}],["如果派生类定义了一个函数与基类中虚函数的名字相同但是形参列表不同",{"2":{"301":1}}],["如果某次函数调用使用了默认实参",{"2":{"301":1}}],["如果某静态成员是可访问的",{"2":{"299":1}}],["如果某个类指定了虚基类",{"2":{"218":1}}],["如果某个类在派生过程中出现了多次",{"2":{"218":1}}],["如果基类的析构函数不是虚函数",{"2":{"306":1}}],["如果基类的公有成员是可访问的",{"2":{"303":1}}],["如果基类中的成员是private的",{"2":{"299":1}}],["如果基类定义了一个静态成员",{"2":{"299":1}}],["如果异常类型有一个字符串初始值",{"2":{"295":1}}],["如果最终还是没能找到",{"2":{"294":1}}],["如果还是没找到匹配的catch子句",{"2":{"294":1}}],["如果没找到匹配的catch子句",{"2":{"294":1}}],["如果没有在构造函数的初始值列表中显示初始化成员",{"2":{"252":1}}],["如果没有显示定义过构造函数",{"2":{"240":1}}],["如果没有找到",{"2":{"222":2}}],["如果没有找到可行函数",{"2":{"47":1}}],["如果程序中含有可能引发异常的代码",{"2":{"292":1}}],["如果程序崩溃",{"2":{"5":1}}],["如果condition第一次求值就是false",{"2":{"284":1}}],["如果catch",{"2":{"207":1}}],["如果catch的参数是基类类型",{"2":{"207":1}}],["如果catch的参数类型是非引用类型",{"2":{"207":1}}],["如果指针或算术类型的值为0",{"2":{"275":1}}],["如果指针指向了一个对象",{"2":{"73":1}}],["如果算术运算或关系运算对象有多种类型",{"2":{"273":1}}],["如果右侧运算对象是左值",{"2":{"272":1}}],["如果对char做位运算",{"2":{"270":1}}],["如果对象没有初始值",{"2":{"240":1}}],["如果对象是常量",{"2":{"98":1}}],["如果运算对象是带符号的且它的值为负",{"2":{"270":1}}],["如果运算对象是",{"2":{"270":1}}],["如果为真则对expr求值并返回该值",{"2":{"269":1}}],["如果赋值运算符的左右两个运算对象类型不同",{"2":{"266":1}}],["如果商含有小数部分",{"2":{"264":1}}],["如果改变了某个运算对象的值",{"2":{"263":1}}],["如果优先级相同",{"2":{"262":1}}],["如果构造函数只接受一个实参",{"2":{"255":1}}],["如果构造函数的所有实参都有默认实参",{"2":{"252":1}}],["如果成员所属的对象是右值",{"2":{"268":1}}],["如果成员所属的对象是左值",{"2":{"268":1}}],["如果成员是const",{"2":{"252":1}}],["如果成员不在初始化列表中",{"2":{"240":1}}],["如果成员函数声明为const版本的",{"2":{"238":1}}],["如果成员存在重载的问题",{"2":{"230":1}}],["如果union的成员类型定义了自己的构造函数和",{"2":{"233":1}}],["如果type是引用类型",{"2":{"276":1}}],["如果type",{"2":{"227":1}}],["如果p是一个指向了有虚函数的类的空指针",{"2":{"226":1}}],["如果e的类型是type的公有派生类",{"2":{"225":1}}],["如果找到了用户自定义的版本",{"2":{"222":1}}],["如果被分配",{"2":{"222":1}}],["如果名字在多个基类中都被找到",{"2":{"217":1}}],["如果命名空间名字很长时尤其如此",{"2":{"211":1}}],["如果一条dynamic",{"2":{"225":1}}],["如果一条throw表达式解引用一个基类指针",{"2":{"206":1}}],["如果一个迭代器提供某个操作",{"2":{"313":1}}],["如果一个派生类虚函数需要调用它的基类版本",{"2":{"301":1}}],["如果一个像screen这样的类希望我们可以访问它的contents成员",{"2":{"229":1}}],["如果一个参数的类型是一个模板参数包",{"2":{"180":1}}],["如果一个函数有最好的匹配",{"2":{"179":1}}],["如果一个函数参数是指向模板类型参数的右值引用",{"2":{"178":1}}],["如果一个函数参数是指向模版参数类型的右值引用",{"2":{"176":1}}],["如果一个运算符函数是成员函数",{"2":{"135":1}}],["如果一个运算符是一个成员函数",{"2":{"121":1}}],["如果一个类需要析构函数",{"2":{"306":1}}],["如果一个类需要一个拷贝构造函数",{"2":{"123":1}}],["如果一个类模板为其所有模版参数都提供了默认实参",{"2":{"168":1}}],["如果一个类模板包含一个非模板友元",{"2":{"167":1}}],["如果一个类定义了任何一个拷贝操作",{"2":{"132":1}}],["如果一个类定义了自己的拷贝构造函数",{"2":{"132":1}}],["如果一个类定义了自己的swap",{"2":{"129":1}}],["如果一个类既有移动构造函数",{"2":{"132":1}}],["如果一个类有数据成员不能默认构造",{"2":{"125":1}}],["如果一个类为一个对象分配一个独有的",{"2":{"123":1}}],["如果一个类未定义自己的拷贝赋值运算符",{"2":{"121":1}}],["如果一个类没有定义所有这些拷贝控制成员",{"2":{"118":1}}],["如果一个构造函数的第一个参数是自身类类型的引用",{"2":{"120":1}}],["如果该指针指向继承体系中的某个类型",{"2":{"306":1}}],["如果该表达式是数组类型或函数类型",{"2":{"206":1}}],["如果该整数所占的空间超过了浮点类型的容量",{"2":{"64":1}}],["如果析构函数又抛出异常",{"2":{"206":1}}],["如果析构函数被删除",{"2":{"125":1}}],["如果lambda的捕获列表为空",{"2":{"194":1}}],["如果希望改变",{"2":{"193":1}}],["如果可能的话",{"2":{"193":1}}],["如果可以对其使用可调用运算符",{"2":{"192":1}}],["如果只有多个函数模板",{"2":{"179":1}}],["如果其中只有一个是非模板函数",{"2":{"179":1}}],["如果将一个左值传递给这样的参数",{"2":{"176":1}}],["如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起",{"2":{"176":1}}],["如果实参是一个左值",{"2":{"178":1}}],["如果实参是一个右值",{"2":{"178":1}}],["如果实参是const的",{"2":{"176":1}}],["如果实参的类型不同",{"2":{"36":1}}],["如果友元自身是模板",{"2":{"167":1}}],["如果速度是要考虑的重点问题的话",{"2":{"162":1}}],["如果输入一个序列中一个子串与表达式匹配",{"2":{"157":1}}],["如果输入一个文件结束符标识",{"2":{"4":1}}],["如果整个输入序列与表达式匹配",{"2":{"157":1}}],["如果读取的字符数小于bitset的大小",{"2":{"156":1}}],["如果小于",{"2":{"155":1}}],["如果引用索引超出范围",{"2":{"153":1}}],["如果要执行降序排列的话",{"2":{"147":1}}],["如果类中有成员绑定了外部的对象",{"2":{"241":1}}],["如果类型不含虚函数",{"2":{"226":1}}],["如果类重载了函数调用运算符",{"2":{"145":1}}],["如果类定义了调用运算符",{"2":{"145":1}}],["如果类定义了算术运算符",{"2":{"139":1}}],["如果类定义了一个移动构造函数或一个移动赋值运算符",{"2":{"132":1}}],["如果左侧运算对象的计数器变为0",{"2":{"128":1}}],["如果变为0",{"2":{"128":1}}],["如果变量名加上了一对括号",{"2":{"83":1}}],["如果变量定义本身含有初始值",{"2":{"27":1}}],["如果采用合成的拷贝和赋值操作",{"2":{"123":1}}],["如果需要的话",{"2":{"223":1}}],["如果需要在很多地方使用相同的操作",{"2":{"194":1}}],["如果需要知道包中有多少个元素时",{"2":{"180":1}}],["如果需要",{"2":{"123":1}}],["如果数据成员含有类内初始值",{"2":{"257":1}}],["如果数组元素是类类型",{"2":{"120":1}}],["如果数值超过了int的表示范围",{"2":{"63":1}}],["如果流是有效的",{"2":{"114":1}}],["如果检测成功",{"2":{"113":1}}],["如果两个迭代器指示的是同一个元素",{"2":{"98":1}}],["如果v不含有任何元素",{"2":{"96":1}}],["如果是带符号的",{"2":{"270":1}}],["如果是无符号的",{"2":{"270":1}}],["如果是const版本的成员函数",{"2":{"245":1}}],["如果是对于限定作用域的枚举类型",{"2":{"228":1}}],["如果是引用类型",{"2":{"207":1}}],["如果是外层循环",{"2":{"105":1}}],["如果是类类型",{"2":{"94":1}}],["如果是内置类型的变量未被显示初始化",{"2":{"67":1}}],["如果s1和s2完全一样",{"2":{"91":1}}],["如果s为空",{"2":{"91":1}}],["如果不是聚合类",{"2":{"257":1}}],["如果不想让一个左值传递给一个参数是右值引用的函数",{"2":{"176":1}}],["如果不定义成static的",{"2":{"159":1}}],["如果不适用等号",{"2":{"90":1}}],["如果不初始化一个智能指针",{"2":{"54":1}}],["如果使用等号",{"2":{"90":1}}],["如果使用了内置指针管理内存",{"2":{"55":1}}],["如果想确保下标是合法的",{"2":{"320":1}}],["如果想对string对象中的每个字符做点儿什么操作",{"2":{"92":1}}],["如果想在多个文件之间共享const对象",{"2":{"75":1}}],["如果想在每次输出操作后都刷新缓冲区",{"2":{"5":1}}],["如果想声明一个变量而非定义它",{"2":{"68":1}}],["如果定义在类内的函数",{"2":{"245":1}}],["如果定义了自己的构造函数",{"2":{"240":1}}],["如果定义了ndebug",{"2":{"46":1}}],["如果定义变量时没有指定初值",{"2":{"67":1}}],["如果表达式既不是引用也不是指针",{"2":{"300":1}}],["如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象",{"2":{"273":1}}],["如果表达式指向并修改了同一个对象",{"2":{"263":1}}],["如果表达式是一个引用",{"2":{"226":1}}],["如果表达式是类类型",{"2":{"206":1}}],["如果表达式被用作条件",{"2":{"150":1}}],["如果表达式含有的下标运算符数量和维度一样多",{"2":{"105":1}}],["如果表达式向decltype返回一个引用类型",{"2":{"83":1}}],["如果表达式里既有带符号类型又有无符号类型",{"2":{"64":1}}],["如果表达式为真",{"2":{"46":1}}],["如果表达式为假",{"2":{"46":1}}],["如果noexcept函数抛出了异常",{"2":{"208":1}}],["如果np不为空则条件成立",{"2":{"57":1}}],["如果new不能分配所要求的内存空间",{"2":{"53":1}}],["如果存在类内初始值",{"2":{"240":1}}],["如果存在如下所示的print重载形式",{"2":{"216":1}}],["如果存在const限定符",{"2":{"133":1}}],["如果存在",{"2":{"57":1,"240":1}}],["如果存在的话",{"2":{"21":1}}],["如果分配失败",{"2":{"53":3}}],["如果在condition中定义变量",{"2":{"287":1}}],["如果在constexpr声明中定义了一个指针",{"2":{"79":1}}],["如果在程序的某个地方",{"2":{"278":1}}],["如果在处理代码之外的区域遇到了空throw语句",{"2":{"207":1}}],["如果在多个catch语句的类型之间存在着继承关系",{"2":{"207":1}}],["如果在调试期间要注释掉包含界定符对形式注释的代码",{"2":{"110":1}}],["如果在一条语句中定义了几个指针变量",{"2":{"73":1}}],["如果在一个条件判断中使用智能指针",{"2":{"52":1}}],["如果在内层作用域声明了一个函数",{"2":{"42":1}}],["如果编译器检查了每一个可行函数",{"2":{"47":1}}],["如果有多个基类",{"2":{"299":1}}],["如果有多个函数提供同样好的匹配",{"2":{"179":1}}],["如果有且只有一个函数满足下列条件",{"2":{"47":1}}],["如果有的话",{"2":{"47":1}}],["如果同一作用域内的几个函数名字相同但形参列表不同",{"2":{"41":1}}],["如果我们删除的是一个指向派生类对象的基类指针",{"2":{"306":1}}],["如果我们使用override标记了某个函数",{"2":{"301":1}}],["如果我们使用列表初始化且初始值存在丢失信息的风险",{"2":{"67":1}}],["如果我们定义了自己版本的operator",{"2":{"222":1}}],["如果我们希望使用一个模板类型参数的类型成员",{"2":{"168":1}}],["如果我们没有为一个类定义拷贝构造函数",{"2":{"120":1}}],["如果我们不传递任何参数",{"2":{"52":1}}],["如果我们想使用默认实参",{"2":{"44":1}}],["如果我们在内层作用域中声明名字",{"2":{"42":1}}],["如果我们知道函数返回的指针将指向哪个数组",{"2":{"40":1}}],["如果我们关心的只不过是一个特定元素是否已在容器中",{"2":{"23":1}}],["如果列表为空",{"2":{"39":1}}],["如果函数形参不是引用类型",{"2":{"172":1}}],["如果函数调用了它自身",{"2":{"39":1}}],["如果函数返回引用",{"2":{"39":1}}],["如果函数无须改变引用形参的值",{"2":{"32":1}}],["如果所有的实参类型相同",{"2":{"36":1}}],["如果形参是引用类型",{"2":{"30":1}}],["如果关键字不在map中",{"2":{"22":1}}],["如果提供了一个文件名",{"2":{"7":1}}],["如果执行下面的代码",{"2":{"5":1}}],["缓冲区满时",{"2":{"5":1}}],["导致缓冲区刷新的原因有",{"2":{"5":1}}],["导航",{"0":{"0":1}}],["1含有纯虚函数的类是抽象基类",{"2":{"302":1}}],["1item的静态类型是quote",{"2":{"300":1}}],["1该代码强行调用quote的net",{"2":{"301":1}}],["1该异常是类型runtime",{"2":{"293":1}}],["1该函数的类型是",{"2":{"49":1}}],["1标签标示符独立于变量或其他标示符的名字",{"2":{"291":1}}],["1label是用于标识一条语句的标示符",{"2":{"291":1}}],["1如果在程序的某个地方",{"2":{"278":1}}],["1如果string包含的字符数比bitset少",{"2":{"155":1}}],["1c++语言不会直接将两个不同类型的值相加",{"2":{"273":1}}],["1当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时",{"2":{"269":1}}],["1f1和f2一定在乘法之前被调用",{"2":{"263":1}}],["1function是一个模板",{"2":{"148":1}}],["1静态成员的类内初始化",{"2":{"258":1}}],["1返回类型使用引用类型",{"2":{"238":1}}],["1和function类似的地方是",{"2":{"231":1}}],["1和指向数据成员的指针意义",{"2":{"230":1}}],["1在c++11中声明成员指针最简单的方式是使用auto或decltype",{"2":{"229":1}}],["1初始化的方式",{"2":{"229":1}}],["1panda通过raccon和bear继承了zooanimal",{"2":{"218":1}}],["1pair的数据成员是public的",{"2":{"17":1}}],["1与只有一个基类的继承一样",{"2":{"216":1}}],["1我们使用mem",{"2":{"231":1}}],["1我们可以为其设定一个短得多的同义词",{"2":{"211":1}}],["1我们传递给deallocate的指针不能为空",{"2":{"60":1}}],["1空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内",{"2":{"207":1}}],["1插入迭代器有三种类型",{"2":{"196":1}}],["1为newcallable的第一个参数",{"2":{"194":1}}],["1newcallable本身是一个可调用对象",{"2":{"194":1}}],["1其中",{"2":{"192":1}}],["1其中type表示某种类型",{"2":{"150":1}}],["1函数参数与其他任何变量一样",{"2":{"178":1}}],["1函数实参类型是int",{"2":{"166":1}}],["1即使给flip2传递一个右值",{"2":{"178":1}}],["1非常重要的有两点",{"2":{"176":1}}],["1一个模板参数名的可用范围是在其声明之后",{"2":{"168":1}}],["1一旦向cout",{"2":{"161":1}}],["1类模板的static成员",{"2":{"167":1}}],["1类似其他任何const对象",{"2":{"53":1}}],["1类似于其他数组的声明",{"2":{"40":1}}],["1模板编译",{"2":{"166":1}}],["1指定整型值的进制",{"2":{"161":1}}],["1可以通过测试",{"2":{"157":1}}],["1可以按照以下的顺序来逐层理解该声明的含义",{"2":{"40":1}}],["16>",{"2":{"156":1}}],["1二进制位的位置是从0开始编号的",{"2":{"155":1}}],["1u",{"2":{"155":1,"156":1}}],["1>",{"2":{"153":2}}],["1move调用告诉编译器",{"2":{"131":1}}],["1调用名为isbn的成员函数",{"2":{"117":1}}],["1100",{"2":{"155":1}}],["11",{"2":{"105":1}}],["1不过c++11提供了begin和end函数",{"2":{"103":1}}],["1定义一个绑定到数组的引用",{"2":{"101":1}}],["1定义一个指向数组的指针",{"2":{"101":1}}],["1箭头运算符",{"2":{"98":1}}],["1vector中存放的是对象",{"2":{"93":1}}],["1使用数据成员指针",{"2":{"229":1}}],["1使用完using声明",{"2":{"88":1}}],["1使用函数指针",{"2":{"49":1}}],["1编译器并不实际调用f",{"2":{"83":1}}],["1编译器将在编译过程中把用到该变量的地方都替换成对应的值",{"2":{"75":1}}],["1还可以将引用的类型设为auto",{"2":{"82":1}}],["1新标准规定了一种新的方法",{"2":{"81":1}}],["1是常量表达式",{"2":{"79":1}}],["1获取对象的地址",{"2":{"73":1}}],["1术语",{"2":{"67":1}}],["1接受指针参数的智能指针构造函数是explicit的",{"2":{"54":1}}],["1释放一块并非new分配的内存",{"2":{"53":1}}],["1默认情况下",{"2":{"53":1,"101":1}}],["1默认初始化的智能指针中保存着一个空指针",{"2":{"52":1}}],["1更多的操作见p401",{"2":{"52":1}}],["14159e0",{"2":{"65":1}}],["14159",{"2":{"65":1}}],["14",{"2":{"47":1,"77":2,"82":1,"150":1,"266":1}}],["1这使得placeholders定义的所有名字都可用",{"2":{"194":1}}],["1这种形式说明希望所有来自namespace",{"2":{"194":1}}],["1这种方法使用关键字using作为别名声明的开始",{"2":{"81":1}}],["1这里声明的function类型",{"2":{"148":1}}],["1这两个变量被定义为int类型",{"2":{"109":1}}],["1这条语句读入输入数据",{"2":{"109":1}}],["1这条语句执行了一个表达式",{"2":{"109":1}}],["1这条命令的作用等价于在main",{"2":{"46":1}}],["1这样初始化的数组包含结尾的空字符",{"2":{"101":1}}],["1这样就把bufsize定义成了一个常量",{"2":{"75":1}}],["1这些命令行选项通过两个",{"2":{"35":1}}],["1首先对expr求值",{"2":{"46":1}}],["1第二个形参argv是一个数组",{"2":{"35":1}}],["10个int分别用列表中对应的初始化器初始化",{"2":{"59":1}}],["10个值初始化为0的int",{"2":{"59":1}}],["10个未初始化的int",{"2":{"59":1}}],["1024",{"2":{"53":2,"54":2,"72":1,"74":1,"76":1,"172":1,"173":2}}],["10",{"2":{"34":4,"40":6,"59":4,"90":1,"101":4,"103":3,"105":1,"113":1,"147":1,"222":1,"228":1,"291":1}}],["1",{"2":{"20":4,"35":2,"40":1,"53":1,"59":1,"79":1,"101":2,"104":1,"105":1,"113":1,"153":1,"159":1,"161":1,"166":3,"168":2,"192":1,"206":1,"231":1,"240":1,"258":1,"299":1,"301":1,"311":1,"327":1}}],["1文本串可能立即打印出来",{"2":{"5":1}}],["12空语句",{"2":{"278":1}}],["12根据所涉及的类型不同",{"2":{"276":1}}],["12我们必须牢记pc所指的真实对象是一个int而非字符",{"2":{"276":1}}],["12我们告诉function一个事实",{"2":{"231":1}}],["12当需要把一个较大的算术类型赋值给较小的类型时",{"2":{"276":1}}],["12当我们创建一个tuple对象时",{"2":{"153":1}}],["12编译器可能先求++i的值",{"2":{"263":1}}],["12编译器将实例化出这样的foo版本",{"2":{"180":1}}],["12为union的一个数据成员赋值会令其他数据成员变成未定义的状态",{"2":{"233":1}}],["12和普通指针不同的是",{"2":{"230":1}}],["12箭头运算符解引用指针sp以获得sp所指的对象",{"2":{"223":1}}],["12实际执行了两步操作",{"2":{"222":1}}],["12实际执行了三步操作",{"2":{"222":1}}],["12那么通过panda对象这样调用print函数将产生二义性编译错误",{"2":{"216":1}}],["12每个基类包含一个可选的访问说明符",{"2":{"215":1}}],["12对于一个函数来说",{"2":{"208":1}}],["12对常量的引用不能修改它所绑定的对象的值",{"2":{"76":1}}],["12区分拷贝元素的版本和不拷贝的版本",{"2":{"202":1}}],["12上面的函数模板可能无法很好的处理字符指针",{"2":{"183":1}}],["12sizeof运算符",{"2":{"180":1}}],["12引用折叠和右值引用参数",{"2":{"176":1}}],["12显式模板实参按由左至右的顺序与对应的模板参数匹配",{"2":{"173":1}}],["12正常类型转换应用于普通函数实参",{"2":{"172":1}}],["12declaration是一个类或函数声明",{"2":{"170":1}}],["12默认模板实参",{"2":{"168":1}}],["12默认情况下",{"2":{"54":1}}],["12模板与友元",{"2":{"167":1}}],["12更多操纵符见p669",{"2":{"161":1}}],["12标准库定义了多个随机数引擎类",{"2":{"159":1}}],["12标准库move函数",{"2":{"131":1}}],["12bitset的io运算符",{"2":{"156":1}}],["12make",{"2":{"153":1}}],["12matrix的声明看起来是一个二维数组",{"2":{"34":1}}],["12p510列出了所有这些函数对象类",{"2":{"147":1}}],["12pair的默认构造函数对数据成员进行值初始化",{"2":{"17":1}}],["12c++class",{"2":{"141":1}}],["12const指针",{"2":{"77":1}}],["12constexpr函数被隐式地指定为内联函数",{"2":{"45":1}}],["12右值和左值引用成员函数",{"2":{"133":1}}],["12重载赋值运算符",{"2":{"121":1}}],["12输入运算符返回其左侧对象",{"2":{"114":1}}],["12for循环的总体执行流程",{"2":{"113":1}}],["12while语句的执行过程是交替地检测condition条件和执行关联的语句statement",{"2":{"112":1}}],["12还可以使用auto或者begin来得到指向内层数组的指针",{"2":{"105":1}}],["12无法保证返回的c风格字符串一直有效",{"2":{"104":1}}],["12指针也是迭代器",{"2":{"103":1}}],["12指针的类型必须与其所指对象的类型一致",{"2":{"77":1}}],["12auto",{"2":{"103":1}}],["12allocator分配未构造的内存",{"2":{"60":1}}],["12理解复杂的数组声明",{"2":{"101":1}}],["12字符数组的特殊性",{"2":{"101":1}}],["12it1能读写元素",{"2":{"98":1}}],["12迭代器运算符",{"2":{"98":1}}],["12只有当元素的值可比较时",{"2":{"96":1}}],["12这样的算法基于一个非常重要的假设",{"2":{"187":1}}],["12这里c是str中字符的副本",{"2":{"92":1}}],["12这种情况下",{"2":{"41":1}}],["12其中",{"2":{"92":1}}],["12其次",{"2":{"82":1}}],["12复合类型",{"2":{"82":1}}],["12使用成员函数指针",{"2":{"230":1}}],["12使用范围for语句处理多维数组",{"2":{"105":1}}],["12使用下标运算符",{"2":{"92":1}}],["12使用auto也能在一条语句中声明多个变量",{"2":{"82":1}}],["12使用decltype",{"2":{"40":1}}],["12与其他常量指针类似",{"2":{"79":1}}],["12建议",{"2":{"74":1}}],["12因为引用不是对象",{"2":{"73":1}}],["12定义引用时",{"2":{"72":1}}],["12任何包含了显式初始化的声明即成为定义",{"2":{"68":1}}],["12一旦元素被销毁后",{"2":{"60":1}}],["12一旦某个形参被赋予了默认值",{"2":{"44":1}}],["12数组的元素按逆序销毁",{"2":{"59":1}}],["12释放动态数组",{"2":{"59":1}}],["12新标准中",{"2":{"59":1}}],["12方括号中的大小必须是整型",{"2":{"59":1}}],["12由于对象可能不存在",{"2":{"57":1}}],["12由于一个unique",{"2":{"56":1}}],["12可以认为每个shared",{"2":{"52":1}}],["12如果派生类含有自己的数据成员",{"2":{"309":1}}],["12如果对象本身是一个非常量",{"2":{"276":1}}],["12如果左侧运算对象是内置类型",{"2":{"266":1}}],["12如果形参是某种类型的指针或引用",{"2":{"41":1}}],["12如果试图在标准输入上键入boo",{"2":{"4":1}}],["123虚函数与默认实参",{"2":{"301":1}}],["123condition使用的变量必须定义在循环体之外",{"2":{"287":1}}],["123后置递增运算符的优先级高于解引用运算符",{"2":{"267":1}}],["123使用bind生成一个可调用对象",{"2":{"231":1}}],["123使用mem",{"2":{"231":1}}],["123使用类的类型成员",{"2":{"168":1}}],["123成员指针函数表",{"2":{"230":1}}],["123之所以上面使用成员指针两边的括号必不可少",{"2":{"230":1}}],["123枚举成员",{"2":{"228":1}}],["123其中",{"2":{"225":1}}],["123上述代码将zooanimal定义为raccoon和bear的虚基类",{"2":{"218":1}}],["123可能是定义了一个名为nsp的新命名空间",{"2":{"210":1}}],["123可以给函数指针赋一个nullptr或0",{"2":{"49":1}}],["123可以直接对指向函数的指针调用该函数",{"2":{"49":1}}],["123详见lambda捕获列表",{"2":{"193":1}}],["123从一个左值static",{"2":{"177":1}}],["123如果提供了初始值",{"2":{"233":1}}],["123如果不能从函数指针类型确定模板实参",{"2":{"175":1}}],["123如果引擎种子相同",{"2":{"159":1}}],["123没有任何函数实参的类型可用来推断t1的类型",{"2":{"173":1}}],["123当编译器遇到extern模板声明时",{"2":{"170":1}}],["123但",{"2":{"150":1}}],["123但对于hasptr这样管理外部资源的类",{"2":{"129":1}}],["123类型转换运算符可能产生意外结果",{"2":{"150":1}}],["123函数调用运算符必须是成员函数",{"2":{"145":1}}],["123函数调用时实参按其位置解析",{"2":{"44":1}}],["123swap函数的存在是为了优化代码",{"2":{"129":1}}],["123这俩函数定义在头文件iterator",{"2":{"103":1}}],["123这些函数接受的形参类型不一样",{"2":{"41":1}}],["123检查下标的值",{"2":{"102":1}}],["123decltype和引用",{"2":{"83":1}}],["123字面值类型",{"2":{"79":1}}],["123还未构造对象的情况下就使用原始内存是错误的",{"2":{"60":1}}],["123",{"2":{"57":1,"59":1,"73":1,"82":1,"83":1,"90":1,"110":1,"156":1,"173":1,"211":1,"279":1}}],["123释放动态内存",{"2":{"53":1}}],["123动态分配的const对象",{"2":{"53":1}}],["123声明一个返回数组指针的函数",{"2":{"40":1}}],["1234这种转换称为派生类到基类的转换",{"2":{"299":1}}],["1234必须确保转换后所得的类型就是指针所指的类型",{"2":{"276":1}}],["1234更多讨论见书本p759",{"2":{"236":1}}],["1234更新三",{"2":{"132":1}}],["1234返回数据成员指针的函数",{"2":{"229":1}}],["1234当仅通过一个地址值调用时",{"2":{"223":1}}],["1234命名空间既可以定义在全局作用域内",{"2":{"210":1}}],["1234其中",{"2":{"201":1}}],["1234如果我们通过flip1调用f",{"2":{"178":1}}],["1234如果表达式的内容是解引用操作",{"2":{"83":1}}],["1234在输出中指出进制",{"2":{"161":1}}],["1234分布类型也是函数对象类",{"2":{"159":1}}],["1234引用限定符可以是",{"2":{"133":1}}],["1234左值持久",{"2":{"131":1}}],["1234还可以对任何函数指定=delete",{"2":{"125":1}}],["1234由于析构函数不接受参数",{"2":{"122":1}}],["1234合成拷贝赋值运算符",{"2":{"121":1}}],["1234main函数的返回类型必须为int",{"2":{"107":1}}],["1234只要指针指向的是数组中的元素",{"2":{"103":1}}],["1234void",{"2":{"73":1}}],["1234指针值",{"2":{"73":1}}],["1234作为c++11新标准的一部分",{"2":{"67":1}}],["1234",{"2":{"33":1,"34":1,"162":1,"178":1,"229":1}}],["1234向multiset或multimap添加元素",{"2":{"20":1}}],["12345通常情况下",{"2":{"309":1}}],["12345派生类析构函数",{"2":{"308":1}}],["12345当选中了某个catch子句处理异常之后",{"2":{"294":1}}],["12345与往常一样",{"2":{"180":1}}],["12345编译器不会将一个显式的类型转换运算符用于隐式类型转换",{"2":{"150":1}}],["12345这个类只定义了一种操作",{"2":{"145":1}}],["12345区分前置和后置运算符",{"2":{"143":1}}],["12345某些运算符不应该被重载",{"2":{"135":1}}],["12345rhs是右侧运算对象的一个副本",{"2":{"129":1}}],["12345合成拷贝构造函数",{"2":{"120":1}}],["12345列表初始化中未列出的元素执行值初始化",{"2":{"105":1}}],["12345我们的类以关键字struct开始",{"2":{"85":1}}],["12345如果希望推断出来的auto类型是一个顶层const",{"2":{"82":1}}],["12345对象销毁的顺序正好与其创建的顺序相反",{"2":{"308":1}}],["12345对const的引用可能引用一个并非const的对象",{"2":{"76":1}}],["12345对允许重复关键字的容器",{"2":{"20":1}}],["12345无论是否发生了异常",{"2":{"55":1}}],["12345类似顺序容器的emplace成员",{"2":{"52":1}}],["12345确定候选函数和可行函数",{"2":{"47":1}}],["12345",{"2":{"19":1,"79":1,"115":1,"143":1,"172":1,"178":2,"180":1,"291":1,"306":1}}],["123456使用union",{"2":{"233":1}}],["123456当我们调用data函数时",{"2":{"229":1}}],["123456当我们定义一个特例化版本时",{"2":{"183":1}}],["123456引用类型的dynamic",{"2":{"225":1}}],["123456虚继承的对象的构造方式",{"2":{"219":1}}],["123456move的函数参数t",{"2":{"177":1}}],["123456从右值引用函数参数推断类型",{"2":{"176":1}}],["123456如果一个函数参数的类型是const",{"2":{"176":1}}],["123456如果在new和delete之间发生了异常",{"2":{"55":1}}],["123456我们知道",{"2":{"174":1}}],["123456模板声明",{"2":{"168":1}}],["123456指定打印精度",{"2":{"161":1}}],["123456直接初始化和拷贝初始化",{"2":{"90":1}}],["1234567跳回到变量定义之前意味着系统将销毁该变量",{"2":{"291":1}}],["1234567第一个扩展操作扩展模板参数包",{"2":{"182":1}}],["1234567进行类型转换的标准库模板类",{"2":{"174":1}}],["1234567模板类型别名",{"2":{"167":1}}],["1234567关系和相等运算符",{"2":{"153":1}}],["1234567复合赋值运算符",{"2":{"141":1}}],["1234567移动操作",{"2":{"132":1}}],["1234567",{"2":{"55":1,"126":1,"137":1,"139":1,"141":1,"148":1,"174":1,"176":1}}],["12345678基类的构造顺序与派生列表中基类的出现顺序保持一致",{"2":{"215":1}}],["12345678捕获所有异常的处理代码",{"2":{"207":1}}],["12345678如果f定义成这样",{"2":{"178":1}}],["12345678与函数默认实参一样",{"2":{"168":1}}],["12345678",{"2":{"40":1,"193":1,"222":1,"233":1,"247":1}}],["123456789派生类赋值运算符",{"2":{"308":1}}],["123456789编译器不会在派生类向基类的几种转换中进行比较和选择",{"2":{"216":1}}],["123456789编译器为每个函数都定义了",{"2":{"46":1}}],["123456789每个foo实例都有其自己的static成员实例",{"2":{"167":1}}],["123456789template是关键字",{"2":{"166":1}}],["1234567891011对于某些函数",{"2":{"297":1}}],["1234567891011当我们将上述函数定义成类的成员时",{"2":{"222":1}}],["1234567891011",{"2":{"138":1,"140":1,"229":1,"294":1}}],["123456789101112typeid是否需要运行时检查决定了表达式是否会被求值",{"2":{"226":1}}],["1234567891011121314因为derived使用了私有继承",{"2":{"303":1}}],["12345678910111213141516公有",{"2":{"303":1}}],["12345678910111213141516",{"2":{"298":1}}],["12345678910111213141516析构函数与多重继承",{"2":{"215":1}}],["123456789101112131415161718提取bitset的值",{"2":{"156":1}}],["123456789101112131415",{"2":{"181":1}}],["12345678910111213派生类中的虚函数",{"2":{"299":1}}],["12345678910111213我们传递给display的实参属于类类型bulk",{"2":{"213":1}}],["12345678910111213移后源对象必须可析构",{"2":{"132":1}}],["123456789101112smallint类的构造函数将算数类型的值转换成smallint对象",{"2":{"150":1}}],["123456789101112下面重载的版本中",{"2":{"41":1}}],["1234567891011头文件不应包含using声明",{"2":{"88":1}}],["12345678910",{"2":{"86":1,"109":1,"167":1,"168":1}}],["123456789",{"2":{"17":1,"142":1,"144":1,"207":1,"225":1,"236":1}}],["123456789初始化multimap或multiset",{"2":{"15":1}}],["1234567递归",{"2":{"39":1}}],["123456但这一用法也限制了print函数的可用性",{"2":{"34":1}}],["123456函数返回类型",{"2":{"27":1}}],["123456",{"2":{"16":1,"35":1,"78":1,"282":1}}],["12也可以使用数组的语法定义函数",{"2":{"34":1}}],["12在c++中",{"2":{"33":1}}],["12",{"2":{"4":1,"5":1,"7":1,"8":1,"36":1,"37":1,"41":1,"44":1,"49":3,"77":1,"91":1,"104":1,"105":1,"147":1,"153":1,"176":1,"178":1,"202":2,"261":1,"275":2,"278":1,"291":1}}],["at会抛出一个out",{"2":{"320":1}}],["at成员函数类似下标运算符",{"2":{"320":1}}],["again",{"2":{"294":1}}],["aggregate",{"2":{"256":1}}],["action",{"2":{"230":2}}],["accessible",{"2":{"303":1}}],["access",{"2":{"242":1}}],["accum",{"2":{"121":2}}],["account",{"2":{"41":4}}],["address",{"2":{"223":4}}],["add",{"2":{"148":1}}],["abstract",{"2":{"237":1}}],["abstraction",{"2":{"237":1}}],["absobj",{"2":{"145":2}}],["absint",{"2":{"145":2}}],["avg",{"2":{"137":1}}],["assign",{"2":{"326":2}}],["assignment",{"2":{"118":2}}],["assume",{"2":{"201":1}}],["assert的行为依赖于一个名为ndebug的预处理变量的状态",{"2":{"46":1}}],["assert宏常用于检查",{"2":{"46":1}}],["assert宏定义在cassert头文件中",{"2":{"46":1}}],["assert宏使用一个表达式作为它的条件",{"2":{"46":1}}],["assert什么也不做",{"2":{"46":1}}],["assert输出信息并终止程序的执行",{"2":{"46":1}}],["assert是一种预处理宏",{"2":{"46":1}}],["assert预处理宏",{"2":{"46":1}}],["assert和ndebug",{"2":{"46":1}}],["a是一个含有3个元素的数组",{"2":{"105":1}}],["a是一个int",{"2":{"82":1}}],["a2",{"2":{"101":2,"103":2}}],["a1",{"2":{"101":3,"103":4}}],["alg是算法名字",{"2":{"201":1}}],["alg",{"2":{"201":4}}],["all",{"2":{"156":2,"207":1}}],["alloc异常",{"2":{"222":1}}],["allocator分配的内存是未构造的",{"2":{"60":1}}],["allocator也是模板",{"2":{"60":1}}],["allocator类",{"0":{"60":1},"2":{"60":1}}],["allocate",{"2":{"50":1,"60":1}}],["alloc",{"2":{"53":1,"60":5,"208":1,"222":1}}],["alloc的异常",{"2":{"53":1}}],["alias",{"2":{"81":2,"211":1}}],["ambiguous",{"2":{"41":1}}],["amp",{"2":{"41":1,"49":2,"72":1,"73":1,"133":3,"176":24,"177":2,"178":11,"182":1,"193":2,"213":1,"231":1,"263":2,"270":2,"300":1}}],["arithmetic",{"2":{"62":1,"274":1}}],["args",{"2":{"180":5,"181":1,"182":2,"201":4}}],["args>",{"2":{"180":2,"181":1,"182":1}}],["args表示零个或多个模板类型参数",{"2":{"180":1}}],["args是一个模板参数包",{"2":{"180":1}}],["arg",{"2":{"178":2,"194":3}}],["argument",{"2":{"44":1,"166":1,"167":1,"168":1,"171":1,"173":1,"329":1}}],["argv应该包含如下的c风格字符串",{"2":{"35":1}}],["argv的第一个元素指向程序的名字或者一个空字符串",{"2":{"35":1}}],["argv",{"2":{"35":7}}],["argc应该等于5",{"2":{"35":1}}],["argc至少为1",{"2":{"35":1}}],["argc",{"2":{"35":1}}],["array",{"2":{"46":1,"65":1,"311":1}}],["arrptr",{"2":{"40":1}}],["arrt的等价声明",{"2":{"40":1}}],["arrt是一个类型别名",{"2":{"40":1}}],["arrt",{"2":{"40":3}}],["arr",{"2":{"34":2,"102":1,"105":2,"222":2}}],["any",{"2":{"156":1}}],["anon",{"2":{"17":1}}],["and",{"2":{"15":1,"109":1,"129":1}}],["auto一般会忽略掉顶层const",{"2":{"82":1}}],["auto定义的变量必须有初始值",{"2":{"82":1}}],["auto类型说明符",{"0":{"82":1}}],["auto",{"2":{"34":1,"40":1,"41":1,"52":2,"60":1,"82":12,"92":2,"98":1,"102":1,"103":1,"153":2,"173":1,"174":2,"193":2,"229":2,"267":1,"327":1}}],["automatic",{"2":{"27":1}}],["author",{"2":{"17":1}}],["authors",{"2":{"15":1,"20":3}}],["authors将姓映射为名",{"2":{"15":1}}],["austen",{"2":{"15":1}}],["append",{"2":{"228":1,"326":2}}],["app",{"2":{"8":2}}],["a",{"2":{"5":1,"44":3,"65":2,"76":2,"82":1,"94":3,"96":1,"101":4,"103":4,"104":3,"105":6,"141":1,"168":7,"178":2,"222":1,"223":1,"233":1,"247":1,"258":1,"275":2}}],["用法",{"2":{"270":1}}],["用的是对象的身份",{"2":{"261":1}}],["用的是对象的值",{"2":{"261":1}}],["用户代码才能使用派生类向基类的转换",{"2":{"303":1}}],["用户可以自行定义其含义",{"2":{"261":1}}],["用户自定义的标识符中不能连续出现两个下画线",{"2":{"69":1}}],["用这些模板实参生成的函数版本与给定的函数调用最为匹配",{"2":{"171":1}}],["用类c实例化的pal是c的一个友元",{"2":{"167":1}}],["用s2的副本代替s1",{"2":{"91":1}}],["用它让编译器替我们去分析表达式所属的类型",{"2":{"82":1}}],["用const定义的变量并不一定是常量表达式",{"2":{"79":1}}],["用常量表达式初始化的const对象",{"2":{"79":1}}],["用花括号来初始化变量得到了全面应用",{"2":{"67":1}}],["用new分配const对象是合法的",{"2":{"53":1}}],["用于报告标准库函数遇到的问题",{"2":{"295":1}}],["用于在throw表达式和相关的catch子句之间传递异常的具体信息",{"2":{"292":1}}],["用于将基类的指针或引用安全地转换成派生类的指针或引用",{"2":{"224":1}}],["用于返回表达式的类型",{"2":{"224":1}}],["用于演示",{"2":{"176":1}}],["用于表示一个序列",{"2":{"92":1}}],["用于表示某种特定类型的值的数组",{"2":{"36":1}}],["用于声明引用的const都是底层const",{"2":{"78":1}}],["用于存放函数的名字",{"2":{"46":1}}],["用于大型程序的工具",{"0":{"204":1},"1":{"205":1,"206":1,"207":1,"208":1,"209":1,"210":1,"211":1,"212":1,"213":1,"214":1,"215":1,"216":1,"217":1,"218":1,"219":1},"2":{"0":1}}],["用一个分号替代即可",{"2":{"28":1}}],["用来初始化新添加的元素",{"2":{"322":1}}],["用来初始化bitset中的低位",{"2":{"155":1}}],["用来终止递归并打印最后一个元素的函数",{"2":{"181":1}}],["用来代替模板参数的模板实参列表",{"2":{"167":1}}],["用来生成针对特定类型的函数版本",{"2":{"166":1}}],["用来生成tuple对象",{"2":{"153":1}}],["用来设置精度",{"2":{"161":1}}],["用来记录有多少个对象与正在创建的对象共享状态",{"2":{"128":1}}],["用来组织一个容器中元素的操作的类型也是该容器类型的一部分",{"2":{"16":1}}],["用来指出如何使用文件",{"2":{"8":1}}],["用来保存程序读写的数据",{"2":{"5":1}}],["读写一个字符",{"2":{"162":1}}],["读写一个io对象会改变其状态",{"2":{"3":1}}],["读取过程才停止",{"2":{"156":1}}],["读取数量不定的输入数据",{"0":{"114":1}}],["读取失败后",{"2":{"4":1}}],["读cin或写cerr",{"2":{"5":1}}],["读操作就会失败",{"2":{"4":1}}],["c语言风格的强制类型转换",{"2":{"276":1}}],["custom",{"2":{"236":1}}],["cursor",{"2":{"229":3,"230":1}}],["cur",{"2":{"163":1}}],["curly",{"2":{"107":1}}],["cstring>中的链接指示",{"2":{"236":1}}],["cstdlib>",{"2":{"73":1}}],["cstdlib头文件定义了两个预处理变量",{"2":{"39":1}}],["cval",{"2":{"233":4}}],["c2",{"2":{"230":1}}],["c1",{"2":{"230":1}}],["c>",{"2":{"167":1}}],["ch",{"2":{"162":6}}],["char是有符号的",{"2":{"63":1}}],["char和unsigned",{"2":{"63":1}}],["char",{"2":{"33":3,"35":1,"41":1,"44":1,"63":2,"104":1,"153":1,"162":1,"180":1,"183":2,"230":3,"236":6,"255":1,"276":5,"294":1}}],["charles",{"2":{"15":1}}],["c和c++都依赖于一个简单的c库函数rand来生成随机数",{"2":{"158":1}}],["cnt是一个int",{"2":{"153":1}}],["cnt的类型与item中第二个成员相同",{"2":{"153":1}}],["cnt",{"2":{"153":2}}],["c风格的字符串即是字符串字面量",{"2":{"104":1}}],["c风格字符串",{"0":{"104":1}}],["c一样",{"2":{"92":1}}],["clause",{"2":{"207":1,"292":1}}],["classes",{"0":{"257":1}}],["class默认为private",{"2":{"242":1}}],["class和struct",{"2":{"242":1}}],["class",{"2":{"85":1,"116":1,"149":1,"167":10,"168":3,"170":2,"180":1,"213":1,"215":1,"218":3,"228":1,"232":1,"234":1,"247":1,"256":1,"292":1,"297":5,"303":2,"308":1}}],["clobber不能访问base的protected成员",{"2":{"303":1}}],["clobber能访问sneaky对象的private和protected成员",{"2":{"303":1}}],["clobber",{"2":{"303":4}}],["clog关联到标准错误",{"2":{"109":1}}],["clog用来输出程序运行时的一般性消息",{"2":{"109":1}}],["close会自动被调用",{"2":{"7":1}}],["c是int",{"2":{"83":1}}],["c是一个int",{"2":{"82":1}}],["cj",{"2":{"83":2}}],["critical",{"2":{"215":2,"219":1}}],["crend成员函数来获得反向迭代器",{"2":{"198":1}}],["crbegin",{"2":{"198":1}}],["cr是ci的别名",{"2":{"82":1}}],["cr",{"2":{"82":2}}],["ci是一个const",{"2":{"176":2}}],["ci是一个顶层const",{"2":{"78":1}}],["ci推演成int",{"2":{"82":1}}],["ci的顶层const被忽略",{"2":{"82":1}}],["ci",{"2":{"78":3,"82":6,"83":3,"176":2}}],["cin也会进入错误状态",{"2":{"4":1}}],["cin进入错误状态",{"2":{"4":1}}],["cin",{"2":{"4":2,"88":2,"109":2,"114":2,"132":2,"156":1,"162":1,"275":1,"278":1,"294":3}}],["cerr和clog的流不支持随机访问",{"2":{"163":1}}],["cerr通常用来输出警告和错误消息",{"2":{"109":1}}],["cerr",{"2":{"46":1}}],["cend",{"2":{"19":1,"187":1}}],["c文件的一开始写",{"2":{"46":1}}],["cc",{"2":{"46":1}}],["catch一旦完成",{"2":{"294":1}}],["catch",{"2":{"207":4,"225":1,"292":1,"294":2}}],["catch子句",{"2":{"207":1,"292":1}}],["calc",{"2":{"168":1}}],["callable",{"2":{"194":1}}],["calls",{"2":{"27":1}}],["called",{"2":{"26":1,"30":2}}],["calling",{"2":{"26":1}}],["call",{"2":{"26":1,"41":1,"148":1}}],["capture",{"2":{"192":2}}],["cap",{"2":{"132":6}}],["candidate",{"2":{"47":1}}],["cast相似的行为",{"2":{"276":1}}],["cast或reinterpret",{"2":{"276":1}}],["cast非常危险",{"2":{"276":1}}],["cast非常有用",{"2":{"276":1}}],["cast通常为运算对象的位模式提供较低层次上的重新解释",{"2":{"276":1}}],["cast常常用于有函数重载的上下文中",{"2":{"276":1}}],["cast只能改变运算对象的底层const",{"2":{"276":1}}],["cast找回存在于void",{"2":{"276":1}}],["cast对于编译器无法自动执行的类型转换也非常有用",{"2":{"276":1}}],["cast支持运行时识别",{"2":{"276":1}}],["cast中的一种",{"2":{"276":1}}],["cast和reinterpret",{"2":{"276":1}}],["cast和重载",{"2":{"41":1}}],["cast异常",{"2":{"225":1}}],["cast语句的转换目标是指针类型并且失败了",{"2":{"225":1}}],["cast运算符将抛出一个bad",{"2":{"225":1}}],["cast运算符",{"0":{"225":1},"2":{"224":1,"225":1}}],["cast显式地将一个左值转换为一个右值引用",{"2":{"177":1}}],["cast到一个右值引用是允许的",{"2":{"177":1}}],["cast",{"2":{"41":3,"150":1,"177":1,"225":9,"276":13}}],["cast在重载函数的情境中最有用",{"2":{"41":1}}],["cplusplus",{"2":{"210":1,"211":3,"236":2}}],["cptr",{"2":{"77":1}}],["cpp",{"2":{"59":1,"108":1}}],["cppreference",{"2":{"59":1}}],["cp",{"2":{"41":1,"325":1}}],["c",{"0":{"236":1},"2":{"33":1,"46":1,"82":1,"83":1,"90":2,"92":2,"94":4,"96":1,"104":3,"141":1,"167":1,"168":1,"233":1,"236":4,"247":1,"294":3}}],["ctr",{"2":{"27":1,"33":1,"167":3}}],["cbegin",{"2":{"19":1,"98":1,"187":2}}],["color",{"2":{"228":1}}],["copy",{"2":{"90":1,"118":3,"120":1,"129":1,"202":1}}],["cond",{"2":{"269":1}}],["condition",{"2":{"112":1,"113":1,"115":1,"284":1,"285":1,"287":1}}],["conversion",{"2":{"150":2,"273":1,"274":1}}],["conversions",{"2":{"149":1}}],["converting",{"2":{"255":1}}],["convert",{"2":{"64":1}}],["continue语句只能出现在for",{"2":{"290":1}}],["continue语句终止最近的循环中的当前迭代并立即开始下一次迭代",{"2":{"290":1}}],["continue语句",{"0":{"290":1}}],["continue",{"2":{"288":1}}],["contetns",{"2":{"229":1}}],["contents",{"2":{"229":4}}],["control",{"2":{"118":1}}],["container",{"2":{"93":1}}],["const成员函数返回const引用",{"2":{"246":1}}],["const已经是函数参数类型的一部分",{"2":{"176":1}}],["const是底层的",{"2":{"176":1}}],["const转换",{"2":{"172":1}}],["constants",{"2":{"153":1}}],["const和constexpr变量等",{"2":{"86":1}}],["const的引用",{"0":{"76":1}}],["const对象只能调用const版本的成员函数",{"2":{"238":1}}],["const对象被设定为仅在文件内有效",{"2":{"75":1}}],["const对象仅在文件内有效",{"2":{"75":1}}],["const限定符",{"0":{"75":1},"1":{"76":1,"77":1,"78":1,"79":1}}],["constructor",{"2":{"118":2,"120":1,"240":3,"253":1,"255":1}}],["construct",{"2":{"60":2}}],["constexpr指针既可以指向常量也可以指向一个非常量",{"2":{"79":1}}],["constexpr变量",{"2":{"79":1}}],["constexpr和常量表达式",{"0":{"79":1}}],["constexpr",{"2":{"45":1,"79":7}}],["constexpr函数",{"2":{"45":1}}],["const版本返回对const",{"2":{"41":1}}],["const形参和实参",{"0":{"33":1}}],["const",{"2":{"16":2,"18":1,"33":1,"34":3,"41":18,"46":1,"49":6,"53":1,"60":1,"75":2,"76":6,"77":5,"78":8,"79":3,"82":3,"83":1,"98":1,"104":1,"120":1,"121":1,"125":2,"133":2,"137":1,"139":2,"140":4,"141":1,"142":1,"144":2,"145":1,"150":3,"153":1,"166":4,"167":4,"168":7,"172":1,"175":6,"176":2,"180":7,"181":3,"182":2,"183":6,"193":1,"213":2,"215":4,"216":5,"225":2,"229":3,"230":2,"231":1,"236":5,"275":1,"276":6,"297":3,"298":3,"299":2,"301":1,"302":1,"303":1,"308":4,"309":2}}],["comma",{"2":{"272":1}}],["comments",{"2":{"110":2}}],["com",{"2":{"59":1}}],["comp",{"2":{"202":1}}],["compare的特殊版本",{"2":{"183":1}}],["compare有一个默认模板实参",{"2":{"168":1}}],["compare函数声明了一个名为t的类型参数",{"2":{"166":1}}],["compare",{"0":{"328":1},"2":{"166":2,"168":2,"172":1,"173":2,"175":3,"183":2}}],["compareisbn",{"2":{"16":3}}],["compound",{"2":{"71":1,"262":1,"278":1}}],["compilation",{"2":{"29":1,"68":1}}],["count会统计有多少个元素有相同的关键字",{"2":{"23":1}}],["count",{"2":{"15":1,"19":2,"20":4,"27":1,"52":1,"128":1,"156":1,"167":1}}],["cout",{"2":{"5":1,"34":1,"55":1,"73":1,"88":1,"102":2,"109":3,"148":3,"156":2,"159":2,"161":9,"163":1,"178":1,"180":2,"216":1,"263":1,"267":1,"278":1,"279":1,"294":1}}],["c++quote",{"2":{"299":1}}],["c++goto",{"2":{"291":1}}],["c++的表达式要不然是右值",{"2":{"261":1}}],["c++的标识符",{"2":{"69":1}}],["c++使用链接指示",{"2":{"236":1}}],["c++定义了一元运算符",{"2":{"261":1}}],["c++定义了一些固有的不可移植",{"2":{"235":1}}],["c++定义了一套包括算术类型",{"2":{"62":1}}],["c++last",{"2":{"233":1}}],["c++long",{"2":{"172":1,"173":1}}],["c++end",{"2":{"291":1}}],["c++enum",{"2":{"228":1}}],["c++extern",{"2":{"170":2}}],["c++包含两种枚举",{"2":{"228":1}}],["c++包含了一个全面的标准库",{"2":{"109":1}}],["c++没有进行特殊规定",{"2":{"215":1}}],["c++namespace",{"2":{"210":2,"211":2,"213":1}}],["c++就要多处理这个异常",{"2":{"206":1}}],["c++程序有时需要调用其他语言编写的函数",{"2":{"236":1}}],["c++程序不应该使用库函数rand",{"2":{"158":1}}],["c++程序使用头文件保护符",{"2":{"86":1}}],["c++bulk",{"2":{"309":1}}],["c++bitset",{"2":{"155":2,"156":2}}],["c++bool",{"2":{"16":1,"49":2,"140":1}}],["c++try",{"2":{"294":1}}],["c++throw",{"2":{"293":1}}],["c++token",{"2":{"233":1}}],["c++template",{"2":{"166":2,"167":2,"168":3,"174":1,"175":1,"176":5,"178":3,"180":1,"182":1}}],["c++tuple",{"2":{"153":1}}],["c++type",{"2":{"40":1}}],["c++typedef",{"2":{"40":1,"44":1,"49":1,"153":1,"167":1,"168":1}}],["c++find",{"2":{"231":1}}],["c++foo",{"2":{"180":1}}],["c++for",{"2":{"92":3,"102":1,"113":1}}],["c++flip2",{"2":{"178":1}}],["c++f",{"2":{"178":1}}],["c++f3",{"2":{"176":1}}],["c++function",{"2":{"148":2,"231":1}}],["c++do",{"2":{"287":1}}],["c++double",{"2":{"258":1,"300":1,"301":1,"302":1}}],["c++data1",{"2":{"135":1}}],["c++derived",{"2":{"226":1}}],["c++default",{"2":{"159":3}}],["c++delete",{"2":{"53":1,"59":1,"222":1}}],["c++decltype",{"2":{"49":1}}],["c++hasptr",{"2":{"129":2}}],["c++case",{"2":{"282":1}}],["c++catch",{"2":{"207":1}}],["c++class",{"2":{"120":1,"121":1,"122":1,"126":1,"133":1,"142":1,"143":2,"144":1,"150":2,"215":1,"218":1,"229":2,"247":1,"298":1,"299":2,"303":2,"306":1,"308":2,"309":1}}],["c++char",{"2":{"101":1,"230":1}}],["c++const",{"2":{"53":1,"229":2}}],["c++constexpr",{"2":{"45":1}}],["c++cout",{"2":{"5":1,"161":5,"166":1}}],["c++标准并没有明确规定派生类的对象在内存中如何分布",{"2":{"299":1}}],["c++标准库定义了一组类",{"2":{"295":1}}],["c++标准规定type",{"2":{"227":1}}],["c++标准规定了尺寸的最小值",{"2":{"63":1}}],["c++标准要求vector应该能在运行时高效快速地添加元素",{"2":{"95":1}}],["c++vector",{"2":{"93":1,"96":1,"98":1,"141":1,"231":1}}],["c++void",{"2":{"33":1,"36":1,"41":1,"46":1,"47":1,"55":2,"133":1,"178":2,"180":1,"193":1,"207":1,"208":1,"216":1,"222":1,"225":1}}],["c++新标准引入了显式的类型转换运算符",{"2":{"150":1}}],["c++新标准引入了第二种类型说明符decltype",{"2":{"83":1}}],["c++新标准提供了另一种简化上述func声明的方法",{"2":{"40":1}}],["c++11可以定义委托构造函数",{"2":{"253":1}}],["c++11中",{"2":{"233":1,"240":1}}],["c++11中可以使用cbegin和cend",{"2":{"98":1}}],["c++11",{"2":{"105":1}}],["c++11标准提供了constexpr关键字",{"2":{"79":1}}],["c++11新标准提供了一种防止继承发生的方法",{"2":{"299":1}}],["c++11新标准提供了两种主要的方法",{"2":{"36":1}}],["c++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数",{"2":{"299":1}}],["c++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象",{"2":{"266":1}}],["c++11新标准引入了一种更简单的for语句",{"2":{"286":1}}],["c++11新标准引入了auto类型说明符",{"2":{"82":1}}],["c++11新标准规定",{"2":{"39":1,"85":1}}],["c++也为标准库保留了一些名字",{"2":{"69":1}}],["c++union",{"2":{"233":1}}],["c++unique",{"2":{"56":1}}],["c++unsigned",{"2":{"156":1}}],["c++using",{"2":{"49":1,"88":1,"105":1,"194":2,"230":1}}],["c++提供了new运算符分配内存",{"2":{"53":1}}],["c++screen",{"2":{"229":1,"230":1}}],["c++smallint",{"2":{"150":2}}],["c++salesdata",{"2":{"240":1}}],["c++sales",{"2":{"121":1,"139":1}}],["c++strvec",{"2":{"132":3}}],["c++struct",{"2":{"125":1,"145":1,"215":1,"301":1}}],["c++string",{"2":{"44":1,"90":2,"91":1,"104":1,"129":1,"177":1,"222":1,"223":1}}],["c++std",{"2":{"109":2}}],["c++shared",{"2":{"52":1,"54":2}}],["c++中有两种注释",{"2":{"110":1}}],["c++中注释的种类",{"2":{"110":1}}],["c++中的每个变量都有其数据类型",{"2":{"66":1}}],["c++中",{"2":{"51":1}}],["c++$",{"2":{"46":1}}],["c++record",{"2":{"41":3}}],["c++return",{"2":{"37":1,"238":1}}],["c++还有一种特殊的形参类型",{"2":{"36":1}}],["c++alloc",{"2":{"60":1}}],["c++allocator",{"2":{"60":1}}],["c++assert",{"2":{"46":1}}],["c++argv",{"2":{"35":1}}],["c++auto",{"2":{"19":1,"52":1,"55":1,"57":1,"60":1,"98":2,"153":1,"192":1,"194":1,"229":1,"230":1,"231":2}}],["c++pmf",{"2":{"230":1}}],["c++pdata",{"2":{"229":1}}],["c++panda",{"2":{"219":1}}],["c++pair",{"2":{"17":3}}],["c++print",{"2":{"216":1}}],["c++prog",{"2":{"35":1}}],["c++plus",{"2":{"147":1}}],["c++pf",{"2":{"49":1}}],["c++语言提供了4种跳转语句",{"2":{"288":1}}],["c++语言提供了两种按条件执行的语句",{"2":{"280":1}}],["c++语言规定",{"2":{"282":1}}],["c++语言定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作",{"2":{"261":1}}],["c++语言定义了两个例外",{"2":{"176":1}}],["c++语言假定通过作用域运算符访问的名字不是类型",{"2":{"168":1}}],["c++语言中的大多数语句都以分号结束",{"2":{"278":1}}],["c++语言中有几种可调用的对象",{"2":{"148":1}}],["c++语言中大多数作用域都以花括号分隔",{"2":{"70":1}}],["c++语言已定义了其特殊含义",{"2":{"135":1}}],["c++语言不要求为一个类定义所有的拷贝控制操作",{"2":{"123":1}}],["c++语言允许用户以类的形式自定义数据类型",{"2":{"84":1}}],["c++语言允许将变量定义成数组的引用",{"2":{"34":1}}],["c++语言保留了一些名字供语言本身使用",{"2":{"69":1}}],["c++语言将声明和定义区分开来",{"2":{"68":1}}],["c++语言支持分离式编译",{"2":{"68":1}}],["c++语言支持所谓的分离式编译",{"2":{"29":1}}],["c++语言和标准库提供了两种一次分配一个对象数组的方法",{"2":{"58":1}}],["c++",{"2":{"27":1,"33":1,"34":4,"40":1,"41":1,"52":1,"53":1,"59":3,"88":1,"109":1,"110":1,"141":1,"147":1,"153":1,"159":1,"162":1,"167":2,"168":2,"172":1,"173":2,"174":2,"177":1,"178":1,"180":1,"181":1,"183":2,"187":1,"192":1,"193":1,"215":1,"216":1,"218":1,"222":1,"233":1,"236":2,"278":1,"291":2,"297":1,"308":1}}],["c++multimap",{"2":{"20":1}}],["c++map",{"2":{"15":1}}],["c++word",{"2":{"20":1}}],["c++while",{"2":{"4":1,"60":1,"112":1,"114":1,"278":1,"279":1,"294":1}}],["c++operator",{"2":{"150":1}}],["c++ofstream",{"2":{"8":1}}],["c++ostream",{"2":{"137":1}}],["c++os",{"2":{"5":1}}],["c++ival",{"2":{"278":1}}],["c++it",{"2":{"196":1}}],["c++item1",{"2":{"117":1}}],["c++istream",{"2":{"138":1}}],["c++if",{"2":{"52":1,"57":1,"115":1,"225":1}}],["c++ifstream",{"2":{"7":1}}],["c++int",{"2":{"4":1,"35":1,"39":1,"40":2,"44":1,"53":2,"59":1,"101":5,"103":5,"104":1,"105":3,"107":1,"109":1,"131":3,"145":1,"148":1}}],["ix",{"2":{"291":2}}],["implicit",{"2":{"273":1}}],["implementation",{"2":{"237":1}}],["identification",{"2":{"224":1}}],["identifier",{"2":{"69":1}}],["i是一个int",{"2":{"176":2}}],["i是一个int型的数",{"2":{"74":1}}],["i是整数",{"2":{"82":1}}],["i和j都必须定义在函数体外",{"2":{"79":1}}],["ip",{"2":{"55":2,"276":2}}],["ia转换成指向数组首元素的指针",{"2":{"103":1}}],["ia",{"2":{"41":1,"46":1,"103":5}}],["i",{"2":{"33":2,"40":9,"68":1,"74":3,"76":2,"78":2,"79":2,"82":6,"83":5,"88":3,"102":2,"103":2,"126":1,"131":5,"145":2,"148":2,"150":4,"156":1,"173":1,"176":4,"178":3,"180":1,"263":3,"275":2,"276":1,"279":3}}],["it>",{"2":{"174":3}}],["it2",{"2":{"98":1}}],["it1",{"2":{"98":1}}],["iter2",{"2":{"98":1,"99":1}}],["iter1",{"2":{"98":1,"99":1}}],["iter",{"2":{"98":5,"99":2,"263":1}}],["iterator只支持递增",{"2":{"200":1}}],["iterator向一个输出流写数据",{"2":{"197":1}}],["iterator读取输入流",{"2":{"197":1}}],["iterator类型的迭代器",{"2":{"98":1}}],["iterator来表示迭代器类型",{"2":{"98":1}}],["iterator",{"2":{"97":1,"98":4,"157":1,"188":1,"201":1}}],["item1",{"2":{"294":1}}],["item及其基类quote所属的命名空间中查找",{"2":{"213":1}}],["item类型是tuple",{"2":{"153":1}}],["item类型一样",{"2":{"84":1}}],["item2",{"2":{"117":1,"294":1}}],["item的别名",{"2":{"81":1}}],["item",{"2":{"81":1,"82":1,"137":5,"138":4,"153":5,"213":3,"299":2,"300":1}}],["it",{"2":{"19":3,"98":1,"174":6,"231":1}}],["ifdef",{"2":{"236":1}}],["if前缀",{"2":{"202":1}}],["if版本的算法",{"2":{"202":1}}],["if也对一个条件求值",{"2":{"115":1}}],["if语句的作用是",{"2":{"281":1}}],["if语句",{"0":{"115":1,"281":1}}],["ifndef",{"2":{"46":1,"86":1}}],["if",{"2":{"17":1,"39":1,"132":1,"166":2,"168":2,"193":1,"202":1,"226":2,"231":4,"291":1,"294":1}}],["is读取下一个字节存入字符ch中",{"2":{"162":1}}],["istream对象的状态会变为无效",{"2":{"114":1}}],["istream",{"2":{"84":1,"132":1,"138":1,"197":1}}],["istringstream从string读取数据",{"2":{"9":1}}],["is",{"2":{"46":1,"91":2,"109":1,"138":3,"156":2,"162":5}}],["isbn",{"2":{"16":2,"117":2,"137":1,"140":2,"153":1,"293":1,"297":1,"298":1}}],["invalid",{"2":{"329":1}}],["incomplete",{"2":{"247":1}}],["include指令一般出现在所有函数之外",{"2":{"109":1}}],["include指令和头文件的名字必须写在同一行中",{"2":{"109":1}}],["include",{"2":{"73":1,"88":1,"109":2}}],["info对象",{"2":{"227":1}}],["info对象t1和t2表示同一种类型",{"2":{"227":1}}],["info类必须定义在typeinfo头文件中",{"2":{"227":1}}],["info类的精确定义随着编译器的不同而略有差异",{"2":{"227":1}}],["info类",{"0":{"227":1}}],["info类定义在typeinfo头文件中",{"2":{"226":1}}],["info的公有派生类型",{"2":{"226":1}}],["info或者type",{"2":{"226":1}}],["inheritance",{"2":{"218":1,"297":1}}],["instantiation",{"2":{"170":1}}],["instantiate",{"2":{"166":1}}],["inserter",{"2":{"188":1,"196":3}}],["insert",{"2":{"20":6,"188":1,"326":3}}],["init",{"2":{"113":1,"285":1}}],["initialization",{"2":{"67":1,"90":2}}],["initialize",{"2":{"94":1,"109":1,"240":1}}],["initialized",{"2":{"67":2}}],["initializers",{"2":{"223":2}}],["initializer",{"2":{"36":4,"85":1,"141":1}}],["input",{"2":{"109":1,"228":1}}],["inner",{"2":{"70":1}}],["inline成员函数通常定义到类的头文件中",{"2":{"245":1}}],["inline或constexpr说明符放在模板参数列表之后",{"2":{"166":1}}],["inline和constexpr的函数模板",{"2":{"166":1}}],["inline",{"2":{"45":1,"166":1}}],["integral",{"2":{"274":1}}],["interface",{"2":{"237":1}}],["intermediary",{"2":{"178":1}}],["intadd",{"2":{"147":2}}],["int类型的形参",{"2":{"143":1}}],["int类型是一种内置类型",{"2":{"107":1}}],["int",{"2":{"33":2,"34":9,"35":1,"40":13,"41":3,"44":1,"45":2,"46":1,"47":3,"49":5,"53":8,"54":3,"55":5,"56":1,"59":9,"65":1,"67":5,"68":2,"72":2,"73":10,"74":1,"75":2,"76":8,"77":2,"78":6,"79":9,"82":4,"83":4,"88":2,"101":2,"103":3,"105":7,"109":2,"113":1,"126":1,"131":4,"143":2,"145":2,"147":3,"148":16,"150":4,"153":1,"159":1,"166":1,"168":3,"172":1,"173":1,"175":6,"176":8,"178":6,"180":2,"183":2,"208":2,"213":1,"236":1,"263":2,"266":1,"273":1,"275":2,"276":1,"279":1,"291":2,"301":1}}],["int>",{"2":{"17":3,"52":3,"53":2,"54":3,"55":2,"56":1,"57":3,"93":1,"96":1,"98":2,"104":1,"147":1,"150":1,"153":1,"168":1}}],["int>>",{"2":{"17":1}}],["in",{"2":{"7":1,"20":1,"85":1,"107":1}}],["ival",{"2":{"4":2,"72":2,"73":4,"233":3,"273":1,"278":1}}],["io",{"2":{"162":1}}],["io标准库分别使用",{"2":{"136":1}}],["io对象无拷贝或赋值",{"0":{"3":1}}],["iostream迭代器",{"0":{"197":1}}],["iostream则可以使用g版本又可以使用p版本",{"2":{"163":1}}],["iostream库包含两个基础类型istream和ostream",{"2":{"109":1}}],["iostream>",{"2":{"88":1,"109":1}}],["iostream",{"2":{"2":1,"109":1}}],["io类型维护一个标记来确定下一个读写操作要在哪里进行",{"2":{"163":1}}],["io类型间的关系",{"2":{"2":1}}],["io类定义了一些函数和标志",{"2":{"4":1}}],["io类",{"0":{"2":1},"1":{"3":1,"4":1,"5":1}}],["io库再探",{"0":{"160":1},"1":{"161":1,"162":1,"163":1}}],["io库定义了用其读写内置类型的版本",{"2":{"136":1}}],["io库还提供了两个操纵符用于刷新缓冲区",{"2":{"5":1}}],["io库",{"0":{"1":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1},"2":{"0":1}}],["泛型算法结构",{"0":{"199":1},"1":{"200":1,"201":1,"202":1}}],["泛型算法",{"0":{"184":1},"1":{"185":1,"186":1,"187":1,"188":1,"189":1,"190":1,"191":1,"192":1,"193":1,"194":1,"195":1,"196":1,"197":1,"198":1,"199":1,"200":1,"201":1,"202":1,"203":1},"2":{"0":1}}],["类不能继承默认",{"2":{"309":1}}],["类派生列表",{"2":{"297":1}}],["类必须使用析构函数的默认定义",{"2":{"257":1}}],["类也可以是字面值类型",{"2":{"257":1}}],["类成员再探",{"0":{"245":1}}],["类成员指针",{"0":{"229":1},"1":{"230":1,"231":1}}],["类通过",{"2":{"240":1}}],["类通过一个或几个特殊的成员函数初始化其成员变量",{"2":{"240":1}}],["类通常被定义在头文件中",{"2":{"86":1}}],["类本身就是一个作用域",{"2":{"238":1}}],["类作用域和成员函数",{"2":{"238":1}}],["类内的所有成员必须声明在类的内部",{"2":{"238":1}}],["类内初始值将用于初始化数据成员",{"2":{"85":1}}],["类类型能定义由编译器自动执行的转换",{"2":{"275":1}}],["类类型定义的转换",{"2":{"275":1}}],["类类型等",{"2":{"258":1}}],["类类型成员必须使用自己的constexpr构造函数",{"2":{"257":1}}],["类类型",{"0":{"247":1},"2":{"193":1}}],["类或函数",{"2":{"167":1}}],["类可以把普通函数定义成友元",{"2":{"248":1}}],["类可以允许其他类或者函数访问它的非公有成员",{"2":{"243":1}}],["类可以定义在某个函数的内部",{"2":{"234":1}}],["类可以授权给所有友元模板实例",{"2":{"167":1}}],["类可以控制其对象如何赋值",{"2":{"121":1}}],["类与友元各自是否是模板是相互无关的",{"2":{"167":1}}],["类模板可以声明static成员",{"2":{"167":1}}],["类模板与另一个模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系",{"2":{"167":1}}],["类模板的每个实例都有其自己版本的成员函数",{"2":{"167":1}}],["类模板的成员函数具有和类模板相同的模板参数",{"2":{"167":1}}],["类模板的成员函数本身是一个普通函数",{"2":{"167":1}}],["类模板的成员函数",{"2":{"167":1}}],["类模板以关键字template开始",{"2":{"167":1}}],["类模板",{"0":{"167":1},"2":{"167":1}}],["类定义必须是可用的",{"2":{"166":1}}],["类很少提供类型转换运算符",{"2":{"150":1}}],["类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象",{"2":{"141":1}}],["类值拷贝赋值运算符",{"2":{"127":1}}],["类的对象",{"2":{"258":1}}],["类的静态成员",{"0":{"258":1}}],["类的作用域之外",{"2":{"249":1}}],["类的作用域",{"0":{"249":1},"1":{"250":1}}],["类的成员函数可以直接访问静态成员",{"2":{"258":1}}],["类的成员函数可以定义在类的内部",{"2":{"238":1}}],["类的成员函数定义成友元",{"2":{"248":1}}],["类的声明",{"2":{"247":1}}],["类的其它特性",{"0":{"244":1},"1":{"245":1,"246":1,"247":1,"248":1}}],["类的基本思想是数据抽象",{"2":{"237":1}}],["类的某些特性对union同样适用",{"2":{"233":1}}],["类的行为像一个指针",{"2":{"126":1}}],["类的行为像一个值",{"2":{"126":1}}],["类的数据成员定义了类的对象的具体内容",{"2":{"85":1}}],["类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝",{"2":{"125":1}}],["类似容器",{"2":{"200":1}}],["类似任何普通类的数据成员",{"2":{"193":1}}],["类似地",{"2":{"193":1}}],["类似sizeof",{"2":{"180":1}}],["类似函数参数的名字",{"2":{"168":1}}],["类似函数模板",{"2":{"167":1}}],["类似的",{"2":{"166":1,"303":1,"308":2}}],["类似make",{"2":{"153":1}}],["类似拷贝赋值运算符",{"2":{"132":1}}],["类似其他任何表达式",{"2":{"131":1}}],["类似使用标准库设施",{"2":{"116":1}}],["类似于变量",{"2":{"28":1}}],["类简介",{"0":{"116":1},"1":{"117":1}}],["类数据成员的初始值",{"2":{"245":1}}],["类数据成员",{"2":{"85":1}}],["类体定义类的成员",{"2":{"85":1}}],["类体右侧的表示结束的花括号后必须写一个分号",{"2":{"85":1}}],["类体由花括号包围形成了一个新的作用域",{"2":{"85":1}}],["类static数据成员以及定义在任何函数之外的变量",{"2":{"50":1}}],["类型支持顺序容器的赋值运算符以及",{"2":{"326":1}}],["类型还提供了一些额外的操作",{"2":{"324":1}}],["类型一旦不符",{"2":{"276":1}}],["类型名字的生成方式因系统而异",{"2":{"227":1}}],["类型推断过程类似普通的推断过程",{"2":{"176":1}}],["类型blob",{"2":{"167":1}}],["类型参数的数目",{"2":{"180":1}}],["类型参数前必须使用关键字class或typename",{"2":{"166":1}}],["类型参数可以用来指定返回类型或函数的参数类型",{"2":{"166":1}}],["类型或分布时",{"2":{"158":1}}],["类型",{"2":{"107":1,"158":2}}],["类型修饰符从右向左依次绑定",{"2":{"101":1}}],["类型别名简化多维数组的指针",{"2":{"105":1}}],["类型别名",{"0":{"81":1},"2":{"81":1}}],["类型比较简单",{"2":{"79":1}}],["类型等",{"2":{"70":1}}],["类型是int",{"2":{"65":1}}],["类型所能表示的值的范围决定了转换的过程",{"2":{"64":1}}],["类型转换模板在普通编程中也很有用",{"2":{"174":1}}],["类型转换与继承",{"0":{"300":1}}],["类型转换与多个基类",{"0":{"216":1}}],["类型转换与模板类型参数",{"0":{"172":1}}],["类型转换与运算符",{"0":{"149":1},"1":{"150":1}}],["类型转换运算符通常不应该改变待转换对象的内容",{"2":{"150":1}}],["类型转换运算符既没有显式的返回类型",{"2":{"150":1}}],["类型转换运算符可以面向任意类型",{"2":{"150":1}}],["类型转换运算符",{"0":{"150":1},"2":{"150":1}}],["类型转换",{"0":{"64":1,"273":1},"1":{"274":1,"275":1,"276":1}}],["类型char会表现为上述形式中的一种",{"2":{"63":1}}],["类型float和double分别有7和16个有效位",{"2":{"63":1}}],["类型来管理动态对象",{"2":{"51":1}}],["类型的方法有",{"2":{"49":1}}],["类型的形参",{"2":{"34":1}}],["类型ifstream和istringstream都继承自istream",{"2":{"2":1}}],["类",{"0":{"212":1,"237":1},"1":{"238":1,"239":1,"240":1,"241":1,"242":1,"243":1,"244":1,"245":1,"246":1,"247":1,"248":1,"249":1,"250":1,"251":1,"252":1,"253":1,"254":1,"255":1,"256":1,"257":1,"258":1},"2":{"0":1}}],["函数在寻找处理代码的过程中退出",{"2":{"294":1}}],["函数形式的强制类型转换",{"2":{"276":1}}],["函数调用返回一个右值",{"2":{"261":1}}],["函数调用返回一个左值",{"2":{"261":1}}],["函数调用是一种特殊的运算符",{"2":{"261":1}}],["函数调用运算符",{"0":{"145":1},"1":{"146":1,"147":1,"148":1},"2":{"145":1}}],["函数体前的一部分内容叫构造函数初始值列表",{"2":{"240":1}}],["函数体是一个以左花括号",{"2":{"107":1}}],["函数就可以返回this对象的引用",{"2":{"238":1}}],["函数参数类型必须与一个先前声明的模板中对应的类型匹配",{"2":{"183":1}}],["函数参数的数目",{"2":{"180":1}}],["函数参数包",{"2":{"180":1}}],["函数参数折叠为int",{"2":{"176":1}}],["函数参数为int",{"2":{"176":1}}],["函数模板可以被另一个模板或一个普通非模板函数重载",{"2":{"179":1}}],["函数模板可以有用普通类型定义的参数",{"2":{"172":1}}],["函数模板显式实参",{"0":{"173":1}}],["函数模板",{"0":{"166":1}}],["函数regex",{"2":{"157":1}}],["函数对象类的对象",{"2":{"148":1}}],["函数及函数指针的类型由其返回值和实参类型决定",{"2":{"148":1}}],["函数结束时shared",{"2":{"55":1}}],["函数指针和实参推断",{"0":{"175":1}}],["函数指针形参",{"2":{"49":1}}],["函数指针指向的是函数而非对象",{"2":{"49":1}}],["函数指针",{"0":{"49":1},"2":{"148":2}}],["函数匹配的第一步是选定本次调用对应的重载函数集",{"2":{"47":1}}],["函数匹配",{"0":{"47":1},"1":{"48":1},"2":{"41":1}}],["函数重载",{"0":{"41":1},"1":{"42":1}}],["函数将不断地调用它自身直到程序栈空间耗尽为止",{"2":{"39":1}}],["函数将",{"2":{"39":1}}],["函数可以返回数组的指针或引用",{"2":{"40":1}}],["函数可以返回花括号包围的值的列表",{"2":{"39":1}}],["函数可以有0个或多个参数",{"2":{"25":1}}],["函数终止意味着局部变量的引用将指向不再有效的内存区域",{"2":{"39":1}}],["函数完成后",{"2":{"39":1}}],["函数名",{"2":{"28":1}}],["函数名字",{"2":{"26":1}}],["函数只能定义一次",{"2":{"28":1}}],["函数声明还要在别的地方声明",{"2":{"243":1}}],["函数声明也称作函数原型",{"2":{"28":1}}],["函数声明",{"0":{"28":1}}],["函数一旦终止",{"2":{"27":1}}],["函数开始时为形参申请存储空间",{"2":{"27":1}}],["函数的一个版本用元素类型的运算符来比较元素",{"2":{"202":1}}],["函数的类型由它的返回类型和形参类型共同决定",{"2":{"49":1}}],["函数的名字仅仅是让编译器知道它调用的是哪个函数",{"2":{"41":1}}],["函数的名字必须在使用之前声明",{"2":{"28":1}}],["函数的意图是作用于一个数组",{"2":{"34":1}}],["函数的三要素",{"2":{"28":1}}],["函数的声明和定义唯一的区别是声明无须函数体",{"2":{"28":1}}],["函数的返回类型及所有形参都得是字面值类型",{"2":{"45":1}}],["函数的返回类型不能是数组类型或函数类型",{"2":{"27":1}}],["函数的返回值用于初始化调用表达式的结果",{"2":{"26":1}}],["函数的调用完成两项工作",{"2":{"26":1}}],["函数基础",{"0":{"26":1},"1":{"27":1,"28":1,"29":1}}],["函数是一个命名了的代码块",{"2":{"25":1}}],["函数",{"0":{"25":1,"328":1},"1":{"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1},"2":{"0":1,"41":1,"70":1,"98":1,"148":1}}],["第九章",{"0":{"310":1},"1":{"311":1,"312":1,"313":1,"314":1,"315":1,"316":1,"317":1,"318":1,"319":1,"320":1,"321":1,"322":1,"323":1,"324":1,"325":1,"326":1,"327":1,"328":1,"329":1}}],["第五章",{"0":{"277":1},"1":{"278":1,"279":1,"280":1,"281":1,"282":1,"283":1,"284":1,"285":1,"286":1,"287":1,"288":1,"289":1,"290":1,"291":1,"292":1,"293":1,"294":1,"295":1}}],["第四章",{"0":{"259":1},"1":{"260":1,"261":1,"262":1,"263":1,"264":1,"265":1,"266":1,"267":1,"268":1,"269":1,"270":1,"271":1,"272":1,"273":1,"274":1,"275":1,"276":1}}],["第七章",{"0":{"237":1},"1":{"238":1,"239":1,"240":1,"241":1,"242":1,"243":1,"244":1,"245":1,"246":1,"247":1,"248":1,"249":1,"250":1,"251":1,"252":1,"253":1,"254":1,"255":1,"256":1,"257":1,"258":1}}],["第三个表示第二个序列的首元素",{"2":{"187":1}}],["第三章",{"0":{"87":1},"1":{"88":1,"89":1,"90":1,"91":1,"92":1,"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1}}],["第三步是从可行函数中选择与本次调用最匹配的函数",{"2":{"47":1}}],["第一种情况中",{"2":{"225":1}}],["第一种例外情况是允许令一个指向常量的指针指向一个非常量对象",{"2":{"77":1}}],["第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值",{"2":{"76":1}}],["第一步调用处理包中的第一个实参",{"2":{"181":1}}],["第一章",{"0":{"106":1},"1":{"107":1,"108":1,"109":1,"110":1,"111":1,"112":1,"113":1,"114":1,"115":1,"116":1,"117":1}}],["第一个模板实参与第一个模板参数匹配",{"2":{"173":1}}],["第一个参数argc表示数组中字符串的数量",{"2":{"35":1}}],["第一个形参的类型应该是const",{"2":{"33":1}}],["第二种形式中",{"2":{"271":1}}],["第二条有一个重要例外",{"2":{"263":1}}],["第二个扩展发生在对print的调用中",{"2":{"182":1}}],["第二个扩展操作出现在对print的调用中",{"2":{"182":1}}],["第二个实参与第二个参数匹配",{"2":{"173":1}}],["第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将输入读入到这个对象中",{"2":{"138":1}}],["第二个形参是将要读入到的",{"2":{"138":1}}],["第二个形参一般来说是一个常量的引用",{"2":{"137":1}}],["第二个维度看作列",{"2":{"105":1}}],["第二章",{"0":{"61":1},"1":{"62":1,"63":1,"64":1,"65":1,"66":1,"67":1,"68":1,"69":1,"70":1,"71":1,"72":1,"73":1,"74":1,"75":1,"76":1,"77":1,"78":1,"79":1,"80":1,"81":1,"82":1,"83":1,"84":1,"85":1,"86":1}}],["第二步考察本次调用提供的实参",{"2":{"47":1}}],["第十五章",{"0":{"296":1},"1":{"297":1,"298":1,"299":1,"300":1,"301":1,"302":1,"303":1,"304":1,"305":1,"306":1,"307":1,"308":1,"309":1}}],["第十章",{"0":{"184":1},"1":{"185":1,"186":1,"187":1,"188":1,"189":1,"190":1,"191":1,"192":1,"193":1,"194":1,"195":1,"196":1,"197":1,"198":1,"199":1,"200":1,"201":1,"202":1,"203":1}}],["第十六章",{"0":{"164":1},"1":{"165":1,"166":1,"167":1,"168":1,"169":1,"170":1,"171":1,"172":1,"173":1,"174":1,"175":1,"176":1,"177":1,"178":1,"179":1,"180":1,"181":1,"182":1,"183":1}}],["第十四章",{"0":{"134":1},"1":{"135":1,"136":1,"137":1,"138":1,"139":1,"140":1,"141":1,"142":1,"143":1,"144":1,"145":1,"146":1,"147":1,"148":1,"149":1,"150":1}}],["第十三章",{"0":{"118":1},"1":{"119":1,"120":1,"121":1,"122":1,"123":1,"124":1,"125":1,"126":1,"127":1,"128":1,"129":1,"130":1,"131":1,"132":1,"133":1}}],["第十二章",{"0":{"50":1},"1":{"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1}}],["第十一章",{"0":{"12":1},"1":{"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1}}],["第六章",{"0":{"25":1},"1":{"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1}}],["第295页",{"2":{"18":1}}],["第294页",{"2":{"14":1}}],["第2章",{"2":{"0":1}}],["第八章",{"0":{"1":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"9":1,"10":1,"11":1}}],["第19章",{"0":{"220":1},"1":{"221":1,"222":1,"223":1,"224":1,"225":1,"226":1,"227":1,"228":1,"229":1,"230":1,"231":1,"232":1,"233":1,"234":1,"235":1,"236":1},"2":{"0":1}}],["第18章",{"0":{"204":1},"1":{"205":1,"206":1,"207":1,"208":1,"209":1,"210":1,"211":1,"212":1,"213":1,"214":1,"215":1,"216":1,"217":1,"218":1,"219":1},"2":{"0":1}}],["第17章",{"0":{"151":1},"1":{"152":1,"153":1,"154":1,"155":1,"156":1,"157":1,"158":1,"159":1,"160":1,"161":1,"162":1,"163":1},"2":{"0":1}}],["第16章",{"2":{"0":1}}],["第15章",{"2":{"0":1}}],["第14章",{"2":{"0":1}}],["第13章",{"2":{"0":1}}],["第12章",{"2":{"0":1}}],["第11章",{"2":{"0":1}}],["第10章",{"2":{"0":1}}],["第1章",{"2":{"0":1}}],["第9章",{"2":{"0":1}}],["第8章",{"2":{"0":1}}],["第7章",{"2":{"0":1}}],["第6章",{"2":{"0":1}}],["第5章",{"2":{"0":1}}],["第4章",{"2":{"0":1}}],["第3章",{"2":{"0":1}}],["开始的所有字符",{"2":{"325":1}}],["开始的字符拷贝",{"2":{"325":1}}],["开始执行",{"2":{"26":1}}],["开始",{"0":{"106":1},"1":{"107":1,"108":1,"109":1,"110":1,"111":1,"112":1,"113":1,"114":1,"115":1,"116":1,"117":1},"2":{"0":1,"35":1,"107":1,"110":1,"325":1}}]],"serializationVersion":2}';export{t as default};
