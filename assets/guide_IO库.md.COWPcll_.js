import{_ as e,C as t,c as n,o as p,j as i,G as l,a6 as r,a as h}from"./chunks/framework.CL7CCNs_.js";const E=JSON.parse('{"title":"IO库","description":"","frontmatter":{"title":"IO库","order":8},"headers":[],"relativePath":"guide/IO库.md","filePath":"guide/IO库.md","lastUpdated":1752168674000}'),d={name:"guide/IO库.md"};function o(k,s,c,g,u,m){const a=t("ArticleMetadata");return p(),n("div",null,[s[0]||(s[0]=i("h1",{id:"第八章-io库",tabindex:"-1"},[h("第八章 IO库 "),i("a",{class:"header-anchor",href:"#第八章-io库","aria-label":'Permalink to "第八章 IO库"'},"​")],-1)),l(a),s[1]||(s[1]=r(`<h2 id="io类" tabindex="-1">IO类 <a class="header-anchor" href="#io类" aria-label="Permalink to &quot;IO类&quot;">​</a></h2><p>为了支持不同种类的IO处理操作，标准库定义了这几种类型：</p><ul><li><p>iostream 定义了用于读写流的基本类型</p></li><li><p>fstream 定义了读写命名文件的类型</p></li><li><p>sstream 定义了读写内存string对象的类型</p></li></ul><p>它们分别定义在同名的头文件中。</p><p><strong>IO类型间的关系</strong></p><p>类型ifstream和istringstream都继承自istream。我们可以像使用istream对象一样来使用它们。对于ostream也是如此。</p><h3 id="io对象无拷贝或赋值" tabindex="-1">IO对象无拷贝或赋值 <a class="header-anchor" href="#io对象无拷贝或赋值" aria-label="Permalink to &quot;IO对象无拷贝或赋值&quot;">​</a></h3><p>由于不能拷贝IO对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递或返回流。</p><p>读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p><h3 id="条件状态" tabindex="-1">条件状态 <a class="header-anchor" href="#条件状态" aria-label="Permalink to &quot;条件状态&quot;">​</a></h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态。见p279。</p><p>一个IO错误的例子：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ival;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ival;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果试图在标准输入上键入Boo，读操作就会失败，cin进入错误状态。</p><p>如果输入一个文件结束符标识，cin也会进入错误状态。</p><p>一个流一旦发生错误，其上后续的IO操作都会失败。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (cin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> word)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ok</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>!!!note 读取失败后，不会消耗掉缓冲区的内容。因此这种情况，通常读取一个字符串，然后转换字符串为数字。</p><h3 id="管理输出缓冲" tabindex="-1">管理输出缓冲 <a class="header-anchor" href="#管理输出缓冲" aria-label="Permalink to &quot;管理输出缓冲&quot;">​</a></h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行下面的代码：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">os </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;please enter a value: &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。这样可以带来很大的性能提升。</p><p>导致缓冲区刷新的原因有：</p><ul><li><p>程序正常结束</p></li><li><p>缓冲区满时</p></li><li><p>使用操纵符，如endl，来显式刷新缓冲区</p></li><li><p>读cin或写cerr，都会导致cout的缓冲区被刷新</p></li></ul><p><strong>刷新输出缓冲区</strong></p><p>IO库还提供了两个操纵符用于刷新缓冲区：</p><ul><li><p>flush 刷新缓冲区，但不输出任何额外字符</p></li><li><p>ends 向缓冲区插入一个空字符，然后刷新缓冲区</p></li></ul><p><strong>unitbuf操纵符</strong></p><p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unitbuf;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 所有输出操作后都会立即刷新缓冲区</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nounitbuf;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 回到正常的缓冲方式</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>!!!warning 如果程序崩溃，输出缓冲区不会刷新</p><h2 id="文件输入输出" tabindex="-1">文件输入输出 <a class="header-anchor" href="#文件输入输出" aria-label="Permalink to &quot;文件输入输出&quot;">​</a></h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。见p283。</p><h3 id="使用文件流对象" tabindex="-1">使用文件流对象 <a class="header-anchor" href="#使用文件流对象" aria-label="Permalink to &quot;使用文件流对象&quot;">​</a></h3><p>当想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p><p>每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。</p><p>创建文件流对象时，如果提供了一个文件名，则open会被自动调用：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ifstream</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 构造一个ifstream并打开给定的文件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ofstream out;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         // 输出文件流未关联到任何文件</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>!!!note 当一个fstream对象被销毁时，close会自动被调用。</p><h3 id="文件模式" tabindex="-1">文件模式 <a class="header-anchor" href="#文件模式" aria-label="Permalink to &quot;文件模式&quot;">​</a></h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。见p286。</p><p>每个文件流类型都定义了一个默认的文件模式，当未指定文件模式时，就使用此默认模式。</p><ul><li><p>与ifstream关联的文件默认以in模式打开；</p></li><li><p>与ofstream关联的文件默认以out模式打开；</p></li><li><p>与fstream关联的文件默认以in和out模式打开。</p></li></ul><p><strong>以out模式打开文件会丢失已有数据</strong></p><p>默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。</p><p>阻止丢弃的方法是同时指定app模式：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofstream</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 文件被截断</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofstream</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;file2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofstream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 保留文件内容，写操作在文件末尾进行</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="string流" tabindex="-1">string流 <a class="header-anchor" href="#string流" aria-label="Permalink to &quot;string流&quot;">​</a></h2><p>sstream头文件定义了三个类型来支持内存IO：</p><ul><li><p>istringstream从string读取数据。</p></li><li><p>ostringstream向string写入数据。</p></li><li><p>stringstream既可以从string读数据，也可以向string写数据。</p></li></ul><p>sstream增加了一些成员来管理与流相关联的string。见p287。</p><h3 id="使用istringstream" tabindex="-1">使用istringstream <a class="header-anchor" href="#使用istringstream" aria-label="Permalink to &quot;使用istringstream&quot;">​</a></h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p><h3 id="使用ostringstream" tabindex="-1">使用ostringstream <a class="header-anchor" href="#使用ostringstream" aria-label="Permalink to &quot;使用ostringstream&quot;">​</a></h3><p>当我们逐步构造输出，希望最后一期打印时，ostringstream是很有用的。</p>`,55))])}const y=e(d,[["render",o]]);export{E as __pageData,y as default};
